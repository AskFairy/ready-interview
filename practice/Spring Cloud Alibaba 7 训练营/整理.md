“什么样的架构才是适合在云环境中运行”是一个非常大的问题，在此先不展开讨论，而是到 

CNCF 对云原生的定义：

> 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。
>
> 云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。
>
> 这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。

 [Spring Cloud](https://spring.io/projects/spring-cloud) 框架。该框架是对云环境下微服务开发中**需要解决的各种问题的标准化**，*以帮助开发者快速实现分布式系统中的某些常见模式（例如，配置管理，服务发现，断路器等）*。

\- 微服务的发展历程
\- 微服务的基本形式
\- Spring 、Spring Boot 、Spring Cloud 的职责与关系
\- Spring Cloud Alibaba 的功能与定位
\- Java 工程脚手架的使用方法
\- Sandbox 沙箱环境的使用发方法

## 理论篇

俗话说，没有最好的架构，只有最合适的架构。我们认为架构发展历史经历了这样一个过程：`单体架构 -> SOA 面向服务架构 -> 微服务架构`

## 单体架构

MVC架构以及由此衍生出来各种多层架构，由此便开启了应用的拆分之旅。多层架构的本质，是按照技术职责将应用做水平拆分，每一层解决的技术问题相对集中，层与层之间做单向依赖。这样做可以帮助我们更好的管理我们的代码，大大提升了后期的维护效率。

优点：

- 开发简单。
- 测试简单。
- 部署简单。
- 开发迅速。

单体应用的弊端：

- 应用膨胀。
- 团队合作冲突。
- 运行效率&稳定性。

单体架构原有的迅速、简单的优点，随着规模的扩大（功能、团队），会变得荡然无存。

为了能解决这些问题，我们自然而然就会想到分而治之的办法，即将原来的单体应用拆分开来。但是应用该怎么拆分？拆分后又会有哪些新的问题产生？如何解决这些新的问题？就留给下面的 SOA 架构来解答。

### SOA 架构

SOA 是 Service-Oriented Architecture 的简写，直译为“面向服务的架构”，从命名上就可以看出“服务”是 SOA 架构里是非常重要的概念。SOA 的核心思想是“**将系统的功能解构为一系列服务**”：

> 面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和协议联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构件在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。

与单体架构按照技术职责进行水平拆分不同，SOA 会按照**业务领域对应用进行粗粒度的垂直拆分**。

一个典型的 SOA 架构模式如下图：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2020/png/10720/1597845919808-af7896d5-403d-4f33-a1d8-1a82e16a2013.png#align=left&display=inline&height=238&margin=[object Object]&name=image.png&originHeight=238&originWidth=500&size=124698&status=done&style=none&width=500)

SOA 并不完美，他也有很多问题的或者说是场景下的不适应。

- 首先就是对 SOA 的**解释缺乏统一标准**。
- **高门槛**。ESB （Enterprise Service Bus, 企业服务总线）本身就是一套非常复杂的系统，**通过 ESB 落地 SOA ，对开发人员的要求很高**。甚至还会需要厂商参与；
- **厂商绑定**。由于缺乏统一保准，不同厂商的解决方案之间很难做切换。
- **不适应云环境**。在如今的互联网时代，速度就是一切。由此诞生了*敏捷开发、持续集成等在不同节点提升业务上线速度的办法*。但是方向是不一致的。
- **中心化**。虽然应用本身实现了分布式与水平扩展，但是 **ESB 却成了系统的中枢神经**。

### 微服务架构

对于微服务架构，一直有一种说法，认为它是SOA架构的一种变体，或者是SOA的子集。关于这个问题，我们不去讨论他的对错（其实也没有对错之分），我们直接从这两者的区别入手来理解到底什么是微服务：

|            | 传统SOA                     | 微服务                                                       |
| ---------- | --------------------------- | ------------------------------------------------------------ |
| 通信方式   | 基于ESB，SOAP、WSDL等重协议 | 点对点通信，开放式协议，如 RESTful、gRPC、或者是轻量级的二进制协议。 |
| 数据管理   | 全局数据模型以及共享存储    | 每个服务独立模型和存储                                       |
| 服务粒度   | 较粗                        | 较细                                                         |
| 诞生的背景 | **企业级应用**              | **互联网**                                                   |
| 解决的问题 | 面向企业内，系统集成。      | 面向最终产品，解决扩展，维护的问题。                         |
|            | 复用                        | 扩展                                                         |

通信手段、数据等的不同只是表象，其本质区别还是由于**两者诞生于不同历史时期，需要解决的问题域不同。**

**SOA** 解决的核心问题是**复用**，而**微服务**解决的核心问题是**扩展**。

### 微服务

什么是微服务，几个重要的概念：

- **一套小服务**

- 独立进程

- **轻量级通信协议**

- 可独立部署

- 多语言&不同储技术

在实际生产环境中，微服务的架构要考虑的问题远比上面的示意图复杂的多，主要包括但不限于如下问题：

- 通过服务实现组件化

- 根据业务组织系统

- 做产品而不是做项目

- 简单高效的通信协议

- 自动化基础设施

- 面向失败的设计

- 具备进化能力的设计

纵然有 Martin Fowler 这样的大神在前面引路，但是我们依然认为**“微服务”不是一个被设计出来的架构，而是在不断是尝试中总结出的一套适合在互联网行业使用的架构模式**。

**它既是一种架构模式，也是实现这种架构模式时所使用的技术方案的集合。**

**“微服务”不是银弹**
微服务自身的限制拖入另一个泥潭：

- **分布式的代价**。原本在单体应用中，很多简单的问题都会在分布式环境下被几何级的放大。例如**分布式事务、分布式锁、远程调用**等，不光要考虑如何实现他们，相关场景的异常处理也是必须要考虑到的问题。

- **协同代价**。如果你经历过一个项目上线需要发布十几个应用，而这些应用又分别由多个团队在维护。你就能深刻的体会到协同是一件多么痛苦的事情了。

- **服务拆分需要很强的设计功力**。微服务的各种优势，其中一个重要的基础是对服务领域的正确切分。如果使用了不合适的切分粒度，或者是错误的切分方法，都会让服务不能很好的实现高内聚低耦合的要求。