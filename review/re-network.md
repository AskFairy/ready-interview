



# 网络

## OSI七层体系结构

概念清楚、理论完整，理论上的国际标准

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层

## TCP/IP 四层体系结构



事实上的国际标准

自上而下是：

- 应用层：

  - 功能：负责**处理应用程序的逻辑**，比如文件传输，名称查询和网络管理等。

  > HTTP协议：从 **Web 服务器传输超文本到本地浏览器**的传送协议。
  >
  > Telnet协议：基于**23端口**，用于远程登陆。例：xshell
  >
  > FTP协议：基于**21端口**，文件传输协议。例：xftp
  >
  > SMTP邮件**发送**协议：**25端口**
  >
  > POP3邮件**接收**协议：**110端口**

- 传输层

  - 功能：提供**应用程序（两台计算机的进程）间**的通信
  - 设备：
  - 协议：

  > - TCP：
  >   - 传输层通信协议
  >   - 面向连接、点对点、可靠、双工通信、面向字节流
  >   - 对应应用层协议
  >     - FTP
  >     - Telnet
  >     - SMTP
  >     - POP3
  >     - HTTP 
  > - UDP
  >   - DNS：**53端口**

- 网络层

  -  功能：负责相邻计算机之间的通信，数据包的选路和转发。

  - 设备：路由器

  - 协议：

    > IP（IPV4/IPV6）
    >
    > - ARP协议、RARP协议：
    >
    > - ICMP协议（Ping/Traceroute命令）

- 数据链路层

  - 功能：发送和接收 IP数据报、ARP请求或应答、ARP请求或应答。

  - 设备：网线、网桥、集线器、交换机

  - 协议：

    > PPP：在同一条**物理链路**上进行**点对点**的数据传输协议

### 数据交换设备

- **网关**（应用层、传输层）：
  - 网关在**传输层上以实现网络互连**，是最复杂的网络互连设备，**仅用于两个高层协议不同的网络互连**。
  - 网关的结构也和路由器类似，不同的是互连层。网关**既可以用于广域网互连，也可以用于局域网互连**。
- **路由器**：**路由选择、存储转发**
  - 常见的路由选择协议有：RIP 协议、OSPF 协议。
    - RIP 协议：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是 15 跳。如果大于 15 跳，它就会丢弃数据包。
    - OSPF 协议：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。
- **交换机**：数据链路层、网络层
  - **识别**数据包中的 **MAC 地址**信息，根据 MAC 地址**进行转发**，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表（**ARP表**）中。
- 网桥：数据链路层
  - 将两个 LAN 连起来，根据 MAC 地址来转发帧。
- 集线器（Hub）：物理层
  - 纯硬件设备，主要用来连接计算机等网络终端。
- 中继器：物理层
  - 在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离。

###  **详细说明 Keepalived 的故障切换工作原理？**

这种故障切换，是通过 **VRRP** 协议来实现的。

​    **VRRP** 协议主备故障切换：心跳->故障广播->节点接管->恢复退位



## IP

IP 地址是指**互联网协议地址**，主机的一个**逻辑地址**，以此来**屏蔽物理地址的**差异。

MAC（物理地址）：**我是谁**

- 数据链路层和物理层使用的地址，负责设备间的通信。

IP（逻辑地址）：**我在哪**

- 网络层、网关。跨网络传输

 **ARP 协议**：用于 IP 地址与物理地址的对应。

**RARP 协议**：用于物理地址与 IP 地址的对应。

### ARP 协议工作原理？

- ARP 列表
- ARP请求的广播包: 源主机的IP 地址、硬件地址、以及目的主机的 IP 地址
- 其他主机检查目的主机IP地址
  - 不同忽略
  - 相同
    - 记录
    - 发送ARP请求响应包

### 子网、超网、子网掩码

IP地址根据**子网掩码**被分为独立的**网络地址**和**主机地址**。

子网把大网络分成若干小网络，

超网把一些小网络组合成一个大网络。

### 什么是单播、组播(多播)、广播、任播？

单播：一对一，例：TCP

**组播/多播**：递给一组目的地址

**广播**：广播域中的所有设备

**任播**(anycast):是一种**网络寻址和路由的策略**，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。

### IPv4 和 IPv6 

**IP地址编址标准**

IPv4：地址长度32位，有限，40亿主机

IPv6：替代IPv4，**长度为 128位**， 2^98 次方倍。

### ICMP 协议

定义：就是互联网**控制**报文协议。

- 控制：网络包在异常负责的网络环境中传输时，会遇到各种问题，当**遇到问题**时，要传出消息，**报告情况**，这样才能调整传输策略。

功能：`IP 主机`、`路由器`之间**传递控制消息**。

- ping
- Traceroute ：用来**侦测主机到目的主机之间所经路由**情况的重要工具，也是最便利的工具。

  - Traceroute 的**原理**：traceroute 发送的是**端口号 >30000**的 **UDP 包**，给目标注解 TTL=1，路由器TTL 减1，直到0，**路由器返回不可达**，主机TTL加1,再发。**目的主机返回的是端口不可达**
    - TTL（生存时间值）TTL是`Time To Live`的缩写，该字段指定IP包被路由器丢弃之前**允许通过的最大网段数量**。

## TCP

### TCP

- 传输层通信协议
- 面向连接
- 点对点
- 可靠
- 双工通信
- 面向字节流

### TCP 头部

![img](https://camo.githubusercontent.com/137a789143b6c6d8af61e62930b9eda514c10ad1/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323434383735322d613636353239636164633332343032302e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

- **源端口号**（Source Port）和**目的端口号**（Destination Port）：**区别主机中的不同进程**
- **序号**（Sequence Number）：表示本报文段中的的第一个数据字节**在整个数据流中的序号**，解决**乱序**问题。
- **确认号**：**发送确认的一端所期望收到的下一个序号**，已成功收到数据**字节序号加1**。解决**不丢包**问题。
- **标志位（TCP Flags）**: `0 / 1`
  - **URG**：此标志表示TCP包的**紧急指针域有效**，用来**保证TCP连接不被中断**
  - **ACK**：此标志表示**应答域有效**
  - **PSH**：**立即传送**给应用程序，而**不是在缓冲区中排队**；
  - **RST**：这个标志表示**连接复位请求**。用来*复位那些产生错误的连接，也被用来拒绝错误和非法的数据包*；
  - **SYN**：**表示同步序号，用来建立连接**。SYN标志位和ACK标志位搭配使用。
    - 扫描：SYN的数据包——存在——第一次握手——不安全。
- **Window**:窗口大小，也就是有名的**滑动窗口，用来进行流量控制**；

## UDP

### UDP

#### 特点：

- 无连接
- **一对一、一对多、多对一和多对多**
- **不保证可靠交付**
- **没有拥塞控制**
- **首部开销小**，8字节

#### 对应应用层协议：

- **DNS ：用于域名解析服务**，将**域名地址转换为 IP 地址**。DNS 用的是 `53 号端`口。
- **SNMP ：简单网络管理协议**，使用 `161 号端口`，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- `TFTP`(Trivial File Transfer Protocol)：**简单文件传输协议**，该协议在熟知`端口 69` 上使用 UDP 服务。

### TCP 与 UDP 的区别

[![TCP 与 UDP 的区别](http://static2.iocoder.cn/047b5c455b1153e895df36e364134fcd)](http://static2.iocoder.cn/047b5c455b1153e895df36e364134fcd)

- TCP 是面向连接的；UDP 是无连接的。

- TCP 是可靠的；UDP 是不可靠的。

  > - TCP需要3次握手，4次分手
  >
  > - UDP只要知道接收端的 IP 和端口，任何主机都可以向接收端发送数据
  >
  > - TCP可靠
  >
  >   - 接收端
  >     - 校验、
  >     - 重排序
  >     - 丢弃重复数据
  >     - 确认机制
  >
  >   - 发送端
  >     - 超时重发
  >     - 流量控制

- TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。

- TCP 是面向字节流的；UDP 是面向报文的。

- TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。

- TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。

 

**为什么 TCP 叫数据流模式？ UDP 叫数据报模式？**

- 数据流模式：

  -  **TCP 是面向连接**，一对一
  - **TCP 发送端发送几次数据和接收端接收几次数据是没有必然联系的**。
    - **双工、数据缓存**

- 数据报模式：

  - 无连接，只要知道接收端的 IP 和端口，任何主机都可以向接收端发送数据。
  - 基于报文。发送完就不管了，接收的时候，每次最多只能读取一个报文
  -  **UDP 发送端调用了几次 write ，接收端必须用相同次数的 read 读完**。
### UDP 报文的格式

  [![UDP 报文格式](http://static2.iocoder.cn/e80a784ed96b6c688ef8e4e409f4cd18)](http://static2.iocoder.cn/e80a784ed96b6c688ef8e4e409f4cd18)UDP 报文格式

  - 16 位 * 4 = 64 位 = 8 字节。

## DNS

### DNS

- **域名解析**， 转换成 IP ，方便
- **DNS 协议运行在 UDP 协议之上**，使用**端口号 53** 。

### 主机解析域名的顺序？

1. **浏览器缓存**
2. 找**本机的 hosts 文件**
3. **路由缓存**
4. 找 **DNS 服务器**(本地域名、顶级域名、根域名)
   - [迭代查询](https://blog.csdn.net/wuchuanpingstone/article/details/6720723)
     - DNS服务器，如果没有，告诉客户端其他DNS服务器地址。
   - [递归查询](https://blog.csdn.net/wuchuanpingstone/article/details/6720723)
     - DNS服务器帮忙查询其他服务器，直接返回结果。

### DNS 使用什么协议？

**既使用 TCP 又使用 UDP** 。

- **区域传送，进行数据同步时使用 TCP 协议。**

  - 辅域名服务器定时同步主域名服务器信息 3小时
  - 有变动，区域传送，数据同步
  - 数据多，可靠。

- **域名解析时使用 UDP 协议。**

  - 客户端向 DNS 服务器查询域名

    > UDP 报文的最大长度为 512 字节。

  - **不用经过 TCP 三次握手，这样 DNS 服务器负载更低，响应更快**

## HTTP

### 定义

HTTP 协议，超文本传输协议，是用于服务器传输超文本到本地浏览器的传送协议。

特点:

1. **简单快速**：只需传送**请求方法**和**路径**
2. **数据格式灵活**：传输的类型由`Content-Type` 加以标记
3. **无连接**：无连接的含义是限制**每次连接只处理一个请求**（非keep-Alive机制下）
4. **无状态**：HTTP 协议是**无状态协议**。无状态，是指协议**对于事务处理没有记忆能力**。
5. 支持 B/S 及 C/S 模式。

### HTTP 基本格式

#### HTTP 请求格式

[![HTTP 请求格式](http://static2.iocoder.cn/e0f66085155bdcdaa170fab4507fa4f1)](http://static2.iocoder.cn/e0f66085155bdcdaa170fab4507fa4f1)

- **请求行**：用来说明**请求类型**，要访问的**资源路径**以及所使用的 **HTTP 版本**。
- **请求头**：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部。
  - `Accept`：告诉服务端,客户端接收什么类型的响应
  - HOST：将指出请求的目的地。
  - Referer：表示这是请求是**从哪个URL进来的**
  - User-Agent ：告诉服务器，客户端使用的**操作系统、浏览器版本和名称**
  - …
- **空行**：请求头部后面的空行是必须的。
- **请求数据**：也叫主体，可以添加任意的其他数据。

#### HTTP 响应格式

[![HTTP 响应格式](http://static2.iocoder.cn/da1ada597b5feedcd7d6c17d1989629d)](http://static2.iocoder.cn/da1ada597b5feedcd7d6c17d1989629d)HTTP 响应格式

- 状态行：由 **HTTP 协议版本号**、**状态码**、**状态消息**三部分组成。
- 消息报头：用来说明客户端要使用的一些附加信息。
- 空行：消息报头后面的空行是必须的。
- 响应正文：服务器返回给客户端的文本信息。

#### URI 和 URL 的区别

- **URI：**Uniform Resource Identifier，统一资源标识符，能把一个资源独一无二地标识出来。
- **URL：**Uniform Resource Location统一资源定位符

URL和URN是URI的子集，

![img](https://upload-images.jianshu.io/upload_images/3028410-db917f3b89c2fd9c.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

- [统一资源名](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%90%8D)（URN）如同一个人的名称，

- [统一资源定位符](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6)（URL）代表一个人的住址。
- 换言之，URN定义某事物的身份，而URL提供查找该事物的方法。

### HTTP 协议包括哪些请求？

- GET: 对服务器资源的简单请求。
- POST: 用于发送包含用户提交数据的请求。
- HEAD：类似于 GET 请求，**不过返回的响应中没有具体内容，用于获取报头**。
- PUT：传说中请求文档的一个版本。
- DELETE：发出一个删除指定文档的请求。
- TRACE：**发送一个请求副本，以跟踪其处理进程。**
- OPTIONS：**返回所有可用的方法，检查服务器支持哪些方法。**
- CONNECT：用于 SSL 隧道的基于代理的请求。

#### GET 和 POST 的区别？

| 请求方式 | 数据位置            | 明文密文 | 数据安全 | 长度限制          | 应用场景 |
| :------- | :------------------ | :------- | :------- | :---------------- | :------- |
| GET      | HTTP 请求的 path 中 | 明文     | 不安全   | 长度较小，一般 2k | 查询数据 |
| POST     | HTTP 请求 body 中   | 可明可密 | 安全     | 支持较大数据传输  | 修改数据 |

- **GET 请求可被缓存**；POST 请求不会被缓存。
- **GET 请求可被收藏为书签**；POST 不能被收藏为书签。

- 对于 GET 方式的请求，浏览器会把 **HTTP header 和 data 一并发送出去**，服务器响应 200（返回数据）。
- 而对于 POST，浏览器先**发送 header** ，服务器响应 100 continue ，浏览器**再发送 data** ，服务器响应 200 ok（返回数据）。

也就是说，GET 只需要汽车跑一趟就把货送到了，而 POS T得跑两趟，第一趟，先去和服务器打个招呼“**嗨，我等下要送一批货来，你们打开门迎接我**”，然后再回头把货送过去。

ps1：不过要注意，POST 具体发几次，也和浏览器的实现有关系。例如：**Firefox 只发一次**。
		ps2：据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，**两次包的 TCP 在验证数据包完整性上，有非常大的优点**。

### HTTP 有哪些状态码？

- 1×× : 请求处理中，请求已被接受，正在处理
- 2×× : 请求成功，请求被成功处理
  - 200 OK // 客户端请求成功
- **3×× : 重定向**，要完成请求必须进行进一步处理
  - **301 Moved Permanently // 永久重定向,使用域名跳转**
  - **302 Found // 临时重定向,**未登陆的用户访问用户中心重定向到登录页面
- **4×× : 客户端错误，请求不合法**
  - 400 Bad Request // 客户端请求有语法错误，不能被服务器所理解
  - 401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
  - 403 Forbidden // 服务器收到请求，但是拒绝提供服务
  - 404 Not Found // 请求资源不存在，eg：输入了错误的 URL
- **5×× : 服务器端错误**，服务器不能处理合法请求
  - 500 Internal Server Error // 服务器发生不可预期的错误
  - 503 Server Unavailable // 服务器当前不能处理客户端的请求，一段时间后可能恢复正常

#### forward 和 redirect 的区别？

- **直接转发方式（转发 Forward），客户端和浏览器只发出一次请求**
- **间接转发方式（重定向 Redirect），实际是两次 HTTP 请求**

一句话，转发是服务器行为，重定向是客户端行为。

#### HTTP 返回码中 301 与 302 的区别

都代表着某个 URL 发生了转移，不同之处在于：

- 301 redirect: 301 代表永久性转移(Permanently Moved)。
- 302 redirect: 302 代表暂时性转移(Temporarily Moved)。

### HTTP、TCP、Socket 的关系是什么？

- TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族。
- HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。运行在应用层。
- **Socket 是 TCP/IP 网络的 API** ，其实就是一个**门面模式**，**它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面**。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。

综上所述：

- 需要 IP 协议来连接网络
- TCP 是一种允许我们安全传输数据的机制，使用 TCP 协议来传输数据的 **HTTP 是 Web 服务器和客户端使用的特殊协议**。
- HTTP 基于 TCP 协议，所以可以使用 Socket 去建立一个 TCP 连接。

### Cookies 和 Session 的区别

- Session 在服务器端的一个文件里（不是内存），Cookie 在客户端（浏览器）。
- Session 可以放在文件、数据库、或内存中都可以。

### （重点）一次完整的 HTTP 请求所经历的步骤

- 1、**DNS 解析**(通过访问的域名找出其 IP 地址，递归搜索)。

- 2.1、浏览器向web服务器发送**HTTP 请求**，当输入一个请求时，**建立一个 Socket 连接发起 TCP的 3 次握手**。

- 2.2、客户端发送请求头信息和数据。

- 3、服务端处理请求

- 4.1、服务器发送应答头信息。

- 4.2、服务器向客户端发送数据。

- 5、服务器关闭 TCP 连接（4次挥手）。

  > 这里是否关闭 TCP 连接，也根据 HTTP Keep-Alive 机制有关。
  >
  > 同时，客户端也可以主动发起关闭 TCP 连接。

- 6、客户端根据返回的 HTML、CSS、JS 进行渲染。

HTTP 请求所经历的步骤：

[![HTTP 请求所经历的步骤](http://static2.iocoder.cn/be5603b1bb6ff46b640909b5b8976827)](http://static2.iocoder.cn/be5603b1bb6ff46b640909b5b8976827)



### HTTP1.0 和 HTTP1.1 有什么区别？

主要是如下 8 点：

- 2、**缓存**：提供更多可供选择的缓存头来控制缓存策略

- 3、带宽优化（节约带宽）

  - HTTP1.1支持只发送header信息（不带任何body信息）

  - 分块传输：允许[HTTP](https://zh.wikipedia.org/wiki/HTTP)由[网页服务器](https://zh.wikipedia.org/wiki/網頁伺服器)发送给[客户端](https://zh.wikipedia.org/wiki/客户端)[应用](https://zh.wikipedia.org/wiki/应用软件)（ 通常是[网页浏览器](https://zh.wikipedia.org/wiki/网页浏览器)）的数据可以分成多个部分

- 【最重要】4、**长连接**

- 6、Host 头域：解决多个虚拟主机共享IP的情况

- 7、错误提示：新增了一些响应状态码

- 8、内容协商：客户端可以告诉服务器自己可以接收以何种语言（或字符集）表示的资源

详细的每一点的说明，可以看 [《HTTP1.0 与 HTTP1.1 的区别》](https://blog.csdn.net/ForgotAboutGirl/article/details/6936982) 文章，简单[《》](https://blog.csdn.net/ailunlee/article/details/97831912)

> HTTP1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）。
>
> - 长连接（PersistentConnection）：处理在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。在 HTTP1.1中 默认开启`Connection：keep-alive` ，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。
> - 请求的流水线（Pipelining）：HTTP1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。
>
> 推荐，在看看 [《HTTP Keep-Alive 是什么？如何工作？》](http://www.nowamagic.net/academy/detail/23350305) 文章。
>
> 关于这一点，可能演变的问题有：
>
> - HTTP 的长连接是什么意思？
> - HTTP Keep-Alive 机制是什么？
> - HTTP Keep-Alive 机制和 TCP Keep-Alive 有什么区别？

## SPDY 是什么？

> 艿艿：关于这个问题，了解就好。
>
> HTTP Working-Group 最终决定以 SPDY/2 为基础，开发 HTTP/2 。

2012 年，Google 如一声惊雷提出了 SPDY 的方案，优化了 HTTP1.X 的请求延迟，解决了 HTTP1.X 的安全性，具体如下：

- 1、降低延迟

  > 针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。多路复用通过多个请求 Stream 共享一个 Tcp连 接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。

- 2、请求优先级（request prioritization）

  > 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。
  >
  > 比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。

- 3、header 压缩

  > 前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。

- 4、基于 HTTPS 的加密协议传输

  > 大大提高了传输数据的安全性。

- 5、服务端推送（server push）

  > 采用了 SPDY 的网页，例如我的网页有一个 `sytle.css` 的请求，在客户端收到 `sytle.css` 数据的同时，服务端会将 `sytle.js` 的文件推送给客户端。当客户端再次尝试获取 `sytle.js` 时就可以直接从缓存中获取到，不用再发请求了。
  >
  > 🙂 和我们理解的服务端推送，有点（非常）不一样哈。

🚀 SPDY 构成图如下：[![SPDY 构成图](http://static2.iocoder.cn/82cf7ea112281d126f23db03a502c249)](http://static2.iocoder.cn/82cf7ea112281d126f23db03a502c249)SPDY 构成图

- SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议(将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。





## 资料

https://www.jianshu.com/p/9a68281a3c84

http://svip.iocoder.cn/Net/Interview/#HTTP