# 消息队列 

#### 消息队列

消息队列，是**分布式系统**中不可缺少的**中间件**。可实现**高性能**，**高可用**，**可伸缩和最终一致性架构**

目前主流的消息队列有

- Kafka：大数据、实时计算，kafka是业内标准。
- RabbitMQ：开源，Erlang实现，Spring Cloud 支持上不错，社区活跃
- RocketMQ ：Java实现，阿里出品。
- ActiveMQ ：不清楚，没经过大规模吞吐量场景的验证，社区不活跃

![image-20200928164858644](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200928164900.png)

#### 角色

- 生产者（Producer）

- 消费者（Consumer

- 消息代理（Message Broker）：负责**存储消息**和**转发消息**两件事情。

  其中，**转发消息**分为推送和拉取两种方式。

  - **拉取**（Pull）
  - **推送**（Push）

#### 应用场景

- 应用解耦
  - 解耦：从主动调用的方式，变成了消息的订阅发布
- 异步处理
  - 串行调用变为异步，提升速度。
  - 前提，返回的结果不依赖于处理的结果。
- 流量削峰
  - 转发到消息队列中，慢慢处理。
  - 生产中，如果对时效没有要求，可以允许短暂的高峰期积压
- 消息通讯
  - 消息通讯
- 日志处理（异步处理）
  - 解决大量**日志传输**的问题（ELK+kafka）

#### 缺点

- 复杂度提高
  - 1）消息怎么不重复消息。
  - 2）消息怎么保证不丢失。
  - 3）需要消息顺序的业务场景，怎么处理。
- 可用性降低
- 一致性问题。**一定要达到数据的最终一致性**

#### 消费语义

1. 消息至多被消费一次（At most once）：消息可能会丢失，但绝不重传。

   - 吞吐量大，容忍消息丢失。
   - Message Broker不对接收到的消息响应确认
   - Message Broker转发不要求持久性，也不关心消费者是否真的收到
   - Message Broker消息被拿走就删除，不关心消费者，消费情况

2. 消息至少被消费一次（At least once）：消息可以重传，但绝不丢失。

   - Message Broker 必须响应对消息的确认，并提供持久性保障
   - 接收到消费者通知后，才删除消息。

3. 消息仅被消费一次（Exactly once）：每一条消息只被传递一次。

   - Message Broker 上存储的消息被 Consumer 仅消费一次。

     - Message Broker不对接收到的消息响应确认

     - Message Broker 提供持久性保障
     - 消息有唯一标识，消费者记录唯一标准，防止重复消费

   - Producer 上产生的消息被 Consumer 仅消费一次。

     - Message Broker对接收到的消息响应确认。 Producer 负责为该消息产生唯一标识，以防止 Consumer 重复消费
     - Message Broker 提供持久性保障，消息队列里有唯一标识
     - 消费者记录唯一标识，防止重复消费

#### 消息队列有几种投递方式？分别有什么优缺点

**push**

- 优点：**即时**
- 缺点：就是受限于消费者的消费能力，可能造成消息的**堆积**

**pull**

- 优点：消费者自己掌控进度，不会堆积
- 缺点：延迟、忙等

**目前的消息队列，基于 push + pull 模式结合的方式**，Broker 仅仅告诉 Consumer 有新的消息，具体的消息拉取，还是 Consumer 自己主动拉取。

##### 消费者实现幂等性？消息不被重复消费？

**消息仅被消费一次**，且**每条消息从 Producer 保证被送达，并且被 Consumer 仅消费一次**。

重复消费：offset，消费者挂了





##### 如何保证生产者的发送消息的可靠性？

##### 如何保证消息的顺序性？

##### 如何解决消息积压的问题？

##### 如何解决消息过期的问题？

##### 消息队列如何实现高可用？

###### RabbitMQ ：

1. 单机：DEMO
2. 普通集群：创建的**创建的 queue，只会放在一个 RabbitMQ 实例上**，每个实例放队列的元数据。集群间可能产生大量的数据传输，没备份，可用性无法保障。就是为了提高吞吐量。
3. 镜像集群模式（高可用性）：基于主从做高可用。你创建的 queue，无论元数据还是 queue 里的消息都会**存在于多个实例上**，也就是镜像
   - 开销大，**不是分布式**，所有数据放到一个节点里，**不能线性扩展**。

###### Kafka 的高可用性

由多个 `broker` 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 `partition`，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。

这就是**天然的分布式消息队列**，就是说一个 topic 的数据，是**分散放在多个机器上的，每个机器就放一部分数据**。

- Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制
- 所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 **leader 打交道**，然后其他 replica 就是 follower。
- **写数据**的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己**主动从 leader 来 pull 数据**
- **消费**的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。
-  broker 宕机：会从 follower 中**重新选举**一个新的 leader 出来