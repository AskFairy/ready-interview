### 基础

#### 数据库的三范式是什么？什么是反模式？

1. 原子性
2. 完全依赖主键
3. 直接依赖于主键

表多，join，性能

反设计模式：宽表

#### Mysql数据类型

#### varchar 则是一种可变长度的类型，（50）排序占内存少

#### int(11) 中的 11影响展示效果

#### 钱用decimal 

#### 自增主键，InnoDB类型重启丢失，MyISAM 类型记录不丢失

#### COUNT(*) ，InnoDB类型全表扫描，MyISAM 类型记录

#### InnoDB 的 [4 大特性](https://note.youdao.com/ynoteshare1/index.html?id=a6004953a0a7c80073ac74d8e76f1ebd&type=note)

- [插入缓冲](https://www.cnblogs.com/zhs0/p/10528520.html)(insert buffer/ change buffer) 
  - **非聚簇索引**
  - 插入缓存，合并
  - 减少随机IO，提升性能
- 二次写(double write)
  - 写入磁盘之前，缓存，崩溃恢复
- 自适应哈希索引(ahi)
  - 监控热数据，自适应变成hash索引
- 预读(read ahead)：提升IO性能
  - 线性预读：阀值，默认56，下一个extent放入**buffer pool**
  - 随机预读：当前extent中剩余的page，5.5废弃

#### MySQL 存储引擎：

- `InnoDB`：不支持事务、也不支持外键，优势是访问速度快
- `MyISAM`：事物，行级别锁，崩溃恢复。
- MRG_MYISAM：Merge存储引擎是**一组MyISAM表的组合**
- MEMORY：使用存在于**内存**中的内容来创建表。

#### MyISAM和InnoDB

- 事物
- 锁
- 崩溃恢复
- MVCC应对高并发





#### 字符集指的是⼀种从**⼆进制编码**到某类**字符符号**的**映射**。校对规则则是指某种**字符集下**的**排序规则**。



![image-20200927201915956](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200927201926.png)



### 索引

#### 好处

- **缩小查询数目**，加快检索速度，**降低IO成本**
- 数据**预先排好序**，排序成本、CPU消耗

#### 坏处

- **占用存储空间**
- **降低更新表的速度**

#### 场景

- **中大型表**
- 特大型的表，建立和使用索引的代价随着增长，建议**分库分表**

#### 索引类型

- 1、普通索引
- 2、唯一索引
- 3、主键索引
- 4、复合索引

#### **创建**原则

1.  `WHERE` 子句中的**列**，**或连接子句中的列**
2. **基数越大**，索引效果越好
3. 创建**复合索引，基数更大**
4. 避免**创建过多**的索引，**占空间，降低写效率**
5. **主键**尽可能**选择较短**的数据类型，可以有效**减少索引的磁盘**占用提高查询效率。
6. 对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间。

#### **使用**注意事项

- 应尽量避免在 `WHERE` 子句中**对字段进行判断、表达式、函数操作**，优化器将**无法通过索引来确定将要命中的行数**，导致引擎放弃使用索引而进行全表扫描。
  - 判断： `!=` 或 `<>` 、`column IS NULL` 、 `OR`
- 不要在 `WHERE` 子句中的 `=` **左边**进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
- 复合索引**遵循前缀原则**。
- 如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中**添加强制索引**。
- 列类型是**字符串类型**，查询时一定要给值**加引号**，否则索引失效。
- `LIKE` 查询，`%` 不能在前，因为无法使用索引。如果需要模糊匹配，可以使用全文索引。

####  以下三条 SQL 如何建索引，只建一条怎么建？

```
WHERE a = 1 AND b = 1
WHERE b = 1
WHERE b = 1 ORDER BY time DESC
```

- 以顺序 b , a, time 建立复合索引，`CREATE INDEX table1_b_a_time ON index_test01(b, a, time)`。
- 对于第一条 **SQL** ，因为最新 MySQL 版本会**优化** `WHERE` 子句后面的列顺序，以匹配复合索引顺序。

#### （重点）EXPLAIN

详细看看 [《MySQL explain 执行计划详细解释》](http://www.jfox.info/2017/mysql-explain执行计划详细解释.html) 。

![image-20201014205144535](https://gitee.com/chenchong0817/picture/raw/master/Aaron/image-20201014205144535.png)

具体解释如下

1. 执行id
   包含一组数字，id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行
2. **查询类型select_type**
   type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： 
   system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL ，一般来说，得**保证查询至少达到range级别，最好能达到ref**。
   - **ALL**: 扫描全表
   - **index**: 扫描全部索引树
   - **range**: 扫描部分索引，索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、<、>等的查询
   - ref: **非唯一性索引扫描**，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找
   - eq_ref：**唯一性索引扫描**，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描
3. possible_keys
   指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
4. **key**：**显示MySQL在查询中实际使用的索引**，若没有使用索引，显示为NULL
   TIPS：查询中若使用了覆盖索引，则该索引仅出现在key列表中
5. key_len
   表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
6. ref
   表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
7. **rows**：
   表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行
8. Extra
   包含不适合在其他列中显示但十分重要的额外信息

二、关于MySQL执行计划的局限总结如下：
1.EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
2.EXPLAIN**不考虑各种Cache**
3.EXPLAIN**不能显示MySQL在执行查询时所作的优化工作**
4.**部分统计信息是估算的，并非精确值**
5.EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划 

#### 索引原理

[《MySQL索引背后的数据结构及算法原理》](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

在 MySQL 中，我们可以看到两种索引方式：

- B-Tree 索引。
- Hash 索引。

##### 磁盘的相关知识

系统从磁盘读取数据基本单位：磁盘块（block）

InnoDB 读取基本单位  page：16k > block

B-Tree 结构的数据可以让**系统高效的找到数据所在的磁盘块**。



**磁盘预读**

局部性原理：

当一个数据被用到时，其附近的数据也通常会马上被使用。

预读的长度一般为页（page）的整倍数

##### AVL-Tree（自平衡二叉树）

2-3树、红黑树等

##### B-Tree

B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：

[![B-Tree 的结构](http://static2.iocoder.cn/84ea509fa091a10add4e7614e6cb37db)](http://static2.iocoder.cn/84ea509fa091a10add4e7614e6cb37db)B-Tree 的结构

- **每个节点占用一个盘块的磁盘空间**
  - 一个节点上有两个升序排序的 key 和三个指向子树根节点的 point ，
  - point 存储的是子节点所在磁盘块的地址。
  - **两个 key 划分成的三个范围域**，对应三个 point 指向的子树的数据的范围域。

发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的 key 是一个有序表结构，可以**利用二分法查找提高效率**。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素**。B-Tree 相对于 AVLTree 缩减了节点个数**，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。

#####  **B+Tree 索引**

将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：

[![B+Tree 的结构](http://static2.iocoder.cn/259d196856a231aff5e3cf1505848af4)](http://static2.iocoder.cn/259d196856a231aff5e3cf1505848af4)B+Tree 的结构

B+Tree 是在 B-Tree 基础上的一种优化，**使其更适合实现外存储索引结构**，InnoDB存储引擎就是用 B+Tree 实现其索引结构。

- 有**数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息**
- 去掉B-Tree节点的date数据，**key存储增多，减少树的深度（减少磁盘I/O次数）**

B+Tree 相对于 B-Tree 有几点不同：

- **非叶子节点只存储键值信息**。
  - key存储增多，减少树的深度（减少磁盘I/O次数）
- 所有叶子节点之间都有一个**链指针**。
  -  B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点
  - 可以对 B+Tree 进行两种查找运算：一种是**对于主键**的**范围查找**和**分页查找**，另一种是从根节点开始，**进行随机查找**。
- **数据记录都存放在叶子节点中**。

推算：

- InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个字节） 或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 **16KB/(8B+8B)=1K 个键值**（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护10^3 *10^3* 10^3 = **10亿 条记录**。
- 实际情况中每个节点可能不能填充满，因此在数据库中，**B+Tree 的高度一般都在 2~4 层**。MySQL 的 `InnoDB` 存储引擎在设计时是**将根节点常驻内存**的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。

##### **B-Tree 有哪些索引类型？**

索引类型分为**主键索引**和**非主键索引（辅助索引）**。

- **辅助索引**与聚集索引的区别在于辅助索引的**叶子节点**并不包含行记录的全部数据，而是存储相应行数据的**聚集索引键，即主键**。

当通过辅助索引来查询数据时，需要进过两步：

- 首先，InnoDB 存储引擎会遍历辅助索引找到主键。
- 然后，再通过主键在聚集索引中找到完整的行记录数据。

另外，InnoDB 通过**主键聚簇数据**，如果**没有定义主键**，会选择一个**唯一的非空索引代替**，如果没有这样的索引，会**隐式定义个主键作为聚簇索引**。

##### **聚簇索引的注意点有哪些？**

聚簇索引表**最大限度地提高了 I/O 密集型应用的性能**，但它也有以下几个限制：

- 1、**插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现**页分裂**，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。

  > 关于这一点，可能面试官会换一个问法。例如，为什么主键需要是**自增 ID** ，又或者为什么主键需要带有时间性关联。

- 2、**更新主键的代价很高**，因为将会导致被更新的行移动。

- 3、**回表：**二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

  > 当然，有一种情况可以**无需二次查找**，基于非主键索引查询，但是**查询字段只有主键 ID** ，那么在二级索引中就可以查找到。

- 4、**主键 ID 建议使用整型**。节点的数据可以存储更多主键 ID 。

##### 🦅 **什么是索引的最左匹配特性？**

当 B+Tree 的数据项是复合的数据结构，比如索引 `(name, age, sex)` 的时候，B+Tree 是按照从左到右的顺序来建立**组合索引搜索树**的（组合索引，就是三个索引在一个索引里面）。

- 比如当 `(张三, 20, F)` 这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex ，最后得到检索的数据。
- 但当 `(20, F)` 这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。
- 比如当 `(张三, F)` 这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以**只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了。**

#### 🦅 **MyISAM 索引实现**

> 艿艿：注意，我们上面看到的都是 InnoDB 存储引擎下的索引实现。

MyISAM 索引的实现，和 InnoDB 索引的实现是一样使用 B+Tree ，**差别在于 MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址**。

1）主键索引：

MyISAM引 擎使用B+Tree作为索引结构，**叶节点的data域存放的是数据记录的地址**。下图是MyISAM主键索引的原理图：

[![主键索引](http://static2.iocoder.cn/d49d260fc1eb8f992df0401b70d70e3d)](http://static2.iocoder.cn/d49d260fc1eb8f992df0401b70d70e3d)主键索引

- 这里设表一共有三列，假设我们以 Col1 为主键，上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。

2）辅助索引：

**在 MyISAM 中，主索引和辅助索引在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。**如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示：

[![辅助索引](http://static2.iocoder.cn/2fb922405a35479fa99eb2de4708638c)](http://static2.iocoder.cn/2fb922405a35479fa99eb2de4708638c)辅助索引

- 同样也是一颗 B+Tree ，data 域保存数据记录的地址。因此，**MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。**

MyISAM 的索引方式也叫做“**非聚集**”的，之所以这么称呼是为了与InnoDB 的聚集索引区分。

🦅 **MyISAM 索引与 InnoDB 索引的区别？**

- InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。

- InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。

- MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。

- InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

  > **覆盖索引**，指的是基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。
  >
  > 只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
  >
  > 如何实现:
  >
  > 将被查询的字段，建立到联合索引里去。

### 事物

**什么是事务？事务的四大特性是什么？并发事务会带来哪些问题？有哪些解决方案？**

#### 什么是事物

多个操作执行，完全地执行，要么完全地不执行。

#### 四大特性（ACID）

**原子性**：对于其数据修改，**要么全都执行，要么全都不执行**

**一致性**：事务在完成时，必须使所有的数据都保持**一致状态**

**隔离性**：由**并发事务所作的修改**必须与任何其它并发事务操作**隔离**

**持久性**：事务完成之后，它对于系统的影响是永久性的，落地到磁盘。

#### 并发事务带来的问题

脏写问题：**多个事务**对同一行，然后基于**最初选定的值更新**该行时，会发生**丢失更新问题**。

脏读问题：**读取未提交的数据**（这条记录的数据就处于不一致状态）。

不可重复读问题：**一个事物**，在不同时间点**读取一条数据**的结果不同。

幻读问题：一个事物，在不同时间点**检索数据条目不同**。

#### 并发事务问题的解决方案（四种隔离级别）

**读未提交（Read Uncommitted）**：**允许脏读取，但不允许更新丢失（脏写）**。如果一个事务已经开始写数据，则另外一个事务则**不允许同时进行写操作**，但允许其他事务读此行数据。该隔离级别可以通过**“排他写锁”**实现。

- 可避免 脏写。
- 不可避免 脏读、不可重复读、幻读。

**读已提交（Read Committed）**：允许不可重复读取，但不允许脏读取。这可以通过**“瞬间共享读锁”和“排他写锁”实现**。读取数据的事务允许其他事务继续访问该行数据，但是**未提交的写事务将会禁止其他事务访问该行**。

- 可避免 脏读，
- 不可避免 不可重复读、幻读。Oracle采用读已提交。

**可重复读取（Repeatable Read）**：禁止不可重复读取和脏读取，但是**有时可能出现幻读数据**。这可以通过**“共享读锁”和“排他写锁”**实现。**读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务**。

- 可避免 脏读、不可重复读， 不可避免 幻读。MySQL采用可重复读。

**序列化（Serializable）**：提供严格的事务隔离。它要求事务序列化执行，**事务只能一个接着一个地执行，不能并发执行**。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

- 可避免 脏读、不可重复读、幻读情况的发生。

**Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别**



### （重点）丁奇老师的 [《MySQL 实战 45 讲》](http://www.iocoder.cn/images/jikeshijian/MySQL实战45讲.jpg) 的「08 | 事务到底是隔离的还是不隔离的？」

## 【重点】请说说 MySQL 的锁机制？

表锁是日常开发中的常见问题，因此也是面试当中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题。MySQL **的共享锁和排他锁，就是读锁和写锁**。

- 共享锁：不堵塞，多个用户**可以同时读一个资源**，互不干扰。
- 排他锁：一个**写锁会阻塞其他的读锁和写锁**，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。

🦅 **锁的粒度？**

- 表锁：系统开销最小，会锁定整张表，MyIsam 使用表锁。
- 行锁：**最大程度的支持并发处理**，但是也带来了最大的锁开销，InnoDB 使用行锁。

🦅 **什么是悲观锁？什么是乐观锁？**

1）悲观锁：保守态度，因此，**在整个数据处理过程中，将数据处于锁定状态**。悲观锁的实现，往往依靠**数据库提供的锁机制**。

> 艿艿：悲观锁，就是我们上面看到的共享锁和排他锁。

2）乐观锁

悲观锁大多数情况下依靠数据库的锁机制实现，据库性能的大量开销（什么样的开销）。

乐观锁，大多是基于数据版本（ Version ）记录机制实现。

> 艿艿：乐观锁，实际就是通过版本号，从而实现 CAS 原子性更新。

🦅 **什么是死锁？**

- 设置获得锁的超时时间。

  > 通过超时，至少保证最差最差最差情况下，可以有退出的口子。

- 按同一顺序访问对象。

  > 这个是最重要的方式。

🦅 **MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？？**

InnoDB 是基于索引来完成行锁。例如：`SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE` 。

- `FOR UPDATE` 可以根据条件来完成**行锁**锁定，并且 id 是有索引键的列,如果 id 不是索引键那么 InnoDB 将完成**表锁**，并发将无从谈起。

🦅 **关于熟悉 MySQL 的锁机制？**

> 艿艿：这个问题，艿艿也没特别研究，先 mark 在这里。

- gap 锁

- next-key 锁

- Innodb 的行锁是怎么实现的？

  > Innodb 的锁的策略为 next-key 锁，即 record lock + gap lock ，是通过在 index 上加 lock 实现的。
  >
  > - 如果 index 为 unique index ，则降级为 record lock 行锁。
  > - 如果是普通 index ，则为 next-key lock 。
  > - 如果没有 index ，则直接锁住全表，即表锁。

- MyISAM 的表锁是怎么实现的？

  > MyISAM 直接使用表锁。

## 【重要】MySQL 查询执行顺序？

MySQL 查询执行的顺序是：

```java
(1)     SELECT
(2)     DISTINCT <select_list>
(3)     FROM <left_table>
(4)     <join_type> JOIN <right_table>
(5)     ON <join_condition>
(6)     WHERE <where_condition>
(7)     GROUP BY <group_by_list>
(8)     HAVING <having_condition>
(9)     ORDER BY <order_by_condition>
(10)    LIMIT <limit_number>
```

具体的，可以看看 [《SQL 查询之执行顺序解析》](http://zouzls.github.io/2017/03/23/SQL查询之执行顺序解析/) 文章。

## 【重要】聊聊 MySQL SQL 优化？

可以看看如下几篇文章：

- [《PHP 面试之 MySQL 查询优化》](https://www.jianshu.com/p/ab958a4823d1)
- [《【面试】【MySQL常见问题总结】【03】》](https://blog.csdn.net/DERRANTCM/article/details/51534411) 第 078、095、105 题

另外，除了从 SQL 层面进行优化，也可以从服务器硬件层面，进一步优化 MySQL 。具体可以看看 [《MySQL 数据库性能优化之硬件优化》](https://blog.csdn.net/bemavery/article/details/46241533) 。

## 【加分】什么是 MVCC ？

> 艿艿：这是一个面试的加分题，一些大厂比较喜欢问，例如蚂蚁金服。

多版本并发控制（MVCC），是一种用来**解决读-写冲突**的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。

推荐可以看看如下资料：

- 沈询 [《在线分布式数据库原理与实践》](https://www.imooc.com/learn/272)

  > 一共 1 小时 53 分钟，有趣，牛逼，强烈推荐！！！

- 钟延辉

  - [《分布式数据库 MVCC 技术探秘 (1)》](https://mp.weixin.qq.com/s/sOxLZlXRYR-zZKStE7qAwg)
  - [《分布式数据库 MVCC 技术探秘(2): 混合逻辑时钟》](https://mp.weixin.qq.com/s/8lX3Gyq4J5vLHETtG01EdA)

## 编写 SQL 查询语句的考题合集

因为考题比较多，艿艿就不一一列举，瞄了一些还不错的文章，如下：

- [《10 道 MySQL 查询语句面试题》](https://www.yanxurui.cc/posts/mysql/2016-11-10-10-sql-interview-questions/)
- [《MySQL 开发面试题》](https://www.cnblogs.com/geaozhang/p/6839297.html)
- [《企业面试题｜最常问的 MySQL 面试题集合（二）》](https://juejin.im/entry/5b57ebdcf265da0f61320e6f)

## MySQL 数据库 CPU 飙升到 500% 的话，怎么处理？

当 CPU 飙升到 500% 时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。

> 如果此时是 IO 压力比较大，可以使用 iostat 命令，定位是哪个进程占用了磁盘 IO 。

如果是 mysqld 造成的，使用 `show processlist` 命令，看看里面跑的 Session 情况，是不是有消耗资源的 SQL 在运行。找出消耗高的 SQL ，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。一般来说，肯定要 kill 掉这些线程(同时观察 CPU 使用率是否下降)，等进行相应的调整(比如说加索引、改 SQL 、改内存参数)之后，再重新跑这些 SQL。

> 也可以查看 MySQL 慢查询日志，看是否有慢 SQL 。

也有可能是每个 SQL 消耗资源并不多，但是突然之间，有大量的 Session 连进来导致 CPU 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。

🦅 **在 MySQL 服务器运行缓慢的情况下输入什么命令能缓解服务器压力？**

> 这个回答，和上面的回答思路是差不多的，优秀在更有层次感。

1）检查系统的状态

通过操作系统的一些工具检查系统的状态，比如 CPU、内存、交换、磁盘的利用率，根据经验或与系统正常时的状态相比对，有时系统表面上看起来看空闲，这也可能不是一个正常的状态，因为 CPU 可能正等待IO的完成。除此之外，还应观注那些占用系统资源(CPU、内存)的进程。

- 使用 sar 来检查操作系统是否存在 IO 问题。
- 使用 vmstat 监控内存 CPU 资源。
- 磁盘 IO 问题，处理方式：做 raid10 提高性能 。
- 网络问题，telnet 一下 MySQL 对外开放的端口。如果不通的话，看看防火墙是否正确设置了。另外，看看 MySQ L是不是开启了 skip-networking 的选项，如果开启请关闭。

2）检查 MySQL 参数

- max_connect_errors
- connect_timeout
- skip-name-resolve
- slave-net-timeout=seconds
- master-connect-retry

3）检查 MySQL 相关状态值

- 关注连接数
- 关注下系统锁情况
- 关注慢查询（slow query）日志

# 运维

理解一遍，即使有蛮多不会，也不要担心太多。

## Innodb 的事务与日志的实现方式

🦅 **有多少种日志？**

- redo 日志
- undo 日志

🦅 **日志的存放形式？**

- redo：在页修改的时候，先写到 redo log buffer 里面， 然后写到 redo log 的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（fsync）。
- undo：在 MySQL5.5 之前，undo 只能存放在 ibdata *文件里面， 5.6 之后，可以通过设置 innodb_undo_tablespaces 参数把 undo log 存放在 ibdata* 之外。

🦅 **事务是如何通过日志来实现的，说得越深入越好**

> 艿艿：这个流程的理解还是比较简单的，实际思考实现感觉还是蛮复杂的。

基本流程如下：

- 因为事务在修改页时，要先记 undo ，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 redo（里面包括 undo 的修改）一定要比数据页先持久化到磁盘。
- 当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的状态。
- 崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo 把该事务的修改回滚到事务开始之前。如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。

## MySQL binlog 的几种日志录入格式以及区别

🦅 **各种日志格式的涵义**

binlog 有三种格式类型，分别如下：

1）Statement

每一条会修改数据的 SQL 都会记录在 binlog 中。

- 优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO，提高性能。(相比 row 能节约多少性能与日志量，这个取决于应用的 SQL 情况，正常同一条记录修改或者插入 row 格式所产生的日志量还小于 Statement 产生的日志量，但是考虑到如果带条件的 update 操作，以及整表删除，alter 表等操作，ROW 格式会产生大量日志，因此在考虑是否使用 ROW 格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的 IO 性能问题。)

- 缺点：由于记录的只是执行语句，为了这些语句能在 slave 上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在 slave 得到和在 master 端执行时候相同 的结果。另外 MySQL 的复制，像一些特定函数功能，slave 可与 master 上要保持一致会有很多相关问题(如 `sleep()` 函数，`last_insert_id()`，以及 user-defined functions(udf) 会出现问题)。

- 使用以下函数的语句也无法被复制：

  - `LOAD_FILE()`

  - `UUID()`

  - `USER()`

  - `FOUND_ROWS()`

  - `SYSDATE()` (除非启动时启用了 `--sysdate-is-now` 选项)

    > 同时在 INSERT …SELECT 会产生比 RBR 更多的行级锁 。

2）Row

不记录 SQL 语句上下文相关信息，仅保存哪条记录被修改。

- 优点：binlog 中可以不记录执行的 SQL 语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以 rowlevel 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或 function ，以及 trigger 的调用和触发无法被正确复制的问题。
- 缺点：所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条 Update 语句，修改多条记录，则 binlog 中每一条修改都会有记录，这样造成 binlog 日志量会很大，特别是当执行 alter table 之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。

3）Mixedlevel

是以上两种 level 的混合使用。

- 一般的语句修改使用 Statement 格式保存 binlog 。
- 如一些函数，statement 无法完成主从复制的操作，则采用 Row 格式保存 binlog 。

MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 Statement 和 Row 之间选择 一种。

新版本的 MySQL 中对 row level 模式也被做了优化，并不是所有的修改都会以 row level 来记录。

- 像遇到表结构变更的时候就会以 Statement 模式来记录。
- 至于 Update 或者 Delete 等修改数据的语句，还是会记录所有行的变更，即使用 Row 模式。

🦅 **适用场景？**

在一条 SQL 操作了多行数据时， Statement 更节省空间，Row 更占用空间。但是， Row 模式更可靠。

因为，互联网公司，使用 MySQL 的功能相对少，基本不使用存储过程、触发器、函数的功能，选择默认的语句模式，Statement Level（默认）即可。

🦅 **结合第一个问题，每一种日志格式在复制中的优劣？**

- Statement 可能占用空间会相对小一些，传送到 slave 的时间可能也短，但是没有 Row 模式的可靠。
- Row 模式在操作多行数据时更占用空间，但是可靠。

所以，这是在占用空间和可靠之间的选择。

**如何在线正确清理 MySQL binlog？**

MySQL 中的 binlog 日志记录了数据中的数据变动，便于对数据的基于时间点和基于位置的恢复。但日志文件的大小会越来越大，占用大量的磁盘空间，因此需要定时清理一部分日志信息。

```
# 首先查看主从库正在使用的binlog文件名称
show master(slave) status

# 删除之前一定要备份
purge master logs before'2017-09-01 00:00:00'; # 删除指定时间前的日志
purge master logs to'mysql-bin.000001'; # 删除指定的日志文件

# 自动删除：通过设置binlog的过期时间让系统自动删除日志
show variables like 'expire_logs_days'; # 查看过期时间
set global expire_logs_days = 30; # 设置过期时间
```

## MySQL 主从复制的流程是怎么样的？

MySQL 的主从复制是基于如下 3 个线程的交互（多线程复制里面应该是 4 类线程）：

- 1、Master 上面的 binlog dump 线程，该线程负责将 master 的 binlog event 传到 slave 。
- 2、Slave 上面的 IO 线程，该线程负责接收 Master 传过来的 binlog，并写入 relay log 。
- 3、Slave 上面的 SQL 线程，该线程负责读取 relay log 并执行。
- 4、如果是多线程复制，无论是 5.6 库级别的假多线程还是 MariaDB 或者 5.7 的真正的多线程复制， SQL 线程只做 coordinator ，只负责把 relay log 中的 binlog 读出来然后交给 worker 线程， woker 线程负责具体 binlog event 的执行。

🦅 **MySQL 如何保证复制过程中数据一致性？**

> 艿艿：这个问题比较难，理解不了也没问题。我自己也没完全理解，主要是网络找到这个答案，后续有精力在研究。

- 1、在 MySQL5.5 以及之前， slave 的 SQL 线程执行的 relay log 的位置只能保存在文件（ relay-log.info）里面，并且该文件默认每执行 10000 次事务做一次同步到磁盘， 这意味着 slave 意外 crash 重启时， SQL 线程执行到的位置和数据库的数据是不一致的，将导致复制报错，如果不重搭复制，则有可能会导致数据不一致。
  - MySQL 5.6 引入参数 relay_log_info_repository，将该参数设置为 TABLE 时， MySQL 将 SQL 线程执行到的位置存到 mysql.slave_relay_log_info 表，这样更新该表的位置和 SQL 线程执行的用户事务绑定成一个事务，这样 slave 意外宕机后，slave 通过 innodb 的崩溃恢复可以把 SQL 线程执行到的位置和用户事务恢复到一致性的状态。
- 2、MySQL 5.6 引入 GTID 复制，每个 GTID 对应的事务在每个实例上面最多执行一次， 这极大地提高了复制的数据一致性。
- 3、MySQL 5.5 引入半同步复制， 用户安装半同步复制插件并且开启参数后，设置超时时间，可保证在超时时间内如果 binlog 不传到 slave 上面，那么用户提交事务时不会返回，直到超时后切成异步复制，但是如果切成异步之前用户线程提交时在 master 上面等待的时候，事务已经提交，该事务对 master 上面的其他 session 是可见的，如果这时 master 宕机，那么到 slave 上面该事务又不可见了，该问题直到 5.7 才解决。
- 4、MySQL 5.7 引入无损半同步复制，引入参 rpl_semi_sync_master_wait_point，该参数默认为 after_sync，指的是在切成半同步之前，事务不提交，而是接收到 slave 的 ACK 确认之后才提交该事务，从此，复制真正可以做到无损的了。
- 5、可以再说一下 5.7 的无损复制情况下， master 意外宕机，重启后发现有 binlog 没传到 slave 上面，这部分 binlog 怎么办？？？分 2 种情况讨论， 1 宕机时已经切成异步了， 2 是宕机时还没切成异步？？？ 这个怎么判断宕机时有没有切成异步呢？？？ 分别怎么处理？？？

🦅 **MySQL 如何解决主从复制的延时性？**

5.5 是单线程复制，5.6 是多库复制（对于单库或者单表的并发操作是没用的），5.7 是真正意义的多线程复制，它的原理是基于 group commit， 只要 master 上面的事务是 group commit 的，那 slave 上面也可以通过多个 worker线程去并发执行。 和 MairaDB10.0.0.5 引入多线程复制的原理基本一样。

🦅 **工作遇到的复制 bug 的解决方法？**

5.6 的多库复制有时候自己会停止，我们写了一个脚本重新 start slave 。

🦅 **你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？**

主从一致性校验有多种工具 例如 checksum、mysqldiff、pt-table-checksum 等。

## 聊聊 MySQL 备份方式？备份策略是怎么样的？

具体的，胖友可以看看 [《MySQL 高级备份策略》](http://www.qinglin.net/1015.html) 。主要有几个知识点：

- 数据的备份类型

  - 【常用】完全备份

    > 这是大多数人常用的方式，它可以备份整个数据库，包含用户表、系统表、索引、视图和存储过程等所有数据库对象。但它需要花费更多的时间和空间，所以，一般推荐一周做一次完全备份。

  - 增量备份

    > 它是只备份数据库一部分的另一种方法，它不使用事务日志，相反，它使用整个数据库的一种新映象。它比最初的完全备份小，因为它只包含自上次完全备份以来所改变的数据库。它的优点是存储和恢复速度快。推荐每天做一次差异备份。

  - 【常用】事务日志备份

    > 事务日志是一个单独的文件，它记录数据库的改变，备份的时候只需要复制自上次备份以来对数据库所做的改变，所以只需要很少的时间。为了使数据库具有鲁棒性，推荐每小时甚至更频繁的备份事务日志。

  - 文件备份

    > 数据库可以由硬盘上的许多文件构成。如果这个数据库非常大，并且一个晚上也不能将它备份完，那么可以使用文件备份每晚备份数据库的一部分。由于一般情况下数据库不会大到必须使用多个文件存储，所以这种备份不是很常用。

- 备份数据的类型

  - 热备份
  - 温备份
  - 冷备份

- 备份工具

  - cp
  - mysqldump
  - xtrabackup
  - lvm2 快照

🦅 **MySQL 几种备份方式？**

MySQL 一般有 3 种备份方式。

1）逻辑备份

使用 MySQL 自带的 mysqldump 工具进行备份。备份成sql文件形式。

- 优点：最大好处是能够与正在运行的 MySQL 自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。SQL 文件通用方便移植。
- 缺点：备份的速度比较慢。如果是数据量很多的时候，就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)，那么服务就会影响的。

2）物理备份

> 艿艿：因为现在主流是 InnoDB ，所以基本不再考虑这种方式。

直接拷贝只适用于 MyISAM 类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用 MyISAM 类型表。你也不可能因为 MyISAM 类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由。

- 缺点：你不能去操作正在运行的 MySQL 服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)，可能无法移植到其他机器上去。

3）双机热备份。

当数据量太大的时候备份是一个很大的问题，MySQL 数据库提供了一种主从备份的机制，也就是双机热备。

- 优点：适合数据量大的时候。现在明白了，大的互联网公司对于 MySQL 数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制。

🦅 **数据库不能停机，请问如何备份? 如何进行全备份和增量备份?**

可以使用逻辑备份和双机热备份。

- 完全备份：完整备份一般一段时间进行一次，且在网站访问量最小的时候，这样常借助批处理文件定时备份。主要是写一个批处理文件在里面写上处理程序的绝对路径然后把要处理的东西写在后面，即完全备份数据库。
- 增量备份：对 ddl 和 dml 语句进行二进制备份。且 5.0 无法增量备份，5.1 后可以。如果要实现增量备份需要在 `my.ini` 文件中配置备份路径即可，重启 MySQL 服务器，增量备份就启动了。

🦅 **你的备份工具的选择？备份计划是怎么样的？**

视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump 更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。

100G 以上的库，可以考虑用 xtrabackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。

> 艿艿：一般情况下，选择每周备份 + 每天增量备份比较靠谱。

🦅 **备份恢复时间是多长？**

物理备份恢复快，逻辑备份恢复慢。

这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考：

- 20G 的 2 分钟（mysqldump）
- 80G 的 30分钟（mysqldump)
- 111G 的 30分钟（mysqldump)
- 288G 的 3 小时（xtrabackup)
- 3T 的 4 小时（xtrabackup)

逻辑导入时间一般是备份时间的 5 倍以上。

🦅 **备份恢复失败如何处理？**

首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。

🦅 **mysqldump 和 xtrabackup 实现原理？**

1）mysqldump

mysqldump 是最简单的逻辑备份方式。

- 在备份 MyISAM 表的时候，如果要得到一致的数据，就需要锁表，简单而粗暴。
- 在备份 InnoDB 表的时候，加上 `–master-data=1 –single-transaction` 选项，在事务开始时刻，记录下 binlog pos 点，然后利用 MVCC 来获取一致的数据，由于是一个长事务，在写入和更新量很大的数据库上，将产生非常多的 undo ，显著影响性能，所以要慎用。
- 优点：简单，可针对单表备份，在全量导出表结构的时候尤其有用。
- 缺点：简单粗暴，单线程，备份慢而且恢复慢，跨 IDC 有可能遇到时区问题

2）xtrabackup

xtrabackup 实际上是物理备份+逻辑备份的组合。

- 在备份 InnoDB 表的时候，它拷贝 ibd 文件，并一刻不停的监视 redo log 的变化，append 到自己的事务日志文件。在拷贝 ibd 文件过程中，ibd文件本身可能被写”花”，这都不是问题，因为在拷贝完成后的第一个 prepare 阶段，xtrabackup 采用类似于 Innodb 崩溃恢复的方法，把数据文件恢复到与日志文件一致的状态，并把未提交的事务回滚。
- 如果同时需要备份 MyISAM 表以及 InnoDB 表结构等文件，那么就需要用 `flush tables with lock` 来获得全局锁，开始拷贝这些不再变化的文件，同时获得 binlog 位置，拷贝结束后释放锁，也停止对 redo log 的监视。

🦅 **如何从 mysqldump 产生的全库备份中只恢复某一个库、某一张表？**

具体可见 [《MySQL 全库备份中恢复某个库和某张表以及 mysqldump 参数 –ignore-table 介绍》](http://blog.51cto.com/wujianwei/1959473) 文章。

## 聊聊 MySQL 集群?

> 艿艿：这块艿艿懂的少，主要找了一些网络上的资料。

- [《五大常见的 MySQL 高可用方案》](https://zhuanlan.zhihu.com/p/25960208)
- [《高性能、高可用、可扩展的 MySQL 集群如何组建？》](https://www.zhihu.com/question/21307639)

🦅 **对于简历中写有熟悉 MySQL 高可用方案？**

我一般先问他现在管理的数据库架构是什么，如果他只说出了主从，而没有说任何 HA 的方案，那么我就可以判断出他没有实际的 HA 经验。

不过这时候也不能就是断定他不懂 MySQL 高可用，也许是没有实际机会去使用，那么我就要问 [MMM](http://www.cnblogs.com/gomysql/p/3671896.html) 以及 [MHA](http://svip.iocoder.cn/MySQL/Interview/MySQL高可用架构之MHA) 以及 [MM + keepalived](http://blog.51cto.com/sumongodb/1953244) 等的原理、实现方式以及它们之间的优势和不足了，一般这种情况下，能说出这个的基本没有。

- MMM 那东西好像不靠谱，据说不稳定，但是有人在用的，和 mysql-router 比较像，都是指定可写的机器和只读机器。
- MHA 的话一句话说不完，可以搜索下相关博客。

🦅 **使用过其他分支版本的数据库吗？Percona、Mariadb 等。对Percona 的 pxc 集群了解吗？**

除了 Oracle 旗下的 MySQL 外，我还使用过 Percona Server 。

Percona 是在原生 MySQL 的基础上，进行了优化和改进，所以 Percona 的性能比 MySQL 更好。

- 目前，我知道 Percona 提供免费的线程池功能，而社区版的 MySQL 没有线程池的功能（当然，企业版的mysql是有线程池的，但是需要收费）
- 另外 Percona 还支持 NUMA 等功能。

我熟悉 pxc ，我曾经在测试环境搭建过 pxc ，但是没有在生产上使用，因为目前使用 pxc 的企业不是很多，目前我知道搜狐在用 pxc 。

- pxc 是摒弃 MySQL 主从的概念，即对于 pxc 来说，每个节点都可以读写，并且写一份数据，其他节点会同时拥有，这是一种同步的复制方案（区别于 MySQL 主从的异步复制）。

## 聊聊 MySQL 安全？

感兴趣的胖友，可以看看：

- [《保障 MySQL 安全的14个最佳方法》](http://netsecurity.51cto.com/art/201311/418159.htm)
- [《详解 MySQL 安全配置》](https://www.freebuf.com/articles/database/36777.html)

## MySQL 有哪些日志？

- 错误日志：记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。

- 二进制文件：记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，不包括数据查询语句。语句以“事件”的形式保存，它描述了数据的更改过程。（定期删除日志，默认关闭）。

  > 就是我们上面看到的 MySQL binlog 日志。

- 查询日志：记录了客户端的所有语句，格式为纯文本格式，可以直接进行读取。（log 日志中记录了所有数据库的操作，对于访问频繁的系统，此日志对系统性能的影响较大，建议关闭，默认关闭）。

- 慢查询日志：慢查询日志记录了包含所有执行时间超过参数long_query_time（单位：秒）所设置值的 SQL 语句的日志。（纯文本格式）

  > 重要，一定要开启。

另外，错误日志和慢查询日志的详细解释，可以看看 [《MySQL 日志文件之错误日志和慢查询日志详解》](https://blog.csdn.net/xlgen157387/article/details/76019934) 文章。

## 聊聊 MySQL 监控？

**你是如何监控你们的数据库的？**

监控的工具有很多，例如 Zabbix ，Lepus ，我这里用的是 [Lepus](https://github.com/lijiapengsa/lepus) 。

## 对一个大表做在线 DDL ，怎么进行实施的才能尽可能降低影响？

使用 pt-online-schema-change ，具体可以看看 [《MySQL 大表在线 DML 神器–pt-online-schema-change》](https://blog.csdn.net/mchdba/article/details/76253016) 文章。

另外，还有一些其它的工具，胖友可以搜索下。

# 彩蛋

T T 知识点真多，胖友还是重点掌握文初说的几个，不要方，我们能赢。如下是艿艿在网络上找到过的一个 MySQL 问题清单（研发向）：

> - 3-1 数据库架构
> - 3-2 优化你的索引-运用二叉查找树
> - 3-3 优化你的索引-运用B树
> - 3-4 优化你的索引-运用B+树
> - 3-5 优化你的索引-运用Hash以及BitMap
> - 3-6 密集索引和稀疏索引的区别
> - 3-7 索引额外的问题之如何调优Sql
> - 3-8 索引额外问题之最左匹配原则的成因
> - 3-9 索引额外问题之索引是建立越多越好吗
> - 3-10 锁模块之MyISAM与InooDB关于锁方面的区别
> - 3-11 锁模块之MyISAM与InooDB关于锁方面的区别_2
> - 3-12 锁模块之数据库事务的四大特性
> - 3-13 锁模块之事务并发访问产生的问题以及事务隔离机制
> - 3-14 锁模块之事务并发访问产生的问题以及事务隔离机制_2
> - 3-15 锁模块之当前读和快照读
> - 3-16 锁模块之RR如何避免幻读
> - 3-17 锁模块小结
> - 3-18 关键语法讲解
> - 3-19 本章总结
> - 3-20 彩蛋之面试的三层架构

------

参考与推荐如下文章：

- ranjun940726 [《PHP 面试指南》](https://www.kancloud.cn/ranjun940726/php_interview)
- 紫葡萄0 [《MySQL 索引的使用和优化》](https://www.jianshu.com/p/07c42e310e67)
- Ddaidai [《【MySQL】20 个经典面试题》](https://www.jianshu.com/p/977a9e7d80b3)
- 瘦瘦鸭 [《MySQL 面试知识点总结》](https://segmentfault.com/a/1190000014316316)
- 立超的专栏 [《MyISAM 和 InnoDB 的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)
- 时芥蓝 [《MySQL 面试之必会知识点》](https://www.jianshu.com/p/5052f6a454ef)
- derrantcm [《【面试】【MySQL常见问题总结】【04】》](https://blog.csdn.net/DERRANTCM/article/details/51535193)
- mrlapulga [《MySQL 经典面试题》](https://www.mrlapulga.com/?p=59) 提供的面试题，难的想哭。
- 小麦苗 [《MySQL 笔试面试题集合》](https://yq.aliyun.com/articles/283427) 全的想哭。

**文章目录**

1. 开发
   1. [为什么互联网公司一般选择 MySQL 而不是 Oracle?](http://svip.iocoder.cn/MySQL/Interview/#为什么互联网公司一般选择-MySQL-而不是-Oracle)
   2. [数据库的三范式是什么？什么是反模式？](http://svip.iocoder.cn/MySQL/Interview/#数据库的三范式是什么？什么是反模式？)
   3. [MySQL 有哪些数据类型？](http://svip.iocoder.cn/MySQL/Interview/#MySQL-有哪些数据类型？)
   4. [MySQL 有哪些存储引擎？](http://svip.iocoder.cn/MySQL/Interview/#MySQL-有哪些存储引擎？)
   5. [【重点】什么是索引？](http://svip.iocoder.cn/MySQL/Interview/#【重点】什么是索引？)
   6. [【重点】MySQL 索引的原理？](http://svip.iocoder.cn/MySQL/Interview/#【重点】MySQL-索引的原理？)
   7. [【重点】请说说 MySQL 的四种事务隔离级别？](http://svip.iocoder.cn/MySQL/Interview/#【重点】请说说-MySQL-的四种事务隔离级别？)
   8. [【重点】请说说 MySQL 的锁机制？](http://svip.iocoder.cn/MySQL/Interview/#【重点】请说说-MySQL-的锁机制？)
   9. [【重要】MySQL 查询执行顺序？](http://svip.iocoder.cn/MySQL/Interview/#【重要】MySQL-查询执行顺序？)
   10. [【重要】聊聊 MySQL SQL 优化？](http://svip.iocoder.cn/MySQL/Interview/#【重要】聊聊-MySQL-SQL-优化？)
   11. [【加分】什么是 MVCC ？](http://svip.iocoder.cn/MySQL/Interview/#【加分】什么是-MVCC-？)
   12. [编写 SQL 查询语句的考题合集](http://svip.iocoder.cn/MySQL/Interview/#编写-SQL-查询语句的考题合集)
   13. [MySQL 数据库 CPU 飙升到 500% 的话，怎么处理？](http://svip.iocoder.cn/MySQL/Interview/#MySQL-数据库-CPU-飙升到-500-的话，怎么处理？)
2. 运维
   1. [Innodb 的事务与日志的实现方式](http://svip.iocoder.cn/MySQL/Interview/#Innodb-的事务与日志的实现方式)
   2. [MySQL binlog 的几种日志录入格式以及区别](http://svip.iocoder.cn/MySQL/Interview/#MySQL-binlog-的几种日志录入格式以及区别)
   3. [MySQL 主从复制的流程是怎么样的？](http://svip.iocoder.cn/MySQL/Interview/#MySQL-主从复制的流程是怎么样的？)
   4. [聊聊 MySQL 备份方式？备份策略是怎么样的？](http://svip.iocoder.cn/MySQL/Interview/#聊聊-MySQL-备份方式？备份策略是怎么样的？)
   5. [聊聊 MySQL 集群?](http://svip.iocoder.cn/MySQL/Interview/#聊聊-MySQL-集群)
   6. [聊聊 MySQL 安全？](http://svip.iocoder.cn/MySQL/Interview/#聊聊-MySQL-安全？)
   7. [MySQL 有哪些日志？](http://svip.iocoder.cn/MySQL/Interview/#MySQL-有哪些日志？)
   8. [聊聊 MySQL 监控？](http://svip.iocoder.cn/MySQL/Interview/#聊聊-MySQL-监控？)
   9. [对一个大表做在线 DDL ，怎么进行实施的才能尽可能降低影响？](http://svip.iocoder.cn/MySQL/Interview/#对一个大表做在线-DDL-，怎么进行实施的才能尽可能降低影响？)
3. [彩蛋](http://svip.iocoder.cn/MySQL/Interview/#彩蛋)

© 2014 - 2020 芋道源码 | 

总访客数 841210 次 && 总访问量 3974138 次

[回到首页](http://svip.iocoder.cn/index)



https://mp.weixin.qq.com/s/Qfvfj9R_dJiV65s48IdLdQ

https://www.jianshu.com/u/b64b58a43e1c

