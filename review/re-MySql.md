### 基础

#### 数据库的三范式是什么？什么是反模式？

1. 原子性
2. 完全依赖主键
3. 直接依赖于主键

表多，join，性能

反设计模式：宽表

#### Mysql数据类型

#### varchar 则是一种可变长度的类型，（50）排序占内存少

#### int(11) 中的 11影响展示效果

#### 金钱decimal 

#### 自增主键，InnoDB类型重启丢失，MyISAM 类型记录不丢失

#### COUNT(*) ，InnoDB类型全表扫描，MyISAM 类型记录

#### InnoDB 的 [4 大特性](https://note.youdao.com/ynoteshare1/index.html?id=a6004953a0a7c80073ac74d8e76f1ebd&type=note)

- [插入缓冲](https://www.cnblogs.com/zhs0/p/10528520.html)(insert buffer/ change buffer) 
  - 非聚簇索引
  - 插入缓存，合并
  - 减少随机IO，提升性能
- 二次写(double write)
  - 写入磁盘之前，缓存，崩溃恢复
- 自适应哈希索引(ahi)
  - 监控热数据，自适应变成hash索引
- 预读(read ahead)：提升IO性能
  - 线性预读：阀值，默认56，下一个extent放入buffer pool
  - 随机预读：当前extent中剩余的page，5.5废弃

#### MySQL 存储引擎：

- `InnoDB`
- `MyISAM`
- MRG_MYISAM
- MEMORY

#### MyISAM和InnoDB

- 事物
- 锁
- 崩溃恢复
- MVCC应对高并发





#### 字符集指的是⼀种从**⼆进制编码**到某类**字符符号**的**映射**。校对规则则是指某种**字符集下**的**排序规则**。



![image-20200927201915956](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200927201926.png)



### 索引

#### 好处

- 缩小查询数目，加快检索速度，降低IO成本
- 数据预先排好序，排序成本、CPU消耗

#### 坏处

- 占用存储空间
- 降低更新表的速度

#### 场景

- 中大型表
- 特大型的表，建立和使用索引的代价随着增长，建议**分库分表**

#### 索引类型

- 1、普通索引
- 2、唯一索引
- 3、主键索引
- 4、复合索引
- 5、外键索引
- 6、全文索引

#### **创建**原则

1.  `WHERE` 子句中的列，或连接子句中的列
2. **基数越大**，索引效果越好
3. 创建**复合索引，基数更大**
4. 避免**创建过多**的索引，**占空间，降低写效率**
5. **主键**尽可能**选择较短**的数据类型，可以有效**减少索引的磁盘**占用提高查询效率。
6. 对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间。

#### **使用**注意事项

- 1、避免在 `WHERE` 子句中使用 `!=` 或 `<>` 、`column IS NULL`  `OR`，否则将引擎放弃使用索引而进行**全表扫描**。优化器将**无法通过索引来确定将要命中的行数**,因此需要搜索该表的所有行。
- 3、应尽量避免在 `WHERE` 子句中**对字段进行表达式、函数操作**，这将导致引擎放弃使用索引而进行全表扫描。
- 5、不要在 `WHERE` 子句中的 `=` 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
- 6、复合索引**遵循前缀原则**。
- 7、如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中**添加强制索引**。
- 8、列类型是**字符串类型**，查询时一定要给值**加引号**，否则索引失效。
- 9、`LIKE` 查询，`%` 不能在前，因为无法使用索引。如果需要模糊匹配，可以使用全文索引。

####  以下三条 SQL 如何建索引，只建一条怎么建？

```
WHERE a = 1 AND b = 1
WHERE b = 1
WHERE b = 1 ORDER BY time DESC
```

- 以顺序 b , a, time 建立复合索引，`CREATE INDEX table1_b_a_time ON index_test01(b, a, time)`。
- 对于第一条 **SQL** ，因为最新 MySQL 版本会**优化** `WHERE` 子句后面的列顺序，以匹配复合索引顺序。

#### （重点）EXPLAIN

详细看看 [《MySQL explain 执行计划详细解释》](http://www.jfox.info/2017/mysql-explain执行计划详细解释.html) 。

#### 索引原理

[《MySQL索引背后的数据结构及算法原理》](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

在 MySQL 中，我们可以看到两种索引方式：

- B-Tree 索引。
- Hash 索引。

##### 磁盘的相关知识

系统从磁盘读取数据基本单位：磁盘块（block）

InnoDB 读取基本单位  page：16k > block

B-Tree 结构的数据可以让**系统高效的找到数据所在的磁盘块**。

**磁盘预读**

局部性原理：

当一个数据被用到时，其附近的数据也通常会马上被使用。

预读的长度一般为页（page）的整倍数

##### B-Tree

B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：

[![B-Tree 的结构](http://static2.iocoder.cn/84ea509fa091a10add4e7614e6cb37db)](http://static2.iocoder.cn/84ea509fa091a10add4e7614e6cb37db)B-Tree 的结构

- 每个节点占用一个盘块的磁盘空间
  - 一个节点上有两个升序排序的 key 和三个指向子树根节点的 point ，
  - point 存储的是子节点所在磁盘块的地址。
  - 两个 key 划分成的三个范围域，对应三个 point 指向的子树的数据的范围域。

发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的 key 是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素**。B-Tree 相对于 AVLTree 缩减了节点个数**，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。

#####  **B+Tree 索引**

将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：

[![B+Tree 的结构](http://static2.iocoder.cn/259d196856a231aff5e3cf1505848af4)](http://static2.iocoder.cn/259d196856a231aff5e3cf1505848af4)B+Tree 的结构

B+Tree 是在 B-Tree 基础上的一种优化，**使其更适合实现外存储索引结构**，InnoDB存储引擎就是用 B+Tree 实现其索引结构。

- 有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息
- 去掉B-Tree节点的date数据，key存储增多，减少树的深度（减少磁盘I/O次数）

B+Tree 相对于 B-Tree 有几点不同：

- 非叶子节点只存储键值信息。
  - key存储增多，减少树的深度（减少磁盘I/O次数）
- 所有叶子节点之间都有一个链指针。
  -  B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点
  - 可以对 B+Tree 进行两种查找运算：一种是**对于主键**的**范围查找**和**分页查找**，另一种是从根节点开始，**进行随机查找**。
- 数据记录都存放在叶子节点中。

推算：

- InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个字节） 或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 **16KB/(8B+8B)=1K 个键值**（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护10^3 *10^3* 10^3 = **10亿 条记录**。
- 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2~4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。

#### 资料

http://blog.codinglabs.org/articles/theory-of-mysql-index.html