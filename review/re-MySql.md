### 基础

#### 数据库的三范式是什么？什么是反模式？

1. 原子性
2. 完全依赖主键
3. 直接依赖于主键

表多，join，性能

反设计模式：宽表

#### Mysql数据类型

#### varchar 则是一种可变长度的类型，（50）排序占内存少

#### int(11) 中的 11影响展示效果

#### 钱用decimal 

#### 自增主键，InnoDB类型重启丢失，MyISAM 类型记录不丢失

#### COUNT(*) ，InnoDB类型全表扫描，MyISAM 类型记录

#### InnoDB 的 [4 大特性](https://note.youdao.com/ynoteshare1/index.html?id=a6004953a0a7c80073ac74d8e76f1ebd&type=note)

- [插入缓冲](https://www.cnblogs.com/zhs0/p/10528520.html)(insert buffer/ change buffer) 
  - **非聚簇索引**
  - 插入缓存，合并
  - 减少随机IO，提升性能
- 二次写(double write)
  - 写入磁盘之前，缓存，崩溃恢复
- 自适应哈希索引(ahi)
  - 监控热数据，自适应变成hash索引
- 预读(read ahead)：提升IO性能
  - 线性预读：阀值，默认56，下一个extent放入**buffer pool**
  - 随机预读：当前extent中剩余的page，5.5废弃

#### MySQL 存储引擎：

- `InnoDB`：不支持事务、也不支持外键，优势是访问速度快
- `MyISAM`：事物，行级别锁，崩溃恢复。
- MRG_MYISAM：Merge存储引擎是**一组MyISAM表的组合**
- MEMORY：使用存在于**内存**中的内容来创建表。

#### MyISAM和InnoDB

- 事物
- 锁
- 崩溃恢复
- MVCC应对高并发





#### 字符集指的是⼀种从**⼆进制编码**到某类**字符符号**的**映射**。校对规则则是指某种**字符集下**的**排序规则**。



![image-20200927201915956](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200927201926.png)



### 索引

#### 好处

- **缩小查询数目**，加快检索速度，**降低IO成本**
- 数据**预先排好序**，排序成本、CPU消耗

#### 坏处

- **占用存储空间**
- **降低更新表的速度**

#### 场景

- **中大型表**
- 特大型的表，建立和使用索引的代价随着增长，建议**分库分表**

#### 索引类型

- 1、普通索引
- 2、唯一索引
- 3、主键索引
- 4、复合索引

#### **创建**原则

1.  `WHERE` 子句中的**列**，**或连接子句中的列**
2. **基数越大**，索引效果越好
3. 创建**复合索引，基数更大**
4. 避免**创建过多**的索引，**占空间，降低写效率**
5. **主键**尽可能**选择较短**的数据类型，可以有效**减少索引的磁盘**占用提高查询效率。
6. 对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间。

#### **使用**注意事项

- 应尽量避免在 `WHERE` 子句中**对字段进行判断、表达式、函数操作**，优化器将**无法通过索引来确定将要命中的行数**，导致引擎放弃使用索引而进行全表扫描。
  - 判断： `!=` 或 `<>` 、`column IS NULL` 、 `OR`
- 不要在 `WHERE` 子句中的 `=` **左边**进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
- 复合索引**遵循前缀原则**。
- 如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中**添加强制索引**。
- 列类型是**字符串类型**，查询时一定要给值**加引号**，否则索引失效。
- `LIKE` 查询，`%` 不能在前，因为无法使用索引。如果需要模糊匹配，可以使用全文索引。

####  以下三条 SQL 如何建索引，只建一条怎么建？

```
WHERE a = 1 AND b = 1
WHERE b = 1
WHERE b = 1 ORDER BY time DESC
```

- 以顺序 b , a, time 建立复合索引，`CREATE INDEX table1_b_a_time ON index_test01(b, a, time)`。
- 对于第一条 **SQL** ，因为最新 MySQL 版本会**优化** `WHERE` 子句后面的列顺序，以匹配复合索引顺序。

#### （重点）EXPLAIN

详细看看 [《MySQL explain 执行计划详细解释》](http://www.jfox.info/2017/mysql-explain执行计划详细解释.html) 。

![image-20201014205144535](https://gitee.com/chenchong0817/picture/raw/master/Aaron/image-20201014205144535.png)

具体解释如下

1. 执行id
   包含一组数字，id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行
2. **查询类型select_type**
   type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： 
   system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL ，一般来说，得**保证查询至少达到range级别，最好能达到ref**。
   - **ALL**: 扫描全表
   - **index**: 扫描全部索引树
   - **range**: 扫描部分索引，索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、<、>等的查询
   - ref: **非唯一性索引扫描**，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找
   - eq_ref：**唯一性索引扫描**，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描
3. possible_keys
   指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
4. **key**：**显示MySQL在查询中实际使用的索引**，若没有使用索引，显示为NULL
   TIPS：查询中若使用了覆盖索引，则该索引仅出现在key列表中
5. key_len
   表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
6. ref
   表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
7. **rows**：
   表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行
8. Extra
   包含不适合在其他列中显示但十分重要的额外信息

二、关于MySQL执行计划的局限总结如下：
1.EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
2.EXPLAIN**不考虑各种Cache**
3.EXPLAIN**不能显示MySQL在执行查询时所作的优化工作**
4.**部分统计信息是估算的，并非精确值**
5.EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划 

#### 索引原理

[《MySQL索引背后的数据结构及算法原理》](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

在 MySQL 中，我们可以看到两种索引方式：

- B-Tree 索引。
- Hash 索引。

##### 磁盘的相关知识

系统从磁盘读取数据基本单位：磁盘块（block）

InnoDB 读取基本单位  page：16k > block

B-Tree 结构的数据可以让**系统高效的找到数据所在的磁盘块**。



**磁盘预读**

局部性原理：

当一个数据被用到时，其附近的数据也通常会马上被使用。

预读的长度一般为页（page）的整倍数

##### AVL-Tree（自平衡二叉树）

2-3树、红黑树等

##### B-Tree

B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：

[![B-Tree 的结构](http://static2.iocoder.cn/84ea509fa091a10add4e7614e6cb37db)](http://static2.iocoder.cn/84ea509fa091a10add4e7614e6cb37db)B-Tree 的结构

- **每个节点占用一个盘块的磁盘空间**
  - 一个节点上有两个升序排序的 key 和三个指向子树根节点的 point ，
  - point 存储的是子节点所在磁盘块的地址。
  - **两个 key 划分成的三个范围域**，对应三个 point 指向的子树的数据的范围域。

发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的 key 是一个有序表结构，可以**利用二分法查找提高效率**。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素**。B-Tree 相对于 AVLTree 缩减了节点个数**，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。

#####  **B+Tree 索引**

将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：

[![B+Tree 的结构](http://static2.iocoder.cn/259d196856a231aff5e3cf1505848af4)](http://static2.iocoder.cn/259d196856a231aff5e3cf1505848af4)B+Tree 的结构

B+Tree 是在 B-Tree 基础上的一种优化，**使其更适合实现外存储索引结构**，InnoDB存储引擎就是用 B+Tree 实现其索引结构。

- 有**数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息**
- 去掉B-Tree节点的date数据，**key存储增多，减少树的深度（减少磁盘I/O次数）**

B+Tree 相对于 B-Tree 有几点不同：

- **非叶子节点只存储键值信息**。
  - key存储增多，减少树的深度（减少磁盘I/O次数）
- 所有叶子节点之间都有一个**链指针**。
  -  B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点
  - 可以对 B+Tree 进行两种查找运算：一种是**对于主键**的**范围查找**和**分页查找**，另一种是从根节点开始，**进行随机查找**。
- **数据记录都存放在叶子节点中**。

推算：

- InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个字节） 或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 **16KB/(8B+8B)=1K 个键值**（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护10^3 *10^3* 10^3 = **10亿 条记录**。
- 实际情况中每个节点可能不能填充满，因此在数据库中，**B+Tree 的高度一般都在 2~4 层**。MySQL 的 `InnoDB` 存储引擎在设计时是**将根节点常驻内存**的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。

##### **B-Tree 有哪些索引类型？**

索引类型分为**主键索引**和**非主键索引（辅助索引）**。

- **辅助索引**与聚集索引的区别在于辅助索引的**叶子节点**并不包含行记录的全部数据，而是存储相应行数据的**聚集索引键，即主键**。

当通过辅助索引来查询数据时，需要进过两步：

- 首先，InnoDB 存储引擎会遍历辅助索引找到主键。
- 然后，再通过主键在聚集索引中找到完整的行记录数据。

另外，InnoDB 通过**主键聚簇数据**，如果**没有定义主键**，会选择一个**唯一的非空索引代替**，如果没有这样的索引，会**隐式定义个主键作为聚簇索引**。

##### **聚簇索引的注意点有哪些？**

聚簇索引表**最大限度地提高了 I/O 密集型应用的性能**，但它也有以下几个限制：

- 1、**插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现**页分裂**，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。

  > 关于这一点，可能面试官会换一个问法。例如，为什么主键需要是**自增 ID** ，又或者为什么主键需要带有时间性关联。

- 2、**更新主键的代价很高**，因为将会导致被更新的行移动。

- 3、**回表：**二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

  > 当然，有一种情况可以**无需二次查找**，基于非主键索引查询，但是**查询字段只有主键 ID** ，那么在二级索引中就可以查找到。

- 4、**主键 ID 建议使用整型**。节点的数据可以存储更多主键 ID 。

##### 🦅 **什么是索引的最左匹配特性？**

当 B+Tree 的数据项是复合的数据结构，比如索引 `(name, age, sex)` 的时候，B+Tree 是按照从左到右的顺序来建立**组合索引搜索树**的（组合索引，就是三个索引在一个索引里面）。

- 比如当 `(张三, 20, F)` 这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex ，最后得到检索的数据。
- 但当 `(20, F)` 这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。
- 比如当 `(张三, F)` 这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以**只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了。**

#### 🦅 **MyISAM 索引实现**

> 艿艿：注意，我们上面看到的都是 InnoDB 存储引擎下的索引实现。

MyISAM 索引的实现，和 InnoDB 索引的实现是一样使用 B+Tree ，**差别在于 MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址**。

1）主键索引：

MyISAM引 擎使用B+Tree作为索引结构，**叶节点的data域存放的是数据记录的地址**。下图是MyISAM主键索引的原理图：

[![主键索引](http://static2.iocoder.cn/d49d260fc1eb8f992df0401b70d70e3d)](http://static2.iocoder.cn/d49d260fc1eb8f992df0401b70d70e3d)主键索引

- 这里设表一共有三列，假设我们以 Col1 为主键，上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。

2）辅助索引：

**在 MyISAM 中，主索引和辅助索引在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。**如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示：

[![辅助索引](http://static2.iocoder.cn/2fb922405a35479fa99eb2de4708638c)](http://static2.iocoder.cn/2fb922405a35479fa99eb2de4708638c)辅助索引

- 同样也是一颗 B+Tree ，data 域保存数据记录的地址。因此，**MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。**

MyISAM 的索引方式也叫做“**非聚集**”的，之所以这么称呼是为了与InnoDB 的聚集索引区分。

🦅 **MyISAM 索引与 InnoDB 索引的区别？**

- InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。

- InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。

- MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。

- InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

  > **覆盖索引**，指的是基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。
  >
  > 只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
  >
  > 如何实现:
  >
  > 将被查询的字段，建立到联合索引里去。

### 事物

**什么是事务？事务的四大特性是什么？并发事务会带来哪些问题？有哪些解决方案？**

https://mp.weixin.qq.com/s/Qfvfj9R_dJiV65s48IdLdQ

https://www.jianshu.com/u/b64b58a43e1c

#### 资料

http://blog.codinglabs.org/articles/theory-of-mysql-index.html