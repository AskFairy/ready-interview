# 网络体系结构

强烈推荐阅读两篇文章：

- [《计算机网络体系结构综述（上）》](https://blog.csdn.net/justloveyou_/article/details/69611328)
- [《计算机网络体系结构综述（下）》](https://blog.csdn.net/justloveyou_/article/details/69612153)

- **OSI 七层体系结构**具有概念清楚、理论完整的特点，是一个理论上的国际标准，但却不是事实上的国际标准。
- 具有简单易用特点的 **TCP/IP 四层体系结构**则是事实上的标准。

#### 简述 OSI 七层体系结构

自上而下是：

- 应用层（数据）：
- 表示层（数据）：
- 会话层（数据）：
- 传输层（段）：
- 网络层（包）：
- 数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正
- 物理层（比特流）：

#### 简述 TCP/IP 四层体系结构

自上而下是：

- 应用层：

  > HTTP、TELNET、FTP、SMTP

- 传输层

  > TCP、UDP

- 网络层

  > IP（IPV4/IPV6）、ARP协议、ICMP协议（Ping/Traceroute命令）

- 数据接口

  > PPP

#### 知道各个层使用的是哪个数据交换设备？

- 网关：应用层、传输层。

- **【重点】路由器：网络层**

  > 路由选择、存储转发

- **【重点】交换机：数据链路层、网络层**

  > 识别数据包中的 **MAC 地址信息**，根据 MAC 地址进行转发，并将这些 **MAC 地址与对应的端口记录在自己内部的一个地址表**中。

- 网桥：数据链路层

  > 将两个 LAN 连起来，根据 MAC 地址来转发帧。

- 集线器（Hub）：物理层

  > 纯硬件设备，主要用来连接计算机等网络终端。

- 中继器：物理层

  > 在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离。

🦅 **交换机是什么？**

🦅 **路由器是什么？**

🦅 **常见的路由选择协议，以及它们的区别？**

🦅 **什么是网关设备？**

####  **详细说明 Keepalived 的故障切换工作原理？**

这种故障切换，是通过 **VRRP** 协议来实现的。

- 主节点会按一定的时间间隔发送**心跳**信息的广播包，告诉备节点自己的存活状态信息。
- 当主节点发生故障时，**备节点**在一段时间内就**收到广播包**，从而判断主节点出现故障，因此会调用自身的**接管**程序来接管主节点的 IP 资源及服务。
- 当主节点**恢复**时，备节点会**主动释放资源**，恢复到接管前的状态，从而来实现主备故障切换

例如，MySQL 基于 Keepalived 实现高可用。详细的，可以看看 [《Keepalived + MySQL实现高可用》](https://www.cnblogs.com/gomysql/p/3856484.html) 。

### IP

#### IP 地址的分类？

IP 地址是指**互联网协议地址**，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个**逻辑地址**，以此来**屏蔽物理地址的**差异。

🦅 **IP 地址与物理地址的区别？**

- **物理地址(MAC 地址)，是数据链路层和物理层使用的地址**。
- IP 地址是**网络层**和以上各层使用的地址，是一种**逻辑地址**。
- 其中 **ARP 协议**用于 IP 地址与物理地址的对应。

详细的，可以看看 [《即生瑜，何生亮 —— MAC 地址与 IP 地址》](http://blog.sciencenet.cn/blog-411071-1037673.html) 文章。

### 网络层的 ARP 协议工作原理？

**网络层**的 **ARP 协议**完成了 **IP 地址与物理地址的映射**。

- 首先，**每台主机**都会在自己的 ARP 缓冲区中建立一个 **ARP 列表**，以表示 IP 地址和 MAC 地址的对应关系。
- 当源主机需要将一个数据包要**发送**到目的主机时，会首先**检查**自己 **ARP 列表**中是否存在该 IP 地址**对应的 MAC 地址**：
  - 如果**有**，就直接将数据包**发送**到这个 **MAC 地址**。
  - 如果**没有**，就向本地网段发起一个**ARP请求的广播包**，查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。**网络中所有的主机**收到这个 ARP 请求后，**会检查数据包中的目的 IP 是否和自己的 IP地址一致。**
    - 如果不相同，就忽略此数据包。
    - 如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中(如果 ARP 表中已经存在该 IP 的信息，则将其覆盖)，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。
      - 源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。
      - 如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。

> 注意，在 OSI 模型中 ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层。

### 如何划分子网、超网？

🦅 **什么是子网，如何划分子网？**

🦅 **超网干什么的？如何划分超网？**

🦅 **子网掩码的作用？**

子网掩码只有一个作用，就是**将某个 IP 地址**划分成**网络地址**和**主机地址**两部分。

用于子网掩码的位数，决定于可能的子网数目和每个子网的主机数目。

## 什么是单播、组播(多播)、广播、任播？

- **单播**(unicast): 是指封包在计算机网络的传输中，目的地址为**单一目标的一种**传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如**一切基于TCP的协议**。
- **组播**(multicast): 也叫多播， 多点广播或群播。 指把信息同时传递给一组目的地址。它使用策略是最高效的，因为消息在每条网络链路上只需传递一次，而且只有在链路分叉的时候，消息才会被复制。
- **广播**(broadcast):是指封包在计算机网络中传输时，目的地址为网络中所有设备的一种传输方式。实际上，这里所说的“所有设备”也是限定在一个范围之中，称为“广播域”。
- **任播**(anycast):是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。

感兴趣的胖友，可以详细看 [《单播，组播(多播)，广播以及任播》](https://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/) 文章。

## 区别 IPv4 和 IPv6 ？

**IP地址编址标准**

- 我们大多数人使用的是**第二代互联网 IPv4 技术，地址长度32位**，它的最大问题是**网络地址资**源有限，从**理论**上讲能编址 1600 万个网络、链接 40 亿台主机。而根据相关数据，全球 IPv4 的 IP 地址已经**即将用完**。
- 而 IPv6 是作为 IETF 设计的用于**替代**现行版本 IP 协议(IPv4)的下一代 IP 协议，其 IPV6 **地址长度为 128位**，地址空间增大了 2^98 次方倍，几乎可以说是用之不竭的。所以随着 IPv4 不足，支持 IPv6 的网络势必会增长。

# ICMP

## ICMP 协议的主要功能？

用于在 **IP 主机、路由器之间传递控制消息**。

## 简述一下 ping 的原理？

一般在网络不通的时候，大家会用 ping 测一下网络是否通畅。

**ping 是基于 ICMP 协议工作的**。ICMP 全称 Internet Control Message Protocol ，就是互联网**控制**报文协议。

## 什么是 Traceroute ？

> Traceroute 是构建在 ICMP 协议之上的应用。

Traceroute ，是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。



Traceroute 的**原理**：traceroute 发送的是端口号 >30000的 UDP 包，给目标注解 TTL=1，路由器TTL 减1，直到0，路由器返回不可达，主机TTL加1,再发。目的主机发送的是端口不可达

# TCP

## TCP 是什么？

TCP(Transmission Control Protocol)，传输控制协议，是一种面向**连接**的、**可靠**的、基于**字节流**的**传输层通信协议**。主要特点如下：

- TCP 是面向**连接**的。

  > 就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接

- 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是**点对点**的（一对一）。

- TCP 提供**可靠**交付的服务。通过TCP连接传送的数据，**无差错、不丢失、不重复、并且按序到达**。

- TCP 提供全**双工通信**。TCP 允许通信双方的应用进程在**任何时候都能发送数据**。TCP 连接的两端都设有**发送缓存和接收缓存**，用来临时存放双方通信的数据。

- 面向**字节流**。

  > TCP 中的“流”（Stream），指的是流入进程或从进程流出的字节序列。
  >
  > “面向字节流”的含义是：**虽然应用程序和 TCP 的交互是一次一个数据块**（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是**一连串的无结构的字节流**。

## TCP 对应的应用层协议？

- **FTP** ：定义了**文件传输协议**，使用 **21 端口**。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。
- **Telnet** ：它是一种**用于远程登陆的端口**，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是纯字符界面的，支持 BBS 的服务器将 **23 端口**打开，对外提供服务。
- **邮箱**
  - SMTP ：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。
  - POP3 ：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Foxmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是 163 邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。
- HTTP ：从 Web 服务器传输超文本到本地浏览器的传送协议。

## TCP 头部是怎么样的？

- [《通俗大白话来理解 TCP 协议的三次握手和四次分手》](https://github.com/jawil/blog/issues/14) 的 [「TCP头部」](http://svip.iocoder.cn/Net/Interview/#) 小节。
- [《TCP 协议的学习 （二）TCP 头部信息》](https://blog.csdn.net/qq_34501940/article/details/51073691)

![img](https://camo.githubusercontent.com/137a789143b6c6d8af61e62930b9eda514c10ad1/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323434383735322d613636353239636164633332343032302e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

上面就是**TCP协议头部**的格式，由于它太重要了，是理解其它内容的基础，下面就将每个字段的信息都详细的说明一下。

- **源端口号**（Source Port）和**目的端口号**（Destination Port）:分别占用16位，表示源端口号和目的端口号；用于**区别主机中的不同进程**，而**IP地址**是用来**区分**不同的**主机**的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；
- **序号**（Sequence Number）:用来标识从TCP发端向TCP收端发送的数据字节流，它**表示本报文段中的的第一个数据字节在数据流中的序号**；主要用来**解决网络报乱序**的问题；
  - 面向字节流的，每个字节都按序号编号。序号301，传了100字节，本次传送的是301-400
- **确认号**（Acknowledgment Number）:32位确认序列号包含**发送确认的一端所期望收到的下一个序号**，因此，确认序号应当是上次已成功收到数据**字节序号加1**。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来**解决不丢包**的问题；
- **数据偏移Offset**:**给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的**。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；
- **标志位（TCP Flags）**:TCP首部中有**6个标志比特**，它们中的**多个可同时被设置为1**，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：

> **URG**：此标志表示TCP包的**紧急指针域有效**，用来**保证TCP连接不被中断**，并且督促中间层设备要尽快处理这些数据；
>
> **ACK**：此标志表示**应答域有效**，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；
>
> - **TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1**
>
> **PSH**：这个标志位**表示Push操作**。所谓Push操作就是指在数据包到达接收端以后，**立即传送**给应用程序，而**不是在缓冲区中排队**；
>
> **RST**：这个标志表示**连接复位请求**。用来*复位那些产生错误的连接，也被用来拒绝错误和非法的数据包*；
>
> **SYN**：**表示同步序号，用来建立连接**。SYN标志位和ACK标志位搭配使用，
>
> - 当**请求**连接的时候**发送**，`SYN=1，ACK=0`的发送报文；
> - 当**同意**连接的时候**回复**，`SYN=1，ACK=1`的接收报文；
>
> - 这个标志的数据包经常被用来进行端口扫描。*扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口*；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫*描的成功表示被扫描的机器不很安全*，*一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手*；
>
> **FIN**： **表示发送端已经达到数据末尾**，也就是说**双方的数据传送完成**，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也*经常被用于进行端口扫描。*

- **Window**:窗口大小，也就是有名的**滑动窗口，用来进行流量控制**；

##  TCP三次握手？



[![TCP 三次握手的干货](http://static2.iocoder.cn/04edb57536fc9bbd3ea096cafa5d3630)](http://static2.iocoder.cn/04edb57536fc9bbd3ea096cafa5d3630)TCP 三次握手的干货

- 第一次握手：

  - 发送数据包：标志位（`SYN=1，ACK=0`），序号（`seq=随机值J`）
  - 客户端进入SYN_SENT状态，等待服务端确认。

- 第二次握手：

  - 服务端收到标志位（`SYN=1，ACK=0`）的数据包，知道这是一个请求连接的报文
  - 返回数据包：标志位（`SYN=1，ACK=1`），确认号（`ack=J+1`），序号（`seq=随机K`）
  - Server 进入 `SYN_RCVD` 状态

- 第三次握手：

  - 客户端收到标志位（`SYN=1，ACK=1`）的报文，知道这是个连接确认报文。
    - 验证确认号`ack是否是J+1`
    - 如果正确，则将标志位 `ACK=1`  ，`ack=K+1` ，并将该数据包发送给 服务端 。此时，`Client` 进入 `ESTABLISHED（连接建立）` 状态。

  - 客户端检查`确认号`是否为`ack=K+1` ，`ACK=1` ，
    - 如果正确则连接建立成功。此时 `Server` 进入 `ESTABLISHED` 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。

🦅 **为什么 TCP 连接需要三次握手，两次不可以么，为什么？**

- 为了防止**客户端已失效的连接请求**报文突然又传送到了服务端，导致服务器端的一直等待而浪费资源。

**🦅 客户端不断进行请求链接会怎样？**

> SYN 攻击，英文为 SYN Flood ，是一种典型的 DoS/DDoS 攻击。

- 1、**客户端**向服务端发送**请求连接数据包**。

- 2、服务端向客户端发送确认数据包。

- 3、**客户端**不向服务端**发送确认数据包**，服务器一直等待来自客户端的确认。

🚀 如何检测 SYN 攻击？

- 检测 SYN 攻击非常的方便，当你在服务器上看到大量的**半连接状态**时，特别是源 **IP 地址是随机的**，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 **netstat 命令**来检测 SYN 攻击。

🚀 怎么解决 SYN 攻击呢？

​				答案是**只能预防**，没有彻底根治的办法，除非不使用 TCP 。方式如下：

- 1、**限流**：限制同时打开 SYN 半链接的数目

- 2、**超时**：缩短 SYN 半链接的 Timeout 时间

- 3、**关闭**不必要的服务。

- 4、**增加**最大半连接数。

- 5、**过滤**网关防护。

- 6、**SYN cookie技术**（对 TCP 的增强）。

## 【重要】什么是 TCP 四次挥手？

详细来说，步骤如下：

[![TCP 四次挥手的干货](http://static2.iocoder.cn/2cf7b8d1689ae6e920ef1b2c3eafb8b2)](http://static2.iocoder.cn/2cf7b8d1689ae6e920ef1b2c3eafb8b2)

![image-20200930120623902](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200930120632.png)

> 如下使用 Client 和 Server 的方式，仅仅是为了方便，也是可以从 Server 向 Client 发起。

1. 第一次挥手：
   - Client 设置"`序号（Sequence Number）：seq=x`"和"`确认号（Acknowledgment Number）ack=y`"，向主机2发送一个**标志位FIN=1**报文段；表名数据发送完毕。
   - Client 进入`FIN_WAIT_1`状态
2. 第二次挥手：
   - Client **收到**的**标志位FIN=1**报文段，**立即**回一个ACK=1报文段：`ack=x+1`；
   - Client 收到后进入`FIN_WAIT_2`状态；
   - Server 进入 `CLOSE_WAIT` 状态
3. 第三次挥手：
   - Server 向Client 发送FIN=1报文段：`seq=y+1`，请求关闭连接，
   - Server 进入`LAST_ACK`状态；
4. 第四次分手：
   - Client 收到Server 发送的FIN报文段，向Server 发送ACK=1报文段：`seq=y+2`，
   - Client 进入`TIME_WAIT`状态；
   - Server 收到Client 的ACK报文段以后，就关闭连接；
   - 此时，Client 等待`2MSL`后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

🦅 **为什么要四次挥手？**

TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。**分手需要双方同意**。**TCP 是全双工模式**，这就意味着：客户端可能发完了，但服务端可能还有数据需要发送给服务端。

**🦅 为何一定要等 2MSL ？**

等：如果不等，`client`释放的端口可能会`重连`刚断开的服务器端口，这样依然存活在网络里的老的 TCP 报文可能`与新` TCP 连接报文`冲突`，造成数据冲突。

2MSL：A主动断开，B被动断开。

1. A不确定B是否接受到自己的ACK，B如果没收到会重传FIN
2. B收到了也不会有反应

所以保守等待`2MSL`：去向**ACK消息最大存活时间**（MSL) + 来向**FIN消息的最大存活时间**(MSL)。

🦅  **TIME_WAIT 和 CLOSE_WAIT 状态的区别？**

- TIME_WAIT 表示**主动**关闭，CLOSE_WAIT 表示**被动**关闭

## 【重要】TCP 数据如何传输？

[![TCP 套接字的数据交换过程](http://static2.iocoder.cn/6ed78395a32a0fbf56afed309dc1eb71)](http://static2.iocoder.cn/6ed78395a32a0fbf56afed309dc1eb71)TCP 套接字的数据交换过程

- 为了保证数据准确到达，目标机器在收到数据包（包括 `SYN` 包、`FIN` 包、普通数据包等）包后必须立即回传 `ACK` 包，这样发送方才能确认数据传输成功。
- ack=seq+1，是为了告诉对方下次要传递的开始字节编号。

🦅 **TCP 数据传输丢失怎么办？什么是 TCP 重传？**

[![TCP套接字数据传输过程中发生错误](http://static2.iocoder.cn/a36ed3dad53b9b4439bc8156bc63a2c0)](http://static2.iocoder.cn/a36ed3dad53b9b4439bc8156bc63a2c0)TCP套接字数据传输过程中发生错误

- 为了完成数据包的重传，TCP 套接字每次发送数据包时都会**启动定时器**，如果在一定时间内没有收到目标机器传回的 `ACK` 包，那么定时器超时，数据包会重传。

- **重传超时时间**(RTO，Retransmission Time Out)，最好是网络上数据往返时间。

  > 理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。
  >
  > 往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 `ACK` 确认包（接收端收到数据后便立即确认），总共经历的时延。

- **重传次数**

  > TCP 数据包重传次数，根据**系统设置的不同而有所区别**。有些系统，一个数据包只会被重传 3 次，如果重传 3 次后还未收到该数据包的 `ACK` 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。
  >
  > 最后需要说明的是，**发送端**只有在收到对方的 `ACK` 确认包后，**才会清空输出缓冲区中的数据**。

另外，也推荐阅读 [《网络基本功（九）：细说TCP重传》](https://wizardforcel.gitbooks.io/network-basic/content/8.html) 。[原始链接](https://www.dell.com/community/%E7%BB%BC%E5%90%88%E8%AE%A8%E8%AE%BA%E5%8C%BA/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%B3%BB%E5%88%97-%E7%BB%86%E8%AF%B4%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-3%E6%9C%8826%E6%97%A5%E6%9B%B4%E6%96%B0/td-p/7045185)

## 【重要】什么是 TCP 滑动窗口？

**背景**：

> 将 `TCP` 与 `UDP` 这样的简单传输协议区分开来的是，它**传输数据的质量**。TCP **对于发送数据进行跟踪**，这种数据管理需要协议有以下两大关键功能：
>
> - 可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。
> - 数据流控：管理数据的发送速率，以使接收设备不致于过载。
>
> 要完成这些任务，整个协议操作是围绕**滑动窗口** + **确认机制**来进行的。因此，理解了滑动窗口，也就是理解了 TCP 。

 TCP 滑动窗口：

> 滑动窗口协议，是**传输层进行流控的一种措施**，**接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度**，从而达到防止发送方发送速度过快而导致自己被淹没的目的。
>
> TCP 的滑动窗口解决了**端到端的流量控制问题**，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。

**滑动窗口实现面向流的可靠性**

1. TCP是双工的协议，会话的双方都可以同时接收、发送数据。TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”
2. 最基本的传输可靠性来源于“确认重传”机制。

2. TCP的滑动窗口的可靠性也是建立在“确认重传”基础上的。
   - 双方只有收到ACK确认，才会移动窗口边界。

建议看下面三篇文章：

- [《TCP 滑动窗口控制流量的原理》](https://www.cnblogs.com/luoquan/p/4886345.html)

  > 比较易懂的一篇文章。

- [《网络基本功（八）：细说 TCP 滑动窗口》](https://wizardforcel.gitbooks.io/network-basic/content/7.html)

  > 更为详细的一篇文章。

- [《TCP 协议的滑动窗口具体是怎样控制流量的？》](https://www.zhihu.com/question/32255109)

  > 知乎上的讨论，重点看「wuxinliulei」和「安静的木小昊」的回答。特别是后者的，回答很生动形象。

## TCP 协议如何来保证传输的可靠性？

TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。

- 在一个 TCP 连接中，仅有两方进行彼此通信。
- 而字节流服务意味着两个应用程序通过 TCP 链接交换 8bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。

对于可靠性，TCP 通过以下方式进行保证：

- 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据。
- 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TC P报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层。
- 丢弃重复数据：对于重复数据，能够丢弃重复数据。
- 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。
- 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
- 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的**滑动窗口协议**。

## 什么是 TCP 拥堵？

计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做**拥塞**。

🦅 **怎么解决 TCP 拥堵？**

通过拥塞控制来解决。拥堵控制，就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个**全局性**的过程，而后者指**点对点**通信量的控制。

拥塞控制的方法主要有以下四种：

- 1、慢开始。
- 2、拥塞避免。
- 3、快重传。
- 4、快恢复。

**1）慢开始**

不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

**2）拥塞避免**

拥塞避免算法，让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1 ，而不是加倍，这样拥塞窗口按线性规律缓慢增长。

[![慢开始和拥塞避免算法的实现举例](http://static2.iocoder.cn/3ed1936c7ee8639606bc8b3dccc2d5bc)](http://static2.iocoder.cn/3ed1936c7ee8639606bc8b3dccc2d5bc)慢开始和拥塞避免算法的实现举例

**3）快重传**

快重传，要求接收方在收到一个**失序的报文段**后就立即发出**重复确认**（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。

快重传算法规定，发送方只要一连收到三个重复确认，就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

[![快重传的示意图](http://static2.iocoder.cn/96da7b757bb0dc2f2eaf86ac8ad20858)](http://static2.iocoder.cn/96da7b757bb0dc2f2eaf86ac8ad20858)快重传的示意图

**4）快恢复**

快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。

- 但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。
- 所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。

[![从连续收到三个重复的确认转入拥堵避免](http://static2.iocoder.cn/d5ac995144720c33399d8e518cb973a6)](http://static2.iocoder.cn/d5ac995144720c33399d8e518cb973a6)从连续收到三个重复的确认转入拥堵避免

# UDP

## UDP 是什么？

UDP（User Data Protocol，用户数据报协议），是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。

主要特点如下：

- UDP 是无连接的。

- UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）。

- UDP 是面向报文的。

- UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。

  > 对实时应用很有用，如 直播，实时视频会议等

- UDP 支持一对一、一对多、多对一和多对多的交互通信。

- UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。

## UDP 对应的应用层协议？

- DNS ：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。
- SNMP ：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- TFTP(Trivial File Transfer Protocol)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。

## 【重要】TCP 与 UDP 的区别

> 这个问题，上面在介绍 TCP 和 UDP 都提到了，就是做了整合哈。

TCP(Transmission Control Protocol)和 UDP(User Datagram Protocol) 协议属于传输层协议，它们之间的区别包括：

[![TCP 与 UDP 的区别](http://static2.iocoder.cn/047b5c455b1153e895df36e364134fcd)](http://static2.iocoder.cn/047b5c455b1153e895df36e364134fcd)TCP 与 UDP 的区别

- TCP 是面向连接的；UDP 是无连接的。
- TCP 是可靠的；UDP 是不可靠的。
- TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。
- TCP 是面向字节流的；UDP 是面向报文的。
- TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。
- TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。

🦅 **为什么 TCP 叫数据流模式？ UDP 叫数据报模式？**

所谓的**“流模式”**，是指**TCP 发送端发送几次数据和接收端接收几次数据是没有必然联系的**。

- 比如你通过 TCP 连接给另一端发送数据，你只调用了一次 write ，发送了 100 个字节，但是对方可以分 10 次收完，每次 10 个字节；你也可以调用 10 次 write ，每次 10 个字节，但是对方可以一次就收完。
- 原因：这是因为 TCP 是面向连接的，一个 Socket 中收到的数据都是由同一台主机发出，且有序地到达，所以每次读取多少数据都可以。

所谓的**“数据报模式”**，是指 **UDP 发送端调用了几次 write ，接收端必须用相同次数的 read 读完**。

- UDP 是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。
- 原因：这是因为 UDP 是无连接的，只要知道接收端的 IP 和端口，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。

## UDP 报文的格式

[![UDP 报文格式](http://static2.iocoder.cn/e80a784ed96b6c688ef8e4e409f4cd18)](http://static2.iocoder.cn/e80a784ed96b6c688ef8e4e409f4cd18)UDP 报文格式

- 16 位 * 4 = 64 位 = 8 字节。

# DNS

## DNS 是什么？

- 域名解析，[www.xxx.com](http://www.xxx.com/) 转换成 IP ，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。
- DNS 协议运行在 UDP 协议之上，使用端口号 53 。

## 主机解析域名的顺序？

1. 浏览器缓存
2. 找本机的 hosts 文件
3. 路由缓存
4. 找 DNS 服务器(本地域名、顶级域名、根域名)
   - [迭代查询](https://blog.csdn.net/wuchuanpingstone/article/details/6720723)
   - [递归查询](https://blog.csdn.net/wuchuanpingstone/article/details/6720723)

## DNS 使用什么协议？

> 参见 [《DNS使用的是 TCP 协议还是 UDP 协议》](https://benbenxiongyuan.iteye.com/blog/1088085) 文章。

既使用 TCP 又使用 UDP 。

- 区域传送时使用 TCP 协议。

  > - 辅域名服务器会定时（一般时 3 小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用 TCP 而不是 UDP ，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。
  > - TCP 是一种可靠的连接，保证了数据的准确性。

- 域名解析时使用 UDP 协议。

  > - 客户端向 DNS 服务器查询域名，一般返回的内容都不超过 512 字节，用 UDP 传输即可。
  >
  >   > UDP 报文的最大长度为 512 字节。
  >
  > - 不用经过 TCP 三次握手，这样 DNS 服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向 DNS 服务器查询的时候使用 TCP ，但事实上，很多 DNS 服务器进行配置的时候，仅支持 UDP 查询包。

# HTTP

## HTTP 是什么？

HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。

主要特点如下：

- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

- 数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。

- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

  > 主要指的是不使用 Keep-Alive 机制的情况下。

- 无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

  > 无状态，所以更容易做服务的扩容，支撑更大的访问量。

- 支持 B/S 及 C/S 模式。

  > 另外，HTTP 协议已经不仅仅使用在浏览器上。在前后端分离的架构中，又或者微服务架构的内部通信中，HTTP 因为其数据格式的通用性，和语言无关，被大规模使用。

## HTTP 基本格式

> 艿艿：详细的，可以看看 [《猫哥网络编程系列：详解 BAT 面试题》](https://github.com/kaiye/kaiye.github.com/issues/3) 文章。

🦅 **HTTP 请求格式**

[![HTTP 请求格式](http://static2.iocoder.cn/e0f66085155bdcdaa170fab4507fa4f1)](http://static2.iocoder.cn/e0f66085155bdcdaa170fab4507fa4f1)HTTP 请求格式

- 请求行：用来说明请求类型，要访问的资源以及所使用的 HTTP 版本。
- 请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部。
  - HOST ，将指出请求的目的地。
  - User-Agent ，服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础。该信息由你的浏览器来定义，并且在每个请求中自动发送等等
  - …
- 空行：请求头部后面的空行是必须的。
- 请求数据：也叫主体，可以添加任意的其他数据。

🦅 **HTTP 响应格式**

[![HTTP 响应格式](http://static2.iocoder.cn/da1ada597b5feedcd7d6c17d1989629d)](http://static2.iocoder.cn/da1ada597b5feedcd7d6c17d1989629d)HTTP 响应格式

- 状态行：由 HTTP 协议版本号、状态码、状态消息三部分组成。
- 消息报头：用来说明客户端要使用的一些附加信息。
- 空行：消息报头后面的空行是必须的。
- 响应正文：服务器返回给客户端的文本信息。

🦅 **URI 和 URL 的区别？**

见 [《URI 和 URL 的区别》](https://www.jianshu.com/p/ba15d066f777) 文章。

## HTTP 协议包括哪些请求？

- GET: 对服务器资源的简单请求。
- POST: 用于发送包含用户提交数据的请求。
- HEAD：类似于 GET 请求，不过返回的响应中没有具体内容，用于获取报头。
- PUT：传说中请求文档的一个版本。
- DELETE：发出一个删除指定文档的请求。
- TRACE：发送一个请求副本，以跟踪其处理进程。
- OPTIONS：返回所有可用的方法，检查服务器支持哪些方法。
- CONNECT：用于 SSL 隧道的基于代理的请求。

🦅 **GET 和 POST 的区别？**

| 请求方式 | 数据位置            | 明文密文 | 数据安全 | 长度限制          | 应用场景 |
| :------- | :------------------ | :------- | :------- | :---------------- | :------- |
| GET      | HTTP 请求的 path 中 | 明文     | 不安全   | 长度较小，一般 2k | 查询数据 |
| POST     | HTTP 请求 body 中   | 可明可密 | 安全     | 支持较大数据传输  | 修改数据 |

- GET 请求可被缓存；POST 请求不会被缓存。

- GET 请求可被收藏为书签；POST 不能被收藏为书签。

- 【非常有趣】参见 [《99%的人理解错 HTTP 中 GET 与 POST 的区别》](https://www.oschina.net/news/77354/http-get-post-different)

  > - 对于 GET 方式的请求，浏览器会把 HTTP header 和 data 一并发送出去，服务器响应 200（返回数据）。
  > - 而对于 POST，浏览器先发送 header ，服务器响应 100 continue ，浏览器再发送 data ，服务器响应 200 ok（返回数据）。
  >
  > 也就是说，GET 只需要汽车跑一趟就把货送到了，而 POS T得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。
  >
  > ps：不过要注意，POST 具体发几次，也和浏览器的实现有关系。例如：Firefox 只发一次。
  > ps2：据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。

## HTTP 有哪些状态码？

- 1×× : 请求处理中，请求已被接受，正在处理
- 2×× : 请求成功，请求被成功处理
  - 200 OK // 客户端请求成功
- 3×× : 重定向，要完成请求必须进行进一步处理
  - 301 Moved Permanently // 永久重定向,使用域名跳转
  - 302 Found // 临时重定向,未登陆的用户访问用户中心重定向到登录页面
- 4×× : 客户端错误，请求不合法
  - 400 Bad Request // 客户端请求有语法错误，不能被服务器所理解
  - 401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
  - 403 Forbidden // 服务器收到请求，但是拒绝提供服务
  - 404 Not Found // 请求资源不存在，eg：输入了错误的 URL
- 5×× : 服务器端错误，服务器不能处理合法请求
  - 500 Internal Server Error // 服务器发生不可预期的错误
  - 503 Server Unavailable // 服务器当前不能处理客户端的请求，一段时间后可能恢复正常

完整的状态码列表，可以看看 [《HTTP 状态码》](https://zh.wikipedia.org/zh-hans/HTTP状态码) 文章。

🦅 **forward 和 redirect 的区别？**

- 直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。
- 间接转发方式（Redirect），实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。

详细的，请看 [《请求转发（Forward）和重定向（Redirect）的区别》](https://www.cnblogs.com/Qian123/p/5345527.html) 。

🦅 **HTTP 返回码中 301 与 302 的区别？**

301，302 都是 HTTP 状态的编码，都代表着某个 URL 发生了转移，不同之处在于：

- 301 redirect: 301 代表永久性转移(Permanently Moved)。
- 302 redirect: 302 代表暂时性转移(Temporarily Moved)。

详细的，请看 [《HTTP 返回码中 301 与 302 的区别》](https://blog.csdn.net/qmhball/article/details/7838989) 文章。

## HTTP、TCP、Socket 的关系是什么？

- TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族。
- HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。
- Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。

综上所述：

- 需要 IP 协议来连接网络
- TCP 是一种允许我们安全传输数据的机制，使用 TCP 协议来传输数据的 HTTP 是 Web 服务器和客户端使用的特殊协议。
- HTTP 基于 TCP 协议，所以可以使用 Socket 去建立一个 TCP 连接。

## Cookies 和 Session 的区别

- Session 在服务器端，Cookie 在客户端（浏览器）。

  > Session 默认被存在在服务器的一个文件里（不是内存）。

- Session 的运行依赖 sessionid ，而 sessionid 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie ，同时 session 也会失效。但是，可以通过其它方式实现，比如在 url 参数中传递 sessionid 。

- Session 可以放在文件、数据库、或内存中都可以。

- 【关键】**用户验证这种场合一般会用 Session** 。

## 【重要】一次完整的 HTTP 请求所经历的步骤

> 这里的客户端，更多指的是浏览器。

- 1、DNS 解析(通过访问的域名找出其 IP 地址，递归搜索)。

- 2、HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手。

  > 如果是 HTTPS 请求，会略微有不同。等到 HTTPS 小节，我们在来讲。

- 3.1、客户端向服务器发送请求命令（一般是 GET 或 POST 请求）。

  > 这个是补充内容，面试一般不用回答。
  >
  > 客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
  >
  > 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。

- 3.2、客户端发送请求头信息和数据。

- 4.1、服务器发送应答头信息。

- 4.2、服务器向客户端发送数据。

- 5、服务器关闭 TCP 连接（4次挥手）。

  > 这里是否关闭 TCP 连接，也根据 HTTP Keep-Alive 机制有关。
  >
  > 同时，客户端也可以主动发起关闭 TCP 连接。

- 6、客户端根据返回的 HTML、CSS、JS 进行渲染。

如下是《图解HTTP》提供的图片：[![HTTP 请求所经历的步骤](http://static2.iocoder.cn/be5603b1bb6ff46b640909b5b8976827)](http://static2.iocoder.cn/be5603b1bb6ff46b640909b5b8976827)HTTP 请求所经历的步骤

## HTTP1.0 和 HTTP1.1 有什么区别？

主要是如下 8 点：

- 1、可扩展性

- 2、缓存

- 3、带宽优化

  > 带来了[分块传输](https://zh.wikipedia.org/wiki/分块传输编码) 。可能的话，面试也会问。

- 【最重要】4、长连接

- 5、消息传递

- 6、Host 头域

- 7、错误提示

- 8、内容协商

详细的每一点的说明，可以看 [《HTTP1.0 与 HTTP1.1 的区别》](https://blog.csdn.net/ForgotAboutGirl/article/details/6936982) 文章，特别是第 4 点【长连接】。

> HTTP1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）。
>
> - 长连接（PersistentConnection）：处理在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。在 HTTP1.1中 默认开启`Connection：keep-alive` ，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。
> - 请求的流水线（Pipelining）：HTTP1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。
>
> 推荐，在看看 [《HTTP Keep-Alive 是什么？如何工作？》](http://www.nowamagic.net/academy/detail/23350305) 文章。
>
> 关于这一点，可能演变的问题有：
>
> - HTTP 的长连接是什么意思？
> - HTTP Keep-Alive 机制是什么？
> - HTTP Keep-Alive 机制和 TCP Keep-Alive 有什么区别？

## SPDY 是什么？

> 艿艿：关于这个问题，了解就好。
>
> HTTP Working-Group 最终决定以 SPDY/2 为基础，开发 HTTP/2 。

2012 年，Google 如一声惊雷提出了 SPDY 的方案，优化了 HTTP1.X 的请求延迟，解决了 HTTP1.X 的安全性，具体如下：

- 1、降低延迟

  > 针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。多路复用通过多个请求 Stream 共享一个 Tcp连 接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。

- 2、请求优先级（request prioritization）

  > 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。
  >
  > 比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。

- 3、header 压缩

  > 前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。

- 4、基于 HTTPS 的加密协议传输

  > 大大提高了传输数据的安全性。

- 5、服务端推送（server push）

  > 采用了 SPDY 的网页，例如我的网页有一个 `sytle.css` 的请求，在客户端收到 `sytle.css` 数据的同时，服务端会将 `sytle.js` 的文件推送给客户端。当客户端再次尝试获取 `sytle.js` 时就可以直接从缓存中获取到，不用再发请求了。
  >
  > 🙂 和我们理解的服务端推送，有点（非常）不一样哈。

🚀 SPDY 构成图如下：[![SPDY 构成图](http://static2.iocoder.cn/82cf7ea112281d126f23db03a502c249)](http://static2.iocoder.cn/82cf7ea112281d126f23db03a502c249)SPDY 构成图

- SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议(将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。

# HTTPS

推荐先看下 [《九个问题从入门到熟悉 HTTPS》](http://juejin.im/post/58c5268a61ff4b005d99652a) 文章，写的很有趣~

另外，也看看 [《SSL/TLS 双向认证(一) – SSL/TLS工作原理》](https://blog.csdn.net/ustccw/article/details/76691248) 文章，写的更技术向~

下面的面试题的答案，我们会基于上述文章来整理。

## HTTPS 是什么？

HTTPS ，实际就是在 TCP 层与 HTTP 层之间加入了 SSL/TLS 来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。

[![img](http://static2.iocoder.cn/a9e8780d6b899cf5709579fc9c451fd9)](http://static2.iocoder.cn/a9e8780d6b899cf5709579fc9c451fd9)

一句话概括：**HTTP + 加密 + 认证 + 完整性保护 = HTTPS** 。

🦅 **什么是 SSL 呢？什么是 TLS 呢？**

官方定义，SSL 是安全套接层(secure sockets layer)；TLS 是 SSL 的继任者，叫传输层安全(transport layer security)。

它们存在的唯一目的就是保证上层通讯安全的一套机制。它的发展依次经历了下面几个时期，像手机软件升级一样，每次更新都添加或去除功能，比如引进新的加密算法，修改握手方式等。

- SSL1.0: 已废除
- SSL2.0: RFC6176 ，已废除
- SSL3.0: RFC6101 ，基本废除
- **TLS1.0**: RFC2246 ，目前大都采用此种方式
- TLS1.1: RFC4346
- TLS1.2: RFC5246 ，没有广泛使用
- TLS1.3: IETF 正在酝酿中

> 艿艿：为了下面描述方便，统一先叫 SSL 。

🦅 **SSL/TLS 协议作用？**

1. 认证用户和服务器，确保数据发送到正确的客户机和服务器。

   > 客户端必须避免中间人攻击，即除了真正的服务器，任何第三方都无法冒充服务器。

2. 加密数据以防止数据中途被窃取。

3. 维护数据的完整性，确保数据在传输过程中不被改变。

## HTTP 和 HTTPS 的区别？

- 端口不同：HTTP 与 HTTPS 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

  > 艿艿：个人的想法，实际 HTTPS 也是可以使用 80 端口，但是考虑继续保持 HTTP 的兼容，只好退而求其次，使用 443 端口。

- 资源消耗：和 HTTP 通信相比，HTTPS 通信会由于加解密处理消耗更多的 CPU 和内存资源。

- 开销：HTTPS 通信需要证书，而证书一般需要向认证机构申请免费或者付费购买。

  > HTTPS 可以有效的防止运营商劫持，解决了防劫持的一个大问题。

## SSL 加密方式是什么？

> - 对称密钥加密，是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。
> - 非对称加密，指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

SSL 协议，即用到了对称加密也用到了非对称加密，如下图所示：[![SSL 加密过程](http://static2.iocoder.cn/images/Net/2020_03_01/01.jpeg)](http://static2.iocoder.cn/images/Net/2020_03_01/01.jpeg)SSL 加密过程

> TODO 这个配图有问题。原图我在翻，貌似不小心被我删除了。。。。

- 在建立传输链路时，SSL 首先对对称加密的密钥使用公钥进行非对称加密。

  > 艿艿：注意哟，这里 Server 返回给 Client 的不是公钥( `server.pub` )，而是 `server.crt` 。Client 需要使用 `ca.key` 从 `server.crt` 中解密出公钥( `server.pub` ) 。

- 链路建立好之后，SSL 对传输内容使用公钥( `server.pub` )对称加密。

🦅 **为什么公钥传输的步骤这么复杂呢？**

答案请看 [《九个问题从入门到熟悉 HTTPS》](http://juejin.im/post/58c5268a61ff4b005d99652a) 文章的如下问题：

- Q5: 那公钥怎么传输
- Q6: 你在逗我么。。。。
- Q7: 怎么知道证书有没有被篡改？
- Q8: 这样可以防止第三方冒充服务器么

也就是说，通过 CA 来保证。至于 `server.crt` 证书是怎么申请的呢？请看 [《SSL/TLS 双向认证(一) – SSL/TLS工作原理》](https://blog.csdn.net/ustccw/article/details/76691248) 文章的 [「CA 的证书 ca.crt 和 SSL Server 的证书 server.crt 是什么关系呢？ 」](http://svip.iocoder.cn/Net/Interview/#) 问题的解答。

> 艿艿：看这块，我已经要被绕晕了！！！耐心~胖友，理解后会很爽。

## 什么是单向认证、双向认证？

- 单向认证，指的是只有一个对象校验对端的证书合法性。

  > 通常都是 Client 来校验服务器的合法性。那么 Client 需要一个`ca.crt` ，服务器需要 `server.crt` 和 `server.key` 。

- 双向认证，指的是相互校验，Server 需要校验每个 Client ，Client 也需要校验服务器。

  > - Server 需要 `server.key`、`server.crt`、`ca.crt` 。
  > - Client 需要 `client.key`、`client.crt`、`ca.crt` 。

🦅 **1）单向认证的过程？**

[![单向认证](http://static2.iocoder.cn/bdf6be06c37bcc026ed906f392661e3b)](http://static2.iocoder.cn/bdf6be06c37bcc026ed906f392661e3b)单向认证

- 1、客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。

- 2、服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书。

- 3、客户端使用服务端返回的信息验证服务器的合法性，包括：

  - 证书是否过期。

  - 发型服务器证书的 CA 是否可靠。

  - 返回的公钥是否能正确解开返回证书中的数字签名。

  - 服务器证书上的域名是否和服务器的实际域名相匹配

    > 验证通过后，将继续进行通信；否则，终止通信。

  - 4、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。
  - 5、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。

- 6、服务器将选择好的加密方案通过明文方式返回给客户端。

- 7、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器。

- 8、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。

  > **在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全**。

🦅 **2）双向认证的过程？**

双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：

[![双向认证](http://static2.iocoder.cn/61ed2a8b189fc549a9c7407c2ebedb64)](http://static2.iocoder.cn/61ed2a8b189fc549a9c7407c2ebedb64)双向认证

- 1、客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。

- 2、服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书。

- 3、客户端使用服务端返回的信息验证服务器的合法性，包括：

  - 证书是否过期。

  - 发型服务器证书的 CA 是否可靠。

  - 返回的公钥是否能正确解开返回证书中的数字签名。

  - 服务器证书上的域名是否和服务器的实际域名相匹配

    > 验证通过后，将继续进行通信；否则，终止通信。

  - **【新增】4、服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端。**
  - **【新增】5、验证客户端的证书，通过验证后，会获得客户端的公钥。**
  - 6、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。
  - 7、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。

- 8、服务器将选择好的加密方案通过明文方式返回给客户端。

- 9、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器。

- 10、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。

  > **在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全**。

🦅 **如何选择单向认证还是双向认证**

- 一般一个站点很多用户访问就用单向认证。

- 企业接口对接就用双向认证。

  > 如果想要提高 APP 的安全级别，也可以考虑双向认证。因为，APP 天然方便放入客户端证书，从而提高安全级别。

## 为什么抓包工具还能抓到 HTTPS 数据包并解密成功呢

不是说HTTPS在网络中传输的是密文吗？这个问题就是**中间者攻击**（man in zhe middle）。

[![中间者攻击原理图](http://static2.iocoder.cn/0332b5d6001f7446a04a5d54b9b93d7e)](http://static2.iocoder.cn/0332b5d6001f7446a04a5d54b9b93d7e)中间者攻击原理图

- 解决办法，就是 HTTPS 单向验证。在客户端中内置服务器公钥，在第三步服务器返回的公钥，除了验证公钥的有效性之外，再比对公钥是不是和内置的公钥一样，不一样说明被中间者攻击了，就断开链接不在请求了。
- 这个原理的前提是服务器的私钥没有泄露，客户端的代码不会被破解，道高一尺魔高一丈。信息安全就是在合理的范围内，选择比较合适的加密方法，没有绝对论，只有相对论。在某个范围内比较安全。

## HTTPS 握手会影响性能么？

TCP 有三次握手，再加上 HTTPS 的四次握手，影响肯定有，但是可以接受。

- 首先，HTTPS 肯定会更慢一点，时间主要花费在两组 SSL 之间的耗时和证书的读取验证上，对称算法的加解密时间几乎可以忽略不计。
- 而且如果不是首次握手，后续的请求并不需要完整的握手过程。客户端可以把上次的加密情况直接发送给服务器从而快速恢复，具体细节可以参考 [《图解 SSL/TLS 协议》](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html) 。
- 除此以外，SSL 握手的时间并不是只能用来传递加密信息，还可以承担起客户端和服务器沟通 HTTP2 兼容情况的任务。因此从 HTTPS 切换到 HTTP2.0 不会有任何性能上的开销，反倒是得益于 HTTP2.0 的多路复用等技术，后续可以节约大量时间。
- 如果把 HTTPS2.0 当做目标，那么 HTTPS 的性能损耗就更小了，远远比不上它带来的安全性提升。

# HTTP2

[![HTTP2 和 HTTP1.1 的区别](http://static2.iocoder.cn/482a127d8fd07940d8f255610c716792)](http://static2.iocoder.cn/482a127d8fd07940d8f255610c716792)HTTP2 和 HTTP1.1 的区别

## 什么是 HTTP2.0 ？

HTTP2.0 ，可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：

- HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS 。
- HTTP2.0 消息头的压缩算法采用 [HPACK](https://link.jianshu.com/?t=http://http2.github.io/http2-spec/compression.html)，而非 SPDY 采用的 [DEFLATE](https://link.jianshu.com/?t=http://zh.wikipedia.org/wiki/DEFLATE) 。

## HTTP2.0 和 HTTP1.X 相比的新特性？

- 1、新的二进制格式（Binary Format）

  > HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。

- 同 SPDY 对 HTTP1.1 的改进。

  - 2、降低延迟
  - 3、多路复用（MultiPlexing）
  - 4、header 压缩
  - 5、服务端推送（server push）

## Nginx 怎么做 HTTP2.0 的升级改造？

- 1、虽然 HTTP2.0 其实可以支持非 HTTPS 的，但是现在主流的浏览器像 Chrome，Firefox 表示还是只支持基于 TLS 部署的 HTTP2.0协议，所以要想升级成 HTTP2.0 还是先升级 HTTPS 为好。
- 2、当你的网站已经升级 HTTPS 之后，那么升级 HTTP2.0 就简单很多，如果你使用 NGINX ，只要在配置文件中启动相应的协议就可以了，可以参考 [NGINX白皮书](https://link.jianshu.com/?t=https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf)，[NGINX配置HTTP2.0官方指南](https://link.jianshu.com/?t=https://www.nginx.com/blog/nginx-1-9-5/) 。
- 3、使用了 HTTP2.0 那么，原本的 HTTP1.x 怎么办？这个问题其实不用担心，HTTP2.0 完全兼容 HTTP1.x 的语义，对于不支持 HTTP2.0 的浏览器，NGINX 会自动向下兼容的。

在我们内部的微服务 API 接口，也可以做 HTTP2 的改造，可以参考如下文章：

> 艿艿：选读，作为知识的扩充

- [《Spring Cloud 使用 HTTP2》](https://www.jianshu.com/p/ed3f8f983764)
- [《再说 SpringBoot2.0 与 HTTP/2》](https://www.jianshu.com/p/7ddcdd3847d6)

## HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？

- HTTP/1.0：一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接。
- HTTP/1.1：Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会。一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞。
- HTTP/2：多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。

如下图所示：[![HTTP/1.1 对比 HTTP/2](http://static2.iocoder.cn/7268e2a2553c6612396b7de03667d348)](http://static2.iocoder.cn/7268e2a2553c6612396b7de03667d348)HTTP/1.1 对比 HTTP/2

🦅 **HTTP2.0 多路复用有多好？**

> 艿艿：最近重新看了 TCP ，发现再看这个问题，真的是有趣！

HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。

HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

## 服务器推送到底是什么？

服务端推送能把客户端所需要的资源伴随着 `index.html` 一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：

- 普通的客户端请求过程：[![普通的客户端请求过程](http://static2.iocoder.cn/9eecd5ec56714731d0e38c6ef9c468d1)](http://static2.iocoder.cn/9eecd5ec56714731d0e38c6ef9c468d1)普通的客户端请求过程
- 服务端推送的过程：[![服务端推送的过程](http://static2.iocoder.cn/c30ec0b3743d1f9751d3ba511f94578b)](http://static2.iocoder.cn/c30ec0b3743d1f9751d3ba511f94578b)服务端推送的过程

## 为什么需要头部(header)压缩？

假定一个页面有 100 个资源需要加载（这个数量对于今天的 Web 而言还是挺保守的），而每一次请求都有 1kb 的消息头（这同样也并不少见，因为 Cookie 和引用等东西的存在），则至少需要多消耗 100kb 来获取这些消息头。HTTP2.0 可以维护一个字典，差量更新 HTTP 头部，大大降低因头部传输产生的流量。

具体参考：[《HTTP/2 头部压缩技术介绍》](https://link.jianshu.com/?t=https://imququ.com/post/header-compression-in-http2.html) 文章。

- 维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合。
- 维护一份相同的动态字典（Dynamic Table），可以动态地添加内容。
- 支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）。

# 彩蛋

感觉，大学丢掉的网络知识，又一次回到我的脑子中了。好开心，又可以遗忘一轮啦，哈哈哈哈。

参考与推荐如下文章：

- [《Https 单向认证和双向认证》](https://blog.csdn.net/duanbokan/article/details/50847612)
- [《【网络协议】ping 的工作原理》](https://blog.csdn.net/Maybe_ch/article/details/82598782)
- [《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》](https://www.jianshu.com/p/be29d679cbff)
- [《计算机网络常见面试题》](https://segmentfault.com/a/1190000010819141)
- [《总结的网络面试题》](https://www.jianshu.com/p/a1f5daf7ada5)
- [《面试/笔试第一弹 —— 计算机网络面试问题集锦》](https://blog.csdn.net/justloveyou_/article/details/78303617)
- [《通俗大白话来理解 TCP 协议的三次握手和四次挥手》](https://github.com/jawil/blog/issues/14)
- [《TCP 数据的传输过程》](https://www.jianshu.com/p/b71ec62b6eb5)
- [《搞定计算机网络面试，看这篇就够了（补充版）》](https://juejin.im/post/5b7be0b2e51d4538db34a51e)

**文章目录**

1. 网络体系结构
   1. [简述 OSI 七层体系结构](http://svip.iocoder.cn/Net/Interview/#简述-OSI-七层体系结构)
   2. [简述 TCP/IP 四层体系结构](http://svip.iocoder.cn/Net/Interview/#简述-TCP-IP-四层体系结构)
   3. [知道各个层使用的是哪个数据交换设备？](http://svip.iocoder.cn/Net/Interview/#知道各个层使用的是哪个数据交换设备？)
2. IP
   1. [IP 地址的分类？](http://svip.iocoder.cn/Net/Interview/#IP-地址的分类？)
   2. [网络层的 ARP 协议工作原理？](http://svip.iocoder.cn/Net/Interview/#网络层的-ARP-协议工作原理？)
   3. [如何划分子网、超网？](http://svip.iocoder.cn/Net/Interview/#如何划分子网、超网？)
   4. [什么是单播、组播(多播)、广播、任播？](http://svip.iocoder.cn/Net/Interview/#什么是单播、组播-多播-、广播、任播？)
   5. [区别 IPv4 和 IPv6 ？](http://svip.iocoder.cn/Net/Interview/#区别-IPv4-和-IPv6-？)
3. ICMP
   1. [ICMP 协议的主要功能？](http://svip.iocoder.cn/Net/Interview/#ICMP-协议的主要功能？)
   2. [简述一下 ping 的原理？](http://svip.iocoder.cn/Net/Interview/#简述一下-ping-的原理？)
   3. [什么是 Traceroute ？](http://svip.iocoder.cn/Net/Interview/#什么是-Traceroute-？)
4. TCP
   1. [TCP 是什么？](http://svip.iocoder.cn/Net/Interview/#TCP-是什么？)
   2. [TCP 对应的应用层协议？](http://svip.iocoder.cn/Net/Interview/#TCP-对应的应用层协议？)
   3. [TCP 头部是怎么样的？](http://svip.iocoder.cn/Net/Interview/#TCP-头部是怎么样的？)
   4. [【重要】什么是 TCP 三次握手？](http://svip.iocoder.cn/Net/Interview/#【重要】什么是-TCP-三次握手？)
   5. [【重要】什么是 TCP 四次挥手？](http://svip.iocoder.cn/Net/Interview/#【重要】什么是-TCP-四次挥手？)
   6. [【重要】TCP 数据如何传输？](http://svip.iocoder.cn/Net/Interview/#【重要】TCP-数据如何传输？)
   7. [【重要】什么是 TCP 滑动窗口？](http://svip.iocoder.cn/Net/Interview/#【重要】什么是-TCP-滑动窗口？)
   8. [TCP 协议如何来保证传输的可靠性？](http://svip.iocoder.cn/Net/Interview/#TCP-协议如何来保证传输的可靠性？)
   9. [什么是 TCP 拥堵？](http://svip.iocoder.cn/Net/Interview/#什么是-TCP-拥堵？)
5. UDP
   1. [UDP 是什么？](http://svip.iocoder.cn/Net/Interview/#UDP-是什么？)
   2. [UDP 对应的应用层协议？](http://svip.iocoder.cn/Net/Interview/#UDP-对应的应用层协议？)
   3. [【重要】TCP 与 UDP 的区别](http://svip.iocoder.cn/Net/Interview/#【重要】TCP-与-UDP-的区别)
   4. [UDP 报文的格式](http://svip.iocoder.cn/Net/Interview/#UDP-报文的格式)
6. DNS
   1. [DNS 是什么？](http://svip.iocoder.cn/Net/Interview/#DNS-是什么？)
   2. [主机解析域名的顺序？](http://svip.iocoder.cn/Net/Interview/#主机解析域名的顺序？)
   3. [DNS 使用什么协议？](http://svip.iocoder.cn/Net/Interview/#DNS-使用什么协议？)
7. HTTP
   1. [HTTP 是什么？](http://svip.iocoder.cn/Net/Interview/#HTTP-是什么？)
   2. [HTTP 基本格式](http://svip.iocoder.cn/Net/Interview/#HTTP-基本格式)
   3. [HTTP 协议包括哪些请求？](http://svip.iocoder.cn/Net/Interview/#HTTP-协议包括哪些请求？)
   4. [HTTP 有哪些状态码？](http://svip.iocoder.cn/Net/Interview/#HTTP-有哪些状态码？)
   5. [HTTP、TCP、Socket 的关系是什么？](http://svip.iocoder.cn/Net/Interview/#HTTP、TCP、Socket-的关系是什么？)
   6. [Cookies 和 Session 的区别](http://svip.iocoder.cn/Net/Interview/#Cookies-和-Session-的区别)
   7. [【重要】一次完整的 HTTP 请求所经历的步骤](http://svip.iocoder.cn/Net/Interview/#【重要】一次完整的-HTTP-请求所经历的步骤)
   8. [HTTP1.0 和 HTTP1.1 有什么区别？](http://svip.iocoder.cn/Net/Interview/#HTTP1-0-和-HTTP1-1-有什么区别？)
   9. [SPDY 是什么？](http://svip.iocoder.cn/Net/Interview/#SPDY-是什么？)
8. HTTPS
   1. [HTTPS 是什么？](http://svip.iocoder.cn/Net/Interview/#HTTPS-是什么？)
   2. [HTTP 和 HTTPS 的区别？](http://svip.iocoder.cn/Net/Interview/#HTTP-和-HTTPS-的区别？)
   3. [SSL 加密方式是什么？](http://svip.iocoder.cn/Net/Interview/#SSL-加密方式是什么？)
   4. [什么是单向认证、双向认证？](http://svip.iocoder.cn/Net/Interview/#什么是单向认证、双向认证？)
   5. [为什么抓包工具还能抓到 HTTPS 数据包并解密成功呢](http://svip.iocoder.cn/Net/Interview/#为什么抓包工具还能抓到-HTTPS-数据包并解密成功呢)
   6. [HTTPS 握手会影响性能么？](http://svip.iocoder.cn/Net/Interview/#HTTPS-握手会影响性能么？)
9. HTTP2
   1. [什么是 HTTP2.0 ？](http://svip.iocoder.cn/Net/Interview/#什么是-HTTP2-0-？)
   2. [HTTP2.0 和 HTTP1.X 相比的新特性？](http://svip.iocoder.cn/Net/Interview/#HTTP2-0-和-HTTP1-X-相比的新特性？)
   3. [Nginx 怎么做 HTTP2.0 的升级改造？](http://svip.iocoder.cn/Net/Interview/#Nginx-怎么做-HTTP2-0-的升级改造？)
   4. [HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？](http://svip.iocoder.cn/Net/Interview/#HTTP2-0-的多路复用和-HTTP1-X-中的长连接复用有什么区别？)
   5. [服务器推送到底是什么？](http://svip.iocoder.cn/Net/Interview/#服务器推送到底是什么？)
   6. [为什么需要头部(header)压缩？](http://svip.iocoder.cn/Net/Interview/#为什么需要头部-header-压缩？)
10. [彩蛋](http://svip.iocoder.cn/Net/Interview/#彩蛋)

© 2014 - 2020 芋道源码 | 

总访客数 800142 次 && 总访问量 3927608 次

[回到首页](http://svip.iocoder.cn/index)