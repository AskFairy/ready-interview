## Java的类加载机制

### 什么是类的加载

Java天生可以**动态扩展**的语言特性就是依赖**运行期动态加载和动态连接**这个特点实现的

类的加载指的是将类的**.class文件中的二进制数据读入到内存**中，经过**校验、解析、初始化**后将其放在**运行时数据区**的方法区内，然后在**堆**区创建一个`java.lang.Class`对象，用来封装类在方法区内的数据结构。并最终形成可以被虚拟机**直接使用的Java类型**。

![img](http://favorites.ren/assets/images/2017/jvm/jvm-1.png)

- JVM规范允许类加载器**预加载**

### 类的生命周期

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20201002191949.png" alt="image-20201002191947495" style="zoom:50%;" />

- 加载、验证、准备、初始化和卸载这五个阶段的**开始**顺序是确定的
- **解析阶段则不一定**：它在**某些情况下可以在初始化阶段之后再开始**， 这是为了支持Java语言的**运行时绑定特性**（也称为动态绑定或晚期绑定）。

1. 加载：
   1. 通过一个**类的全限定名**来**获取定义此类的二进制字节流**。 （可控性最强：自定义类的加载器）
      - zip包
      - 网络——Web Applt
      - 运行时计算生产——动态代理
      - 其他文件生产——JSP
      - 数据库中读取
      - 加密文件中读取，防Class文件反编译
   2. 将这个字节流所代表的**静态存储结构转化为方法区的运行时数据结构**。 
   3. 在**堆**中生成一个代表这个类的`java.lang.Class`对象，**作为方法区这个类的各种数据的访问入口**。 

**数组类本身不通过类加载器创建**，它**是由Java虚拟机直接在内存中动态构造出来的**。

- 引用类型：**数组类将被标识在加载该组件类型的类加载器的类名称空间上**（这点很重要，在7.4节会介绍，**一个类型必须与类加载器一起确定唯一性**）。
- 如果数组的组件类型**不是引用类型**（例如int[]数组的组件类型为int），Java虚拟机将会**把数组C标记为与引导类加载器关联**。 
- **数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。** 

2. **验证**：加载类的Class文件来源多样。为了**安全**确保被**加载的类的正确性**，在整加载过程中比重最大。

   1. **文件格式**验证

   2. **元数据**验证

   3. **字节码**验证
      - **对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为**。
      - 新增“StackMapTable”新属性。——可能错误、被篡改
   4. **符号引用**验证
      - 最后一个阶段的校验行为**发生在虚拟机将符号引用转化为直接引用的时候**，这个转化动作将在连接的第三阶段——**解析阶段中**发生。
      - 符号引用验证的主要目的是**确保解析行为能正常执行**，如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如： `java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError`等

3. **准备**：**为类的`静态变量分`配内存，并将其初始化为默认值**

   - 在JDK 8及之后，类变量则会随着Class对象一起存放在**Java堆中**
   - 静态变量赋值动作**初始化阶段**才会被执行。
   - 但被final修饰的类变量**准备阶段**就会被赋值。

4. 解析：解析阶段是Java虚拟机**将常量池内的符号引用替换为直接引用的过程**

   - 可访问性
   - 缓存

5. 初始化：初始化，为类的静态变量赋予正确的初始值，即执行构造器<clinit>()方法的过程。

   <clinit>()自动收集**类变量的赋值动作**和**静态语句块**，源文件出现**顺序**、**父类 > 子类**、**接口**的**不**需要先执行父类、加锁=多线程等待。

   初始化6种情况：

   1. new
   2. **读取或设置一个类型的静态字段**（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候
      - **调用父类的静态字段**，只会初始化其父类，不会初始化子类
      - 通过数组定义来引用类，不会触发此类的初始化`SuperClass[] sca = new SuperClass[10];`
      - **常量**在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，**因此不会触发定义常量的类的初始化**
        - 这两个类在编译成 Class文件后就已不存在任何联系了。
   3. 调用类的静态方法
   4. 反射
   5. 父类先初始化
   6. main主类
   7. 类实现接口的默认方法之前，接口先初始化

   接口区别：

   1. 接口不能使用static{}
   2. **只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化**。

6. **结束生命周期**：

   - 执行了`System.exit()`方法
   - 程序**正常**执行结束
   - **程序**在执行过程中遇到了异常或**错误而异常**终止
   - 由于**操作系统出现错误**而导致Java虚拟机进程终止









