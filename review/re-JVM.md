## Java的类加载机制

### 什么是类的加载

Java天生可以**动态扩展**的语言特性就是依赖**运行期动态加载和动态连接**这个特点实现的

类的加载指的是将类的**.class文件中的二进制数据读入到内存**中，经过**校验、解析、初始化**后将其放在**运行时数据区**的方法区内，然后在**堆**区创建一个`java.lang.Class`对象，用来封装类在方法区内的数据结构。并最终形成可以被虚拟机**直接使用的Java类型**。

![img](http://favorites.ren/assets/images/2017/jvm/jvm-1.png)

- JVM规范允许类加载器**预加载**

### 类的生命周期

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20201002191949.png" alt="image-20201002191947495" style="zoom:50%;" />

- 加载、验证、准备、初始化和卸载这五个阶段的**开始**顺序是确定的
- **解析阶段则不一定**：它在**某些情况下可以在初始化阶段之后再开始**， 这是为了支持Java语言的**运行时绑定特性**（也称为动态绑定或晚期绑定）。

1. 加载：
   1. 通过一个**类的全限定名**来**获取定义此类的二进制字节流**。 （可控性最强：自定义类的加载器）
      - zip包
      - 网络——Web Applt
      - 运行时计算生产——动态代理
      - 其他文件生产——JSP
      - 数据库中读取
      - 加密文件中读取，防Class文件反编译
   2. 将这个字节流所代表的**静态存储结构转化为方法区的运行时数据结构**。 
   3. 在**堆**中生成一个代表这个类的`java.lang.Class`对象，**作为方法区这个类的各种数据的访问入口**。 

**数组类本身不通过类加载器创建**，它**是由Java虚拟机直接在内存中动态构造出来的**。

- 引用类型：**数组类将被标识在加载该组件类型的类加载器的类名称空间上**（这点很重要，在7.4节会介绍，**一个类型必须与类加载器一起确定唯一性**）。
- 如果数组的组件类型**不是引用类型**（例如int[]数组的组件类型为int），Java虚拟机将会**把数组C标记为与引导类加载器关联**。 
- **数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。** 

2. **验证**：加载类的Class文件来源多样。为了**安全**确保被**加载的类的正确性**，在整加载过程中比重最大。
   1. **文件格式**验证

   2. **元数据**验证

   3. **字节码**验证
      - **对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为**。
      - 新增“StackMapTable”新属性。——可能错误、被篡改
   4. **符号引用**验证
      - 最后一个阶段的校验行为**发生在虚拟机将符号引用转化为直接引用的时候**，这个转化动作将在连接的第三阶段——**解析阶段中**发生。
      - 符号引用验证的主要目的是**确保解析行为能正常执行**，如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如： `java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError`等
3. **准备**：**为类的`静态变量分`配内存，并将其初始化为默认值**
   - 在JDK 8及之后，类变量则会随着Class对象一起存放在**Java堆中**
   - 静态变量赋值动作**初始化阶段**才会被执行。
   - 但被final修饰的类变量**准备阶段**就会被赋值。
4. 解析：解析阶段是Java虚拟机**将常量池内的符号引用替换为直接引用的过程**
   - 可访问性
   - 缓存
5. 初始化：









