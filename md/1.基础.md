# 基础

## 精通

### Java8新特性？

为解决之前修改`接口`或者添加接口时候，需要修该接口全部实现类的这一问题，引进了`默认方法`，也就是定义接口时可以提供默认的实现。

增加了，只有一个抽象方法的`函数式接口`，（方便JVM进行类型推断，并找到对应方法）。以此为基础引入增加了`Lambda` 表达式来简化开发。

并且`内置`了很多函数式接口。

以及用来包装对象，防止空指针异常的Optionals

内置函数(断言、Function、生产者、消费者)

Stream流
		Map集合特性
		日期
		注解

#### 函数式接口？

1. 一个函数式接口有且只有一个抽象方法。
2. 默认方法不是抽象方法，因为它们已经实现了。
3. 重写了超类Object类中任意一个public方法的方法并不算接口中的抽象方法。

#### 什么是Lambda表达式？什么是 ()->{ }？

就是写了一个匿名实现，本质上是一种延迟加载执行。将预先写好的实现方法进行加载。到实际使用时，再执行。

#### 四饼调用？

可以引用方法,构造行数,和普通方法（把函数式接口中的抽象方法替换成把对象中的一个方法，用函数接口去调用）

- 对函数式接口的默认实现

  ```java
  IConverter<Integer,String> converter04 = String::valueOf;
  <参数,返回值>  = 被替换的对象::被替换的方法
  ```

  

- 引用普通方法,引用里面的方法体里面逻辑

  ```java
  IConverter<String, String> converter01 = s -> String.valueOf(s.charAt(0)); //[参照物]直接把逻辑放到这调用
  IConverter<String, String> converter02 = something::startsWith;            //引用的方法体里面逻辑可以更多，否则只是一句代码并不能适合所有的情况
  System.out.println(converter01.convert("Java"));
  System.out.println(converter02.convert("Java"));
  ```

- 引用类的构造器

  ```java
  IPersonFactory<Person> personFactory = Person::new;  
  //[参照物]：(firstName, lastName) -> new Person(firstName, lastName); 返回对象::推断构造方法
  Person person = personFactory.create("Peter", "Parker");
  ```

#### Lambda作用范围？

Lambda表达式访问外部的变量(局部变量，成员变量，静态变量，接口的默认方法),它与匿名内部类访问外部变量非常相似。

访问局部变量:

​	但这个局部变量得是不可变值.也就是说:lambda表达式内部不允许修改,表达式之后,值不能改变。

​	是因为其实修改的是内部类对象所持有的final对象（不用显式的用final修饰）。你可以通过定义一个相同类型的变量b，然后将该外部变量赋值给b，匿名内部类引用b就行了，然后就可以继续修改外部变量。	

```
注：

- 在jdk7之前，匿名内部类访问外部类的局部变量时，那么这个局部变量必须用final修饰符修饰。jdk8则不需要，但是我们在使用这个局部变量时，无法改变局部变量的值，否则编译会报错。

为什么要求是final类的呢？
	因为在java设计之初为了保护数据的一致性而规定的。对引用变量来说是引用地址的一致性，对基本类型来说就是值的一致性。
```

访问成员变量和静态变量:

​	与局部变量相比，在 Lambda 表达式中对成员变量和静态变量拥有读写权限。，

#### 内置函数式接口都有哪些？

Jdk中常用的 Comparator 和 Runnable 外

Predicate断言： 是一个可以指定入参类型，并返回 boolean 值的函数式接口。它内部提供了一些带有默认实现的方法，可以 被用来组合一个复杂的逻辑判断（and, or, negate）

Function 功能链 ：函数式接口的作用是，我们可以为其提供一个原料，他给生产一个最终的产品。通过它提供的默认方法，组合,链行处理(compose, andThen)：

Supplier生产者： 与 Function 不同，它不接受入参，直接为我们生产一个指定的结果，有点像生产者模式：（就是一个空的函数式接口，方便调用其他对象中的不传参方法）

Consumer 消费者：于 Consumer，我们需要提供入参，用来被消费（就是一个空的函数式接口，方便调用其他对象中的传参方法）

Comparator比较器： 在 Java 8 之前是使用比较普遍的。Java 8 中除了将其升级成了函数式接口，还为它拓展了一些默认方法：

#### 什么是Stream 流？都有哪些操作？

对实现Collection 接口的元素做流的操作，支持同步执行，也支持并发执行。

包含：

- Filter 过滤
-  Sorted 排序
-  Map 转换：中间操作映射通过给定的函数将每个元素转换为另一个对象（替换对象对象或者属性）
- Match 匹配：匹配操作，返回Boolean型，部分存在，全部存在，没有匹配 三种情况
- Count 计数
- Reduce:合并，我们能够将 list 归约成一个值。它的返回类型是 Optional 类型。

并行：就是将 stream 换成 parallelStream

#### Map 集合

Map是不支持 Stream 流的，但是，我们可以对其 key, values, entry 使用 流操作，如 map.keySet().stream(), map.values().stream() 和 map.entrySet().stream().

```java
// 会判断 key 是否已经存在，存在则直接返回 value, 否则 put, 再返回 value
 map.putIfAbsent(i, "val" + i);
// forEach 可以很方便地对 map 进行遍历操作
map.forEach((key, value) -> System.out.println(value));


	// 如下：对 key 为 3 的值，内部会先判断值是否存在，存在，则做 value + key 的拼接操作
	map.computeIfPresent(3, (num, val) -> val + num);
	map.get(3);             // val33
	// 先判断 key 为 9 的元素是否存在，存在，则做删除操作
	map.computeIfPresent(9, (num, val) -> null);
	map.containsKey(9);     // false


	// computeIfAbsent(), 当 key 不存在时，才会做相关处理
	// 如下：先判断 key 为 23 的元素是否存在，不存在，则添加
	map.computeIfAbsent(23, num -> "val" + num);
	map.containsKey(23);    // true
	// 先判断 key 为 3 的元素是否存在，存在，则不做任何处理
	map.computeIfAbsent(3, num -> "bam");
	map.get(3);             // val33

	//JDK 8 中提供了能够新的 remove() API:只有当给定的 key 和 value 完全匹配时，才会执行删除操作  
	map.remove(3, "val3");
	map.get(3);             // val33

	map.remove(3, "val33");
	map.get(3);             // null

	//提供了带有默认值的 getOrDefault() 方法
	map.getOrDefault(42, "not found");  // not found

	//对于 value 的合并操作也变得更加简单：(这不就是三元运算符嘛，判断key是否存在？x ：  Y)
	// merge 方法，会先判断进行合并的 key 是否存在，不存在，则会添加元素
    map.merge(9, "val9", (value, newValue) -> value.concat(newValue));
    map.get(9);             // val9
    // 若 key 的元素存在，则对 value 执行拼接操作
    map.merge(9, "concat", (value, newValue) -> value.concat(newValue));
    map.get(9);             // val9concat
```

#### 日期 Date API

1. Clock:我们可以利用它来替代 System.currentTimeMillis() 方法。另外，通过 clock.instant() 能够获取一个 instant 实例，此实例能够方便地转换成老版本中的 java.util.Date 对象。

   ```java
   @Test
   public void test31(){
       Clock clock = Clock.systemDefaultZone();
       long millis = clock.millis();
       Instant instant = clock.instant();
       Date legacyDate = Date.from(instant);   // 老版本 java.util.Date
   }
   ```

2. Timezones 时区

3. LocalTime

4. LocalDate

5. LocalDateTime 

#### Annotations 注解

Java8中的注释是可重复的。{在SpringBoot的启动类中就可以看到这中类型的注解}



### 重载和重写的区别（位置、时间）

重载和重写都是面向对象四大特征中**多态**的一种体现。只是发生的时期和发生的位置不同。

重载：在同一类中，发生在编译期，编译期不关注调用时的返回值，只根据参数的类型以及数量确定调用哪个方法。所以除方法名外，返回类型，访问修饰符，抛出的异常都可以不同。

重写：在父子类中，发生在运行期，编译时编译器无法知道调用的是子类的还是父类的方法，运行是才知道具体调用方法。方法名、参数类型、返回值相同都得相同。并且子类方法不能缩小父类方法的访问权限，子类方法不能抛出比父类方法更多的异常，不能重新父类中私有的、或用final修饰的方法，必选重新抽象方法。

### == 、hashcode 和 equals (比较、可靠、效率)

== 、hashcode 和 equals 三者都是用来比较的。

== 用来比较值类型的内存地址，hashCode和equals 用来对比两个对象是否相等的。对于对象来说，如果不重写equals 方法，本质上用的还是==，也就是比较内存地址。

如果想用对象属性自定义比较，就得重写equals 方法了。equals 方法虽然可靠，但效率比较低。而利用hashCode()进行对比，也就是生成一个hash值，进行比较效率就高很多，但是hash值并不可靠，可能会产生hash冲突，也就是说不同的对象生成的hash值一样。

所以一般对比对象的解决方式是，首先用hashCode()去对比，再利用equals 兜底验证。HashMap对比Key就是这么干的，云用逻辑运算符的短路性质，先对hash值，与上  （内存地址 或 equals ）。

### 8种基本类型

byte、1byte等于8bit。

boolean、1byte, 只有 0,1

short、2byte

char、2byte  范围 0~2^16-1

int、4byte，范围是-2^31~2^31

float 4byte   单精度浮点数有效数字8位   -2^128~+2^128

double、8byte 双精度浮点数有效数字16位  -2^1024~+2^1024

long、8byte  

范围是由指数的位数来决定的，float指数8，double指数11

公式：（浮点）数值 =    （符号位）尾数   ×   底数 ^ 指数



#### char 型变量中能不能存贮一个中文汉字？为什么？

看在什么语言了，汉字在Unicode编码下占两个字节，C语言char型只有一个字节不能存储。Java占两个字节可以存储。

### 字符串（String）

#### String、StringBuffer、StringBuilder 

三者都可以都存储操作字符串，底层都是用char[]数组

只是String的数组用final修饰，每次修改每次修改，会生成新的字符串，并将指针指向新的String对象，适合操作少量数组。

用在字符串缓冲区被单个线程使用的时候，用StringBuilder ，但它不是线程安全的。

如果在多线程操作多线程操作字符串缓冲区，用StringBuffer，它被synchronized 修饰线程安全。

#### String s = new String("xyz") 会创建几个对象？

看见首先在 string 池内找，找到？不创建 string 对象，否则创建一个对象。

遇到 new 运算符号了，在内存堆上创建 string 对象，并将其返回给 s，又一个对象。

所以说可能是2两个，也可能是一个。

- 注：

  1. Strings1="hello"   
     先去字符串常量池找，没有去堆中创建，然后注册到字符串常量池中。
  2. Strings2=newString("hello");
     当我们使用new关键字创建字符串对象的时候, JVM将不会查询字符串常量池, 它将会直接在堆内存中创建一个字符串对象, 并返回给所属变量。
  3. 当调用 intern()方法时, 首先会去常量池中查找是否有该字符串对应的引用, 如果有就直接返回该字符串; 如果没有, 就会在常量池中注册该字符串的引用, 然后返回该字符串。
4. 结果为false!

  ![从底层彻底搞懂String，StringBuilder，StringBuffer的实现](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2ViZmVlMjZlZGRlMTQ4MzRiMGQ0MDQzZjU2YzJlMDYx)

### final、finally、finalize?

  final是修饰符关键字，修饰变量时必须声明时给定初始值，并且不能修改读取。修饰方法时，只能使用，不能重写。修饰类不能被继承。
  finally一般在异常处理时在catch之后做清除操作。`有些时候finally块不会被执行，在 finally 语句块中发生了异常，在前面的代码中用了 System.exit() 退出程序，程序所在的线程死亡被Kill，关闭 CPU 或者 停电。`

  finalize是Object里的抽象方法，垃圾收集器删除对象之前会调用这个方法，所以一般子类覆盖 finalize() 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。

### 深拷贝（深克隆）、浅拷贝（浅克隆）？

浅拷贝（shallowCopy），浅度克隆对于要克隆的对象，对于其基本数据类型的属性，复制一份给新产生的对象，对于非基本数据类型的属性，仅仅复制一份引用给新产生的对象，即新产生的对象和原始对象中的非基本数据类型的属性都指向的是同一个对象。
	   深拷贝（deepCopy），在浅度克隆的基础上，这样对于非基本数据类型的属性，复制的不是一份引用，即新产生了一个对象，和原始对象中的非基本数据类型的属性指向的不是同一个对象

两者最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。

一般有两种方式，重写 Object 类中的 #clone() 方法来实现深克隆或者浅克隆。另一种是实现 Serializable 接口，也就是通过对象的序列化和反序列化实现深克隆，常用于微服务的的数据传输。

### 值传递和引用传递?

​	值传递，一般是对基本型变量而言，传递的是该变量的一个副本，就是`变量的拷贝`，改变副本不影响原变量。
​			引用传递，是对于对象型变量而言的，传递的是该`对象地址（引用）`的一个`副本`，并不是原对象本身。浅拷贝就是这种情况。

### 自动拆装箱

​	自动装箱和拆箱，就是`基本类型和引用类型之间的转换`。

为了解决

- 一个`函数`需要传递一个Object变量、

- 原始数据类型和 Java `泛型`并不能配合使用

- 解决之前JDK中不能直接地向`集合`( Collection )中放入原始类型值的问题

  总之为了让代码简练

  注：int是基本数据类型，Integer 是int包装类，也就是一个对象。

### Object有哪些方法？

- 返回当前类信息的getClass方法，一般用来反射。
- 用来对象对比的equals方法
- 和一般用来和equals方法配合使用的用来获取hash值的hashCode方法。
- 用来clone对象的clone方法。
- 将对象用字符串表示的toString方法。
- 用来线程间通信的wait()、notify()、notifyAll()方法。
  - 让线程进入阻塞状态的wait()方法
  - 用来唤醒该对象监视器的一个等待线程的notify()
  - 以及用来唤醒全部等待线程的notifyAll()方法。
- 以及垃圾收集器删除对象之前会调用的finalize() 方法，可以用了对象的自救。

### 类的实例化顺序？

先静态后非静，先父后子的顺序。

先加载父类静态变量，父类静态代码块，子类静态变量，子类静态代码块。

后加载父类非静态变量，父类构造函数，子类非静态变量，子类构造函数。



`注：类属性初始化时虚拟机是不会声明属性的同时赋值的，它会把所有属性和方法全部声明完了再从头按代码顺序赋值。`

`静态属性是在类被加载之后就放进静态存储区的,而非静态属性需要类被实例化之后才被创建`

#### 为什么先加载父类再加载子类？

​	父类都没有初始化，子类随时会用到父类中的东西啊，比如子类构造时需要调用父类的一些方法获取一些东西什么的，父类如果都没有构造的话，那不是一堆null。

### 什么是内部类？

就是在一个类、接口或者方法的内部创建另一个类。

每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响，并且一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。相当于变相解决的多重继承问题。

主要分为：作为外部类的一个成员存在，与外部类的属性、方法并列的`成员内部类`。

在方法中定义的内部类称为`局部内部类`。

如果你不需要内部类对象与其外围类对象之间有联系，那你可以将内部类声明为static，称为`静态内部类`。

`匿名内部类`就是没有名字的内部类：在jdk7之前，匿名内部类访问外部类的局部变量时，那么这个局部变量必须用final修饰符修饰。1.8虽然不需要用程序员final修饰，但是java已经帮我们隐的声明我们在使用这个局部变量时，无法改变局部变量的值，否则编译会报错，当然你也可以通过定义一个相同类型的变量b，然后将该外部变量赋值给b，匿名内部类引用b就行了，然后就可以继续修改外部变量。

### 对象的生命周期？JVM怎么判断长生命周期?

### Java IO？

### 反射

### 代理

### 泛型

### 二进制

### 异常

## 熟悉

### String、Integer、Object的hashcode()方法

String: h = h * 31 + val[i]

Integer: 就是值

Object：通过将该对象的内部地址转换成一个整数来实现的

#### hashCode()的计算逻辑中，为什么是31作为乘数?

31是个奇数，如果选择偶数会导致乘积运算时数据溢出。

JVM虚拟机会自动支持对乘积运算使用`位移`优化以提升性能。`也就是说31 乘 i 等于 (i 左移 5 位)后 减 i（31 * i == (i << 5) - i）`

31当乘数碰撞概率很小基本稳定，太大可能导致int型存不下，以至于信息丢失

### 抽象类和接口有什么区别？

接口是对行为的抽象，从多种类似的对象中提取共同行为的总结，是一种行为的规范。

抽象是对类的抽象，抽象出的一种需要实现特定功能的模板。

接口中所有的方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。
	   类可以实现很多个接口，但是只能继承一个抽象类
		Java 接口中声明的变量默认都是 final 的。成员函数默认是 public 的。

### 对象创建方式？

​	四种创建方式：

- 使用 `new 关键字`创建对象	
- 运用java的`反射`机制，使用 Class 类的 `newInstance 方法`或者使用 Constructor 类的 newInstance 方法。
- 使用 `clone 方法`创建对象
- 使用(反)`序列化机制`创建对象

### Java中的关键字

- transient：将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。
- native：因为JAVA无法对操作系统底层进行操作，所以需要其他语言进行底层操作，一个native方法是指该方法的实现由非Java语言实现，比如用C或C++实现。

### 构造方法

每个类都有构造方法，新对象被创建的时候，构造方法会被调用，一般用来做一些初始化的操作。构造方法可以像普通方法一样被重载。构造方法不能能被继承，所以不能重写。

注：Java 不支持像 C++ 中那样的拷贝构造方法
		

## 了解

### 继承和组合的区别在哪？

继承是类与类或者接口与接口之间最常见的关系，指的是一个类，继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，在 Java 中，此类关系通过关键字 extends 明确标识。

组合是关联关系的一种特例，体现的是整体与部分、拥有的关系，即 has-a 的关系。

### charAt(index)与toCharArray()

charAt()直接通过chr[]数组下标获取字符，不会有额外的堆内存使用。

toCharArray的调用会在堆中创建新字符数组，用通过System.arrayCopy把value字符数组都copy进去，再返回。

### 说一下Runtime类？

可以获取一些`系统级别的参数`，比如核数、内存使用情况等。比如`抢占式线程池`默认就是用Runtime类获取JVM的可用处理器数，当并行度的。

还可以用来为JVM的添加`钩子线程`（一个线程可以注入多个钩子），当jvm进程退出的时候或者受到了系统的`中断信号`，做一下释放资源类的操作。或者创建`lock文件`，防止程序被重复启动。
		注：如果没有收到中断信号，就不会执行hook，导致.lock不能删除。比如kill -9命令。

### (待确定)字符串常量池底层是用HashTable实现的？

### 不可变类

![image-20200908124656320](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200908124658.png)

### StringTokenizer 是什么

分割字符串的工具类

### 接口数量不能超过65535的问题？

是和Class类文件的结构中的接口计数器有关，Class文件是一组以8字节为基础单位的二进制流，接口索引计数器(interfaces_count)，占2字节。最大就是2^16-1=65535。超过65535接口就存不下了，所以动态代理中要求目标类实现的接口数量不能超过65535。

### this的三种用法？

- `表示对当前对象的引用`：在当前对象中可以使用this关键字指代当前对象

  ![image-20200911104537632](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911104539.png)

- `表示类的成员变量`：在函数参数和成员变量同名是进行区分

  ![image-20200911104627146](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911104628.png)

- `指定构造器：`用于在构造方法中引用满足指定参数类型的构造器

  ![image-20200911104704179](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911104705.png)

### 断言

断言是一个包含布尔表达式的语句，是在开发和测试时，保证程序最基本的正确性。一般用在单元测试中。

在软件发布后断言检查通常是关闭的

- 运行时启用断言
  				在启动 JVM 时使用 -enableassertions 或者 -ea 标记
- 运行时禁用断言
  				在启动 JVM 时使用 -da 或者 -disableassertions 标记
  				要在系统类中启用或禁用断言，可使用 -esa 或 -dsa 标记
  				还可以在包的基础上启用或者禁用断言

  