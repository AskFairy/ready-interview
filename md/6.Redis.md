

# 缓存

## 什么是缓存？

缓存，就是**数据交换的缓冲区**，目的是，**把读写速度【慢】的介质的数据保存在读写速度【快】的介质中，从而提高读写速度，减少时间消耗**。

## 为什么要用缓存？

为了提升**读性能**，带来更好的性能，**更高的并发量**。

日常业务中，我们使用比较多的数据库是 MySQL ，缓存是 Redis 。一起来看看，阿里云提供的性能规格：

- Redis 性能规格，https://help.aliyun.com/document_detail/26350.html 。打底 8W QPS （每秒查询率），最高可达千万 QPS 。
- MySQL 性能规格 https://help.aliyun.com/document_detail/53637.html 。打底 1.4K QPS ，最高 7W QPS 。

将 MySQL 的**热点数据**，缓存到 Redis 中，提升读取性能，也减小 MySQL 的读取压力。

## 请说说有哪些缓存算法？是否能手写一下 LRU 代码的实现？

🦅 **缓存算法**

缓存算法，比较常见的是三种：

- LRU（least recently used ，最近最少使用)
  - 踢走最近最少使用的对象
- LFU（Least Frequently used ，最不经常使用)
  - 踢走不经常使用的对象
- FIFO（first in first out ，先进先出)

完整的话，胖友可以看看 [《缓存、缓存算法和缓存框架简介》](http://blog.jobbole.com/30940/) 的 [「缓存算法」](http://svip.iocoder.cn/Cache/Interview/#) 部分。

🦅 **手写 LRU 代码的实现**

## 常见的常见的缓存工具和框架有哪些？

在 Java 后端开发中，常见的缓存工具和框架列举如下：

- 本地缓存：`Guava LocalCache`、`Ehcache`、`Caffeine` 。
  - Ehcache 的功能更加丰富，Caffeine 的性能要比 Guava LocalCache 好。
- 分布式缓存：`Redis`、`Memcached`、`Tair（淘宝）` 。
  - Redis 最为主流和常用。

## 用了缓存之后，有哪些常见问题？

常见的问题，可列举如下：

- 写入问题
  - 缓存何时**写入**？并且写时如何避免并发重复写入？
  - 缓存如何**失效**？
  - 缓存和 DB 的**一致性**如何保证？
- 经典三连问
  - 如何避免缓存**穿透**的问题？
  - 如何避免缓存**击穿**的问题？
  - 如果避免缓存**雪崩**的问题？

## 当查询缓存报错，怎么提高可用性？

缓存可以极大的提高查询性能，但是缓存数据丢失和缓存不可用不能影响应用的正常工作。

因此，一般情况下，如果缓存出现异常，需要**手动捕获异常，并且记录日志**，并且**从数据库查询数据**返回给用户，而不应该导致业务不可用。

当然，这样做可能会带来缓存雪崩的问题。具体怎么解决，可以看看本文 [「如何避免缓存”雪崩”的问题？」](http://svip.iocoder.cn/Cache/Interview/#) 问题。

## 如果避免缓存”穿透”的问题？

🦅 **缓存穿透**

- **缓存穿透**，指的是查询一个**不存在**的数据，致使每次请求都要到 **DB** 去查询。

🦅 **如何解决**

有两种方案可以解决：

1）方案一，缓存空对象、**特殊的标识**与正常区分、过期时间（<5min）

2）方案二，`BloomFilter` 布隆过滤器。

- **判断对应的 KEY 是否存在**
-  **存在误判**、 **不允许删除**

🦅 **选择**

这两个方案，各有其优缺点。

|          | 缓存空对象                                          | BloomFilter 布隆过滤器                        |
| :------- | :-------------------------------------------------- | :-------------------------------------------- |
| 适用场景 | 1、数据命中不高 2、保证一致性                       | 1、数据命中不高 2、**数据相对固定、实时性低** |
| 维护成本 | 1、代码维护简单 2、需要过多的缓存空间 3、数据不一致 | 1、**代码维护复杂** 2、**缓存空间占用小**     |

### 布隆过滤器

## 如何避免缓存”雪崩”的问题？

🦅 **缓存雪崩**

缓存雪崩，是指缓存由于某些原因无法提供服务( 例如，**缓存挂掉**了 )，**所有请求全部达到 DB** 中，导致 DB 负荷大增，最终挂掉的情况。

🦅 **如何解决**

预防和解决缓存雪崩的问题，可以从以下**多个方面进行共同着手**。

1）**缓存高可用**

2）**本地缓存**

当然，引入本地缓存也会有相应的问题，例如说：

- **本地缓存的实时性**怎么保证？
  - 方案一，可以引入**消息队列**。在数据更新时，发布数据更新的消息；而进程中有相应的消费者消费该消息，从而更新本地缓存。
  - 方案二，设置**较短的过期时间**，请求时从 DB 重新拉取。
  - 方案三，使用 [「如果避免缓存”击穿”的问题？」](http://svip.iocoder.cn/Cache/Interview/#) 问题的【方案二】，**手动过期**。
- 每个进程可能会本地缓存相同的数据，**导致数据浪费**？
  - 方案一，需要**配置本地缓存的过期策略和缓存数量上限**。

如果我们使用 JVM ，则可以使用 Ehcache、Guava Cache 实现本地缓存的功能。

3）**请求 DB 限流**

​	**服务降级**

如果我们使用 Java ，则可以使用 `Guava RateLimiter`、`Sentinel`、`Hystrix` 实现限流的功能。

4）**提前演练**

## 如果避免缓存”击穿”的问题？

🦅 **缓存击穿**

缓存击穿，是指某个**极度“热点”**数据在某个时间点**过期**时，恰好在这个时间点对这个 **KEY** 有**大量的并发**请求过来，这些请求发现缓存过期一般都会**从 DB 加载数据**并回设到缓存，但是这个时候大并发的请求可能会瞬间 DB 压垮。

- 区别：
  - 和缓存**“雪崩“”**的区别在于，前者针对某一 KEY 缓存，后者则是**很多 KEY** 。
  - 和缓存**“穿透“”的区别**在于，这个 **KEY 是真实存在对应的值**的。

🦅 **如何解决**

有两种方案可以解决：

1）方案一，**使用互斥锁**。

请求发现缓存不存在后，去查询 DB 前，使用**分布式锁**，保证有且只有一个线程去查询 DB ，并更新到缓存。

2）方案二，**手动过期，牺牲时效性**。将过期时间存在 KEY 对应的 VALUE 里。即使过期，也直接返回。异步线程构建缓存。

🦅 **选择**

这两个方案，各有其优缺点。

|      | 使用互斥锁                          | 手动过期                  |
| :--- | :---------------------------------- | :------------------------ |
| 优点 | 1、思路简单 2、保证一致性           | 1、性价最佳，用户无需等待 |
| 缺点 | 1、代码复杂度增大 2、存在死锁的风险 | 1、无法保证缓存一致性     |

具体使用哪一种方案，胖友可以根据自己的业务场景去做选择。

- 有一点要注意，上述的两个方案，都是建立在**极度“热点”**数据存在的情况，所以实际场景下，需要**结合避免缓存”穿透”的方案**，一起使用。

## 缓存和 DB 的一致性如何保证？

🦅 **产生原因**

主要有两种情况，会导致缓存和 DB 的一致性问题：

1. **并发**的场景下，导致**读取老的 DB 数据，更新到缓存中**。
- 更新 DB 数据之前，先删除 Cache 的数据产生的问题。
   - 并且使用**被动读**。即不存在查询写入。
2. **缓存和 DB 的操作，不在一个事务中**，可能只有一个 DB 操作成功，而另一个 Cache 操作失败，导致不一致。

当然，有一点我们要注意，缓存和 DB 的一致性，我们指的更多的是**最终一致性**。

🦅 **解决方案**

下面，我们就来看看几种方案。当然无论哪种方案，比较重要的就是解决两个问题：

- 1、将缓存可能存在的并行写，实现**串行写**。

- 2、实现数据的**最终一致性**。

1）**先淘汰缓存，再写数据库**，并且引入**分布式锁**，实现串行锁。

2）**先写数据库，再更新缓存**。

按照“先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够**在“同一个事务”中**，从而**实现最终一致性**。

**基于定时任务来实现**，事物（写DB，写任务表），**定时任务每秒扫描任务表**，更新。

**基于消息队列来实现**，事物（写DB，发送事物消息），消费更新。

这两种方式，可以进一步优化，可以先尝试更新缓存，如果失败，则插入任务表，或者事务消息。

另外，极端情况下，如果**并发写执行时**，先更新成功 DB 的，结果后更新缓存。

- 理论来说，希望的更新缓存顺序是，线程 1 快于线程 2 ，但是实际线程1 晚于线程 2 ，导致数据不一致。
- 可能胖友会说，图中不是基于定时任务或消息队列来实现异步更新缓存啊？答案是一直的，如果网络抖动，导致【插入任务表，或者事务消息】的顺序不一致。
- 需要做如下三件事情：
  - 1、在**缓存值中，拼接上数据版本号或者时间戳**。例如说：`value = {value: 原值, version: xxx}` 。
  - 2、在**任务表的记录，或者事务消息中**，增加上**数据版本号**或者**时间戳**的字段。
  - 3、在定时任务或消息队列执行更新缓存时，先读取缓存，**对比版本号或时间戳，大于才进行更新**。当然，此处也会有并发问题，所以还是得引入**分布式锁**或 **CAS 操作**。

3）**基于数据库的 binlog 日志**

[![binlog 方案](http://static.iocoder.cn/f434927790ae53b4fa955ecd9952f787)](http://static.iocoder.cn/f434927790ae53b4fa955ecd9952f787)binlog 方案

- 应用直接写数据到数据库中。
- 数据库更新binlog日志。
- 利用**Canal中间件读取binlog日志**。
- Canal借助于限流组件按频率将数据发到MQ中。
- 应用监控MQ通道，将MQ的数据更新到Redis缓存中。

可以看到这种方案对研发人员来说比较轻量，不用关心缓存层面，而且这个方案虽然比较重，但是却容易形成统一的解决方案。

------

当然，以上种种方案，各有其复杂性，如果胖友心里没底，还是仅仅使用如下任一方案：

- “**先淘汰缓存，再写数据库**”的方案设定超时时间30min，并且无需引入分布式锁。

- “**先写数据库，再更新缓存**”的方案，并且无需引入定时任务或者消息队列。


另外，在 DB 主从架构下，方案会更加复杂。详细可以看看 [《主从 DB 与 cache 一致性优化》](https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-master-and-slave-database.html) 。

## 什么是缓存预热？如何实现缓存预热？

🦅 **缓存预热**

依靠用户请求的方式重建缓存数据，那么对数据库的压力非常大，而且系统的性能开销也是巨大的。最好的策略是启动时就把热点数据加载好。

🦅 **如何实现**

一般来说，有如下几种方式来实现：

1. 数据量不大时，**项目启动时，自动进行初始化**。
2. 写个**修复数据脚本**，手动执行该脚本。
3. 写个**管理界面，可以手动点击，预热对应的数据到缓存中**。

## 缓存数据的淘汰策略有哪些？

除了缓存服务器自带的缓存**自动**失效策略之外，我们还可以根据具体的业务需求进行自定义的**“手动”**缓存淘汰，常见的策略有两种：

- 1、定时去清理过期的缓存。
- 2、当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。

两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！
具体用哪种方案，大家可以根据自己的应用场景来权衡。

## 缓存如何存储 POJO 对象？

实际场景下，缓存值可能是一个 POJO 对象，就需要考虑如何 POJO 对象存储的问题。目前有两种方式：

- 方案一，将 POJO 对象

  序列化

  进行存储，适合 Redis 和 Memcached 。

  - 可参考 [《Redis 序列化方式StringRedisSerializer、FastJsonRedisSerializer 和 KryoRedisSerializer》](https://blog.csdn.net/xiaolyuh123/article/details/78682200) 文章。
  - 对于 POJO 对象比较大，可以考虑使用压缩算法，例如说 Snappy、zlib、GZip 等等。

- 方案二，使用 **Hash 数据结构**，适合 Redis 。

  - 可参考 [《Redis 之序列化 POJO》](https://my.oschina.net/yuyidi/blog/499951) 文章。
