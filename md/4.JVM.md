# JVM

## 精通

### （待整理）内存区域

线程到底在私有区域在干什么？哪些是在栈中的？概述

### （新）如何确定垃圾？

引用计数法

在为对象添加一个引用时，引用计数加 1；在为对象删除一个引用时，引进计数减1；如果一个对象的引用计数为 0，则表示此刻该对象没有被引用，可以被回收。

容易产生循环引用的问题，即互为引用，引用计数一直为1。

![image-20200910215537317](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910215539.png)

![image-20200911165721598](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911165730.png)

可达性分析通过根搜索算法（GC Roots Tracing）来实现。

首先定义GC Roots对象，以GC Roots对象作为起点根据引用关系向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡，但不可达对象要经过至少两次标记才能判定其是否可以被回收。

根搜索算法主要针对栈中的引用、方法区中的静态引用和JNI中的引用展开分析。

#### Java中哪些是GC Root是对象？

在Java技术体系里面，固定可作为 GC Roots的对象包括以下几种：

- 在虚拟机栈（`栈帧中的本地变量表`）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的`参数、局部变量、临时变量`等。

- 在`方法区中类静态属性引用的对象`，譬如Java类的`引用类型静态变量`。

- 在`方法区中常量引用的对象`，譬如`字符串常量池`（ String Table）里的引用。

- 在本地方法栈中JNⅠ（即通常所说的 Native方法）引用的对象。

- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些`常驻的异常对象`（比如NullPointExcepiton、 OutOfMemoryError）等，还有`系统类加载器`。

- 所有`被同步锁`（ synchronized关键字）`持有的对象`

- 反映Java虚拟机内部情况的JMⅹBean、JMTI中注册的回调、本地代码缓存等。

  除了这些固定的 GC Roots集合以外，根据`用户所选用的垃圾收集器以及当前回收的内存区域不同`，还可以有其他对象“`临时性`”地加入，共同构成完整 GC Roots集合。

  譬如后文将会提到的分代收集和局部回收（ Partial gc），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到`内存区域`是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更`不是孤立封闭`的，所以`某个区域里的对象完全有可能被位于堆中其他区域的对象所引用`，这时候就需要将这些关联区域的对象也一并加GC Roots集合中去，才能保证可达性分析的正确性

  目前最新的几款垃圾收集器(OpenJDK中的G1、 Shenandoah、ZGC),无一例外都具备了局部回收的特征，为了避免 GC Roots包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。

#### Java中的四种引用类型

在Java中一切皆对象，对象的操作是通过该对象的引用（Reference）实现的，Java中的引用类型有4种，分别为强引用、软引用、弱引用和虚引用。

- 强引用：最传统的引用定义，值代码之中普遍存在的引用赋值。在把`一个对象赋给一个引用变量即 new`时，这个引用变量就是一个`强引用`。有强引用的对象定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成Java内存泄漏（ Memory link）的主要原因。
  - 定义：如果 reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference数据是代表某块内存、某个对象的引用。
- 软引用：描述一些还有用，但非必须的对象。如果一个对象`只有软引用`，在系统将要发生`内存溢出异常前`，会把这些对象`列进回收范围`之中进行第`二次回收`，如果这次回收还没有足够的内存，才会抛出内存溢出异常。软引用通过 SoftReference类实现
- 弱引用：描述一些非必须的对象，如果一个对象只有弱引用，则在`垃圾回收过程中一定会`被回收。弱引用通过 WeakReference类实现。
- 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也`无法`通过虚引用来`取得一个对象实例`。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器`回收时收到一个系统通知`。`虚引用和引用队列联合使用`，主要用于跟踪对象的垃圾回收状态。虚引用通过 PhantomReference类实现

#### 对象真正死亡？

真正宣告一个对象死亡，至少要经历两次标记，一次可达性分析标记，一次在判定有必要执行 finalized方法判定后，放入F- Queue中等待Finalizer线程去执行，之后收集器将对F- Queue中的对象进行第二次小规模的标记。：

- 如果对象在进行可达性分析后发现`没有与 GC Roots`相连接的`引用链`，那它将会被第一次标记，
- 随后`进行一次筛选`，筛选的条件是此对象是否有必要执行 finalized方法。假如对象没有覆盖 finalized方法，或者 finalize方法已经被虚拟机调用过，那这个对象就死了。
- 如果这个对象被判定为确`有必要执行 finalized方法`，那么该对象将会被放置在一个名为`F- Queue的队列`之中，并在稍后由一条由虚拟机自动建立的、`低调度优先级`的 `Finalizer线程去执行`它们的 finalized方法。这里所说的“执行”是指虚拟机会`触发`这个方法开始`运行`，但并`不承诺`一定会`等待`它运行`结束`。这样做的原因是，如果某个对象的 finalize方法`执行缓慢`，或者更极端地发生了`死循环`，将很可能导致F- Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。
- finalized方法是对象逃脱死亡命运的最后一次机会，`稍后收集器将对F- Queue中的对象进行第二次小规模的标记`，如果对象要在 finalized中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，`譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量`，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。
  - 注：但也`不是百分百成功`，因为不知道收集器啥时候来遍历F-Queue，所以不能做关闭资源的操作。 而且finalize方法只能被系统调用一次。

  



### 为什么MajorGC之前，要进行一次MinorGC？



因为老代空间中的对象可能持有对年轻代空间中的对象的引用。如果年轻代空间没有被垃圾收集，那么在老代空间中`持有对年轻代空间中的对象的引用`的任何`对象`都`不能`被垃圾收集。

![image-20200911171512671](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911171514.png)

老年代的是GC root是？？  这

### （新）垃圾回收算法？

Jaa中常用的垃圾回收算法有

- `标记清除算法：`内存碎片化

- `复制算法：`内存清理销量高，且易于实现 。但由于同一时刻只有一个内存区域可用，因此存在大量的内存浪费。在系统中有大量长时间存活的对象时，这些对象的来回复制也会影响系统的运行效率。因此，该算法只在对象为“朝生夕死”状态时运行效率较高。

- `标记整理算法：`标记整理算法结合了标记清除算法和复制算法的优点，其标记阶段和标记清除算法的标记阶段相同，在标记完成后将存活的对象移到内存的另一端，然后清除该端的对象并释放内存。

- `分代收集算法：`无论是标记清除算法、复制算法还是标记整理算法，都无法对所有类型（长生命周期、短生命周期、大对象、小对象）的对象都进行垃圾回收。因此，针对不同的对象类型，JVM采用了不同的垃圾回收算法，该算法被称为分代收集算法。

  分代收集算法根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代和老年代。

  - `新生代：`主要存放新生成的对象，其特点是对象数量多，但是小而且生命周期短，采用复制算法。
  - `老年代：`主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。采用标记清楚。

#### 分代收集算法和分区收集算法

  - 分代收集算法：JVM根据对象存活周期的不同将内存划分为新生代、老年代和永久代，并根据各年代的特点分别采用不同的GC算法。
    - `新生代：`主要存放新生成的对象，其特点是对象数量多，但是小而且生命周期短，采用复制算法。
    - `老年代：`主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。采用标记清楚。
  - 分区收集算法：分区算法将整个堆空间`划分为连续的大小不同的小区域`，对每个小区域都`单独进行内存使用和垃圾回收`，这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。
    分区收集算法可以根据系统可接受的停顿时间，`每次都快速回收若干个小区域`的内存，`以缩短垃圾回收时系统停顿的时间`，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。如果垃圾回收机制一次回收整个堆内存，则需要更长的系统停顿时间，长时间的系统停顿将影响系统运行的稳定性。

### 垃圾收集器





## 熟悉



## 了解

