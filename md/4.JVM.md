JVM

## 概念

### [JAVA中类、实例与Class对象](https://blog.csdn.net/djzhao/article/details/79107071)

**类：**类是面向对象编程语言的`一个重要概念`，它是`对一项事物的抽象概括，可以包含该事物的一些属性定义，以及操作属性的方法`。

类只是信息描述的，写明了有哪些内部属性及接口，你可以理解为是程序员定义了一套规则。

面向对象编程中，我们都是以类来编码。

**Class：**在包 java.lang 下继承Object特殊的**Class类**，它内部可以记录类的成员、接口等信息，也就是在Java里，Class是一个用来`表示类的类`，让JVM`看懂的一套模板`。（Class是一个实实在在的类，可以为它创建实例，也就是本文后面提到的Class对象，也叫做Class实例：就是类加载器加载到内存中的模板。）。

java提供了下面几种获取到类的Class对象的方法：

- （1）利用对象实例调用getClass()方法获取该对象的Class实例；

- （2）运用类名.class 的方式来获取Class实例；

- （3）使用Class类的静态方法forName("包名+类名")，用类的名字获取一个Class实例

  ![image-20200913202846994](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200913202855.png)

**实例：**简单理解，就是new，就是对类的实例化，创建这个`类对应的实际对象`，`类只是对事物的描述`，而`实例化`就相当于为`这个描述新开辟了一块内存`，可以改变这块区域里的各种属性（成员变量），用操作方法。当然，也可以实例化多块区域，只是不同的对象而已。

总结：在java里，`类只是信息描述`的，写明了有哪些内部属性及接口，你可以理解为是定义了`一套规则`；而`Class对象`在java里被用来对类的情况进行表述的一个实例，也就是是`类的实际表征`，可以理解为是对规则的图表化，这样`JVM才能直观的看懂，可以看做是一个模版`；而类的`实例化对象，就是通过模版，开辟出的一块内存进行实际的使用`。

### 类文件结构

无关性基石

各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——**字节码（Byte Code）是构成平台无关性的基石**

**《Java语言规范》-语言无关性：**商业企业和开源机构已经在Java语言之外发展出一大批运行在Java虚拟机之上的语言，如`Kotlin、Clojure、Groovy、JRuby、JPython、Scala`等。

实现语言无关性的基础仍然是**虚拟机**和**字节码存储格式**。*Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联*，Class文件中包含了Java虚拟机 指令集、符号表以及若干其他辅助信息。

作为一个通用的、与机器无关的执行平 台，任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础，以Class文件作为他们产品的交付媒介。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200921190508.png" alt="image-20200921190506747" style="zoom:50%;" />

#### Class类文件结构



时至今日，Java发展 经历了十余个大版本、无数小更新，那时`定义的Class文件格式的各项细节几乎没有出现任何改变`。尽管不同版本的《Java虚拟机规范》对Class文件格式进行了几次更新，但基本上只是在原有结构基础上 `新增内容、扩充功能`，`并未对已定义的内容做出修改`。

- 任何一个*Class文件都对应着唯一的一个类或接口的定义信*息，但是反过来说，类或
  接口并不一定都得定义在文件里（譬如`类或接口也可以动态生成，直接送入类加载器中`）。

Class文件是一组以`8个字节为基础单位的二进制流`，各个数据项目严格按照顺序紧凑地排列在文件之中，中间`没有添加任何分隔符`，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。

当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割成若干个8个字节进行存储。
		根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。后面的解析都要以这两种数据类型为基 础，所以这里笔者必须先解释清楚这两个概念。

- **无符号数属于基本的数据类型**，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数**可以用来描述**`数字`、`索引引用`、`数量值`或者按照UTF-8编码构成`字符串值`。
- **表是由多个无符号数或者其他表作为数据项构成的复合数据类型**，为了便于区分，所有表的命名都习惯性地`以“_info”结尾`。表用于描述有层次关系的`复合结构的数据`，*整个Class文件本质上也可以视作是一张表*，这张表由表6-1所示的数据项按严格顺序排列构成。

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用`一个前置的容量计数器加若干个连续的数据项的形式`，这时候称这一系列连续的某一类型的数据为某一类型的“`集合`”。

#### 魔数

每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是**确定这个文件是否为一个能被虚拟机接受的Class文件**。

不仅是Class文件，很多文件格式标准中都有使用魔数来进行身份识 别的习惯，譬如图片格式，如GIF或者JPEG等在文件头中都存有魔数。

使用魔数而不是扩展名来进行识别主要是基于**安全考虑**，因为**文件扩展名可以随意改动**。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆。

Class文件的魔数取得很有“浪漫气息”， 值为`0xCAFEBABE`（咖啡宝贝？）

#### 版本号

紧接着魔数的4个字节存储的是Class文件的版本号：**第5和第6个字节是次版本号（Minor**
**Version），第7和第8个字节是主版本号（Major Version）**。Java的版本号是从`45开始的`，JDK 1.1之后 的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的**JDK能 向下兼容以前版本的Class文件，但不能运行以后版本的Class文件**，因为《Java虚拟机规范》在Class文 件校验部分明确要求了即使文件格式并未发生任何变化，**虚拟机也必须拒绝执行超过其版本号的Class 文件。**

#### 常量池

紧接着主、次版本号之后的是常量池入口，常量池可以比喻为**Class文件里的资源仓库**，它是Class文件结构中与其他项目关联最多的数据，通常也是**占用Class文件空间最大的数据项目之一**，另外，它还是**在Class文件中第一个出现的表类型数据项目**。
	由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项**u2类型**的数据，代表**常量池容量计数值**（constant_pool_count）。与Java中语言习惯不同，这个**容量计数是从1**而不是0**开始** 的

- 在Class文件格式规范制定之时，设计者将第0项常量 空出来是有特殊考虑的，这样做的目的在于，如果后面*某些指向常量池的索引值的数据在特定情况下 需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示*。

Class文件结构中只有 常量池的容量计数是从1开始，对于其他集合类型，包括`接口索引集合`、`字段表集合`、`方法表集合`等的 *容量计数都与一般习惯相同，是从0开始*。

常量池中主要存放两大类**常量**：`字面量（Literal）`和`符号引用（Symbolic References）`。

1. **字面量**比较接近于Java语言层面的常量概念
   - 文本字符串
   - 被声明为final的常量值。
   - 基本数据类型的值
   - 其他
2. 而**符号引用**则属于编译原理方面的概念，主要包括下面`几类常量`(相当于字典?)：
   - 被模块导出或者开放的包（Package） 
   - 类和接口的全限定名（Fully Qualified Name） 
   - 字段的名称和描述符（Descriptor） 
   - 方法的名称和描述符 
   - 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic） 
   - 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant） 

Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候`进行动态连接`（具体见第7章）。也就是说，在`Class文件中不会保存各个方法、字段最终在内存中的布局信息`，这些*字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址*，也就无法直接被虚拟机使用的。当`虚拟机做类加载时`，将会从`常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中`。关于类的创建和动态连接的内容， 在下一章介绍虚拟机类加载过程时再详细讲解。

常量池中**每一项常量都是一个表**，常量表中分别有17种不同类型的常量。
这17类表都有一个共同的特点，**表结构起始的第一位是个u1类型的标志位**（tag，取值见表6-3中标志列），代表着当前常量属于哪种常量类型。

u2类型能表达的最大的值是65535所以Java程序中如果定义了超过64KB 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。接口数量超过65535也不合法的

#### 访问标注

在常量池结束之后，紧接着的**2个字节代表访问标志（access_flags）**，这个标志用于`识别一些类或者接口层次的访问信息`，包括：*这个Class是类还是接口；是否定义为public类型；是否定义为abstract 类型；如果是类的话，是否被声明为final；等等。*

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200921194905.png" alt="image-20200921194901665" style="zoom:50%;" />

#### 类索引、父类索引与接口索引集合 

类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合
（interfaces）是一组u2类型的数据的集合，Class文件中由这**三项数据来确定该类型的继承关系**。

`类索引`:用于`确定`这个`类的全限定名`

`父类索`:引用于确定这个`类的父类`的`全限定名`。由于Java语言不允许多 重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了 java.lang.Object外，所有Java类的父类索引都不为0。

`接口索引集合`就用来描述这个`类实现了哪些接口`，这些被实现的接口将按**implements关键字**（如果这个Class文件表示的是一个接口，则应当是 extends关键字）**后的接口顺序从左到右排列在接口索引集合中**。
		类索引、父类索引和接口索引集合都`按顺序排列在访问标志之后`

**类索引和父类索引用**两个u2类型的索引值表示:

1. 它们各自指向一个类型为`CONSTANT_Class_info`的类描述符常量

2. 通过 CONSTANT_Class_info类型的`常量中的索引值`可以找到定义在`CONSTANT_Utf8_info`类型的`常量中的全限定名字符串`。图6-6演示了代码清单6-1中代码的类索引查找过程。

   <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200923204842.png" alt="image-20200923204840693" style="zoom:50%;" />

**接口索引集合**，入口的第一项`u2类型`的数据为`接口计数器`（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200923210434.png" alt="image-20200923210432372" style="zoom:50%;" />

#### 字段表集合 

字段表（field_info）用于**描述接口或者类中声明的变量**。Java语言中的“字段”（Field）包括*类级变量以及实例级变量，但不包括在方法内部声明的局部变量*。

字段可以包括的修饰符有

- 字段的作用域（public、private、protected修饰 符）、
- 是实例变量还是类变量（static修饰符）、
- 可变性（final）、
- 并发可见性（volatile修饰符，是否 强制从主内存读写）、
- 可否被序列化（transient修饰符）、
- 字段数据类型（基本类型、对象、数组）、 
- 字段名称。

上述这些信息中，各个`修饰符都是布尔值`，要么有某个修饰符，要么没有，很`适合使用标志`位来表示。

而字段叫做什么名字、字段被定义为什么数据类型，这些都是`无法固定的`，只能`引用常量池中的常量`来描述。

字段表的结构如同字段表一样，依次包括**字段表容量计数器(fields_count)**、**访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表计数器（attributes_count）  属性表集合（attributes）**几项

表6-8中列出了字段表的最终格式

![image-20200923211054569](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200923211056.png)

**全限定名:** 以代码清单6-1中的代码为例，“`org/fenixsoft/clazz/TestClass”`是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混 淆，在使用时最后一般会加入一个“；”号表示全限定名结束。

**简单名称**: 则就是指没有类型和参数修饰 的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。
		相比于全限定名和简单名称，方法和字段的描述符就要复杂一些。**描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值**。

根据描述符规则，

- **基本数据类型**（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示![image-20200923211517435](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200923211519.png)

- **数组类型**，每一维度将使用一个前置的`“[”`字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成`“[[Ljava/lang/String；”`，一个整型数组`“int[]”将被记录成“[I”`。 

- 描述符来`描述方法时`，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符 为“()Ljava/lang/String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target， int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。

  

字段表所包含的固定数据项目到descriptor_index为止就全部结束了，不过在descrip-tor_index之`后跟随着一个属性表(attributes)集合，用于存储一些额外的信息`，字段表可以在属性表中附加描述零至多项的额外信息。对于本例中的字段m，它的属性表计数器为0，也就是没有需要额外描述的信息，但是，如果将字段m的声明改为`“final static int m=123；”`，那就可能会存在一项名称为**ConstantValue的属性，其值指向常量123**。
      **字段表集合中不会列出从父类或者父接口中继承而来的字段**，但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。另外，*在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的。*

#### 方法表集合 

Class文件存储格式中对**方法的描述与对字段的描述**采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括**方法表容量计数器(fields_count)**、**访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）**几项，如表6-11所示。这些数据项目的含义也与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。

![image-20200923212602491](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200923212603.png)

方法的定义可以通过访问标志、名称索引、描述符索引来 表达清楚，但方法里面的代码去哪里了？

方法里的Java代码，**经过Javac编译器编译成字节码指令之后**，**存放**在**方法属性表(attributes)集合中一个名为“Code”的属性**里面，属性表作为Class文件格式中最具扩展性的 一种数据项目，将在下一节中详细讲解。

与字段表集合相对应地，`如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息`。

 在Java语言中，要**重载（Overload）**一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个**与原方法不同的特征签名**[2]。

特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合(Java代码的`方法特征签名只包括方法名称、参数顺序及参数类型`)，也正是因为**返回值不会包含在特征签名之中**，所以Java语言里面是**无法仅仅依靠返回值的不同来对一个已有方法进行重载的**。

但是在Class文件格式之中，特征签名的范围明显要更大一些， 只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签 名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。

#### 属性表集合 

属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。为了能正确解析Class文件

##### Code属性 

Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽 象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如表6-15所示。

![image-20200924174231686](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200924174233.png)

- **attribute_name_index**是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“**Code**”，它代表了该属性的属性名称，
- **attribute_length**指示了属性值的长度，由于属性名称索引与属性长度一共为 6个字节，所以属性值的长度固定为**整个属性表长度减去6个字节**。
- **max_stack**代表了操作数栈（Operand Stack）深度的最大值。
- **max_locals**代表了**局部变量表所需的存储空间**。
- code_length和code用来存储Java源程序编译后生成的字节码指令。**code_length**代表**字节码长度**，**code**是用于存**储字节码指令的一系列字节流**。

Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为

代码（Code，方法体里面的Java代码）

和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，

那么在整个Class文件里，**Code属性用于描述代码，所有的其他数据项目都用于描述元数据。**

##### Exceptions属性 

这里的Exceptions属性是在方法表中与Code属性平级的一项属性，读者不要与前面刚刚讲解完的异常表产生混淆。Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也 就是方法描述时在throws关键字后面列举的异常。

##### LineNumberTable属性 

LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。

##### LocalVariableTable及LocalVariableTypeTable属性 

`LocalVariableTable`属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。

在JDK 5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”——
`LocalVariableTypeTable`。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的**字段描述符的descriptor_index替换成了字段的特征签名（Signature）**。

对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，

但是泛型引入之后，**由于描述符中泛型的参数化类型被擦除掉**[3]，描述符就不能准确描述泛型类型了。因此出现了**LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述**。

##### SourceFile及SourceDebugExtension属性 

`SourceFile`属性用于记录生成这个Class文件的**源码文件名称**.对于大多数的类来说，类名和文 件名是一致的，但是有一些特殊情况（**如内部类**）例外。如果不生成这项属性，当抛出异常时，堆栈 中将不会显示出错代码所属的文件名。

为了方便在编译器和动态生成的Class中加入供程序员使用的自定义内容，在JDK 5时，新增了
**SourceDebugExtension属性**用于存储额外的代码调试信息。

##### **ConstantValue**属性

 ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。

##### InnerClasses属性 

InnerClasses属性用于记录内部类与宿主类之间的关联

##### Deprecated及Synthetic属性 

Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。 

**Deprecated**属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。 

**Synthetic**属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的 ACC_SYNTHETIC标志位。编译器通过生成一些在源代码中不存在的Synthetic方法、字段甚至是整个 类的方式，实现了越权访问（越过private修饰器）或其他绕开了语言限制的功能，这可以算是一种早 期优化的技巧，其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法 （Bridge Method）。所有由不属于用户代码产生的类、方法及字段都应当至少设置Synthetic属性或者 ACC_SYNTHETIC标志位中的一项，唯一的例外是实例构造器“<init>()”方法和类构造器“<clinit>()”方 法。

##### StackMapTable属性

这个属性会在**虚拟机类加载的字节码验证阶段**被新**类型检查验证器**（Type Checker）使用（详见第7章字节码验证部分），目的在于代替以前比较消耗性能的基于数据流分析的 类型推导验证器。

StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示**执行到该字节码时局部变量表和操作数栈的验证类型**。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型**来确定一段字节码指令是否符合逻辑约束**

Signature属性 Signature属性在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段
表和方法表结构的属性表中。在JDK 5里面大幅增强了Java语言的语法，在此之后，任何类、接口、初 始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（Parameterized Type），则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类 型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编 译（类型变量、参数化类型）在编译之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改 Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型 所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的 普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而

### JVM的运行机制？

运行Java字节码的虚拟机，包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器。
	**Java源文件被编译器编译成.Class文件，.Class文件被解释器解释成机器码，机器码调用相应操作系统的本地方法库执行相应的方法**。
	在一个Java进程开始运行后，虚拟机就开始**实例化**了，**有多个进程启动就会实例化多个虚拟机实例**。虚拟机实例之间不能共享数据。



### JVM（Java虚拟机）有哪些部分组成？

- `类加载器：`于将编译好的. Class文件加载到JVM中
- `运行时数据区：`用于存储在JVM运行过程中产生的数据，包括线程私有的`程序计数器、虚拟机栈、本地方法栈`和线程共享的`方法区、虚拟机堆`；
- `执行引擎：`包括`即时编译器`和`垃圾回收器`，即时编译器用于将Java字节码编译成具体的机器码，垃圾回收器用于回收在运行过程中不再使用的对象
- `本地接口库`用于调用操作系统的本地方法库完成具体的指令操

![image-20200912193207228](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912193208.png)



### 运行时数据区（内存区域）

线程到底在私有区域在干什么？哪些是在栈中的？概述

每个区域都是干什么的，都存储了什么

![image-20200912194906222](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912194907.png)

**线程私有区域**：

- `程序计数器：`**记录当前运行线程在该方法中执行的字节码指令位置（行号指示器）**。在方法正在执行时，该方法的程序计数器记录的是实时虚拟机字节码指令的地址，Native方法，程序计数器的值为空（undefined）。唯一**无内存溢出**（Out Of Memory）问题的地方。

- `虚拟机栈：`描述的是**执行Java方法的线程内存模型**。在**方法**被执行时虚拟机会为其创建一个**与之对应的栈帧**，里面存储：局部变量表、操作栈、动态链接、方法出口等信息。`方法的执行和返回对应栈帧在虚拟机栈的入栈和出栈`。每个运行中的线程当前只有一个栈帧处于活动状态（线程执行代码是顺序的）。
  	  	`栈帧存储：`
  
  - `局部变量表`：存放`编译期可知的数据类型`，数据类型在局部变量表中的存储空间以局部变量槽（Sot）来表示，其中64位长度的`long和double类型`的数据会占用`两个变量槽`，`其余`的数据类型只`占用一个`。数据类型所需空间在编译期完成，进入方法前已经确定，运行期间不会改变局部变量表大小。
    - 基本数据类型
    - 对象引用
    - returnAddress（指向了一条字节码的地址）
  - `操作栈`：
  - `动态链接`：
  - `方法出口等`：
  
  ​		异常：
    				StackOverflowError：请求栈大于虚拟机深度
    				OutOfMemoryError：虚拟机栈容量可以动态扩展，但无法申请足够的内存。
  
- `本地方法栈：` 线程私有，本地方法区和虚拟机栈的作用类似，区别是虚拟机栈为执行Java 方法服务，`本地方法栈为Native方法服务`	

**线程共享区域**：

- 方法区：（`Java8元空间概念所在，采用本地内存实现`）用于存储已被虚拟机加载的**静态常量池**，**类型信息（即时编译器编译后的机器码）**等数据。垃圾回收器主要做针对**常量池的回收**，和**类型的卸载**。（所有的Class文件一次性都加载进内存？什么时候加载？）

  - 静态常量池

    - 字面量
    - 符合引用

    ![image-20200912205138122](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912205139.png)

  **注：**而当类加载到内存中后，JVM就会将`静态常量池中的内容存放到运行时常量池`中。在静态常量池的符号引用有`一部分是会被转变为直接引用`的，比如说**类的静态方法或私有方法，实例构造方法，父类方法**，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被**第一次调用（线程调用到虚拟机栈？）**的时候才会将符号引用转变为直接引用的。

- `虚拟机堆：`虚拟机管理最大的区域，`虚拟机启动时创建`。在JVM运行过程中**几乎**所有的**对象实例**和**产生的数据**都被存储在堆中。垃圾回收器（GC）工作的区域。

  JDK8：

  - 对象实例
  - 运行时常量池
    - 字符串常量池：存的是在堆中的字符串的引用？还是字符串对象？

  **注1：**对堆的区域划分，仅仅是垃圾收集器的设计风格，一种概念，而非JVM具体实现的固有布局。

  **注2：**字符串常量池存的是引用值？，还是对象存在于运行时常量池之中？。

  **注3：**类（.class文件）加载到内存中后，JVM就会将`静态常量池中的内容存放到运行时常量池`中，运行时常量池更重要的的特征：`动态性`。Java要求，编译期静态常量池的内容可以进入运行时常量池（字符串），运行时产生的常量也可以放入池中：常用的是String类的intern()方法。（类加载器不是一次将所有的的.class文件都加载进内存）

  注4：几乎？：值类型的支持，以及编译技术进步，逃逸分析，栈上分配，标量替换优化手段导致一些微妙的变化，对象都分配到栈上已经不那么绝对了。

**直接内存：**

直接内存也叫作堆外内存，它**并不是JVM运行时数据区**的一部分，但在并发编程中被频繁使用。
		例如：JDK的**NIO模块提供的基于 通道（Channel）与缓冲区（Buffer）的I/O操作方式**就是基于堆外内存实现的，NIO模块通过**调用Native函数库直接在操作系统上分配堆外内存**，然后使用DirectByteBuffer对象作为这块内存的引用对内存进行操作
					Java进程可以通过堆外内存技术**避免在Java堆和 Native堆中来回复制数据带来的资源占用和性能消耗**，因此堆外内存在高并发应用场景下被广泛使用（ Netty、F1ink、 HBase、 Hadoop都有用到堆外内存）

#### 静态常量池在Class文件中的位置

![image-20200912211433506](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912211434.png)

从上图可以看出，Class文件中包括：

魔数：它的唯一作用是确定这个文件是否可以被JVM接受。很多文件储存标准中都使用魔数来进行身份识别的，其占用这个文件的前四个字节。

版本号：第5和第6个字节是副版本号，第7个和第8 个是主版本号。

常量池计数器：也就是常量池的入口，代表常量池的容量计数器。

常量池：常量池中主要存放两类常量：字面量和符号引用。字面量比较接近Java语言层面的常量概念。就是我们什么提到的常量。而符号引用则属于编译原理的方面的概念。包括以下三类常量：

（1）类和接口的全限定名

（2）字段的名称和描述符

（3）方法的名称和描述符

### 对象

#### 对象的创建

对象的创建过程：通常指new[^其他创建方式]一个对象[^讨论对象]，创建对象是由`一个线程参与完成`的。

1. `类加载检查：`当Java虚拟机遇到一条字节码`new指令`时，首先将去检査这个指令的参数是否能在`常量池中定位到个类的符号引用（哪个常量池？不能怎么办？）`，并且检査这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

   `类加载过程：`

2. `分配内存（方法区-->堆-->Eden）：`在类加载检查通过后，接下来虚拟机将为新生对象在Java堆中划分内存。对象所需内存的大小在类加载完成后便可完全确定（怎么确定）。

   （1）类加载完成后，怎么确定内存大小。

   - 

   （2）划分方式：

   - `指针碰撞：`适合`堆中内存绝对规整`。所有被使用过的内存都被放在边，空闲的内存被放在另一边，中间放着一个`指针作为分界点的指示器`，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离。
   - `空闲列表`：适合`堆中的内存并不是规整`。虚拟机就必须`维护一个列表`，`记录`上哪些`内存块`是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

   选择**哪种分配方式由Java堆是否规整**决定，而Java堆是**否规整又由所采用的垃圾收集器**是否带有空间压缩整理的能力决定。

   - 压缩整理：使用 `Serial、 ParNew`等带压缩整理过程的收集器时，系统采用的分配算法是`指针碰撞`，既简单又高效
   - 清除算法：理论上山就只能采用较为复杂的空闲列表来分配内存
     - 强调¨理论上”是因为在CMS的实现里面，为了能在多数情况下`分配得更快`，设计了一个叫作 `Linear Allocation Buffer的分配缓冲区`，通过空闲列表`拿到一大块分配缓冲区`之后，在它里面仍然可以使用`指针碰撞`方式来分配。

   （3）频繁对象创建，移动指针不是线程安全的。

   - `对分配内存空间的动作进行同步处理`：实际上虚拟机是采用`CAS配上失败重试`的方式`保证更新操作的原子性`
   - `把内存分配的动作按照线程划分在不同的空间之中进行`：即`每个线程在Java堆中预先分配一小块内存`，称为本地线程分配缓冲（ Thread Local Allocation Buffer,TLAB）。**哪个线程要分配内存**，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，**分配新的缓存区时才需要同步锁定**。（虚拟机是否使用TLAB，可以通过-XX：+/- UseTlAB参数来设定）。

3. `内存空初始化为零值：`内存分配完成之后，虚拟机`必须将分配到的内存空间（但不包括对象头）都初始化为零值`，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了`对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值`。

4. `Java虚拟机还要对对象头进行必要的设置`：

   - 见对象的内存布局：对象头部分：运行时数据，和类型指针。

5. `构造函数初始化字段`：因为目前所有的字段都为默认的零值。需要用构造函数，即 Class文件中的<init>()方法对对象需要的其他资源和状态信息按照程序员预定的意图构造好。

   - 一般来说（由字节码流中new指令后面是否跟随 invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），`new指令之后会接着执行<init>方法`

![image-20200913220431790](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200913220433.png)

[^其他创建方式]:clone，反序列化
[^讨论对象]:普通Java对象，不包含数组，Class对象

#### 对象的内存布局

在 HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（ Header）、实例数据（ Instance data）和对齐填充（ Padding）。

[对象头](https://blog.csdn.net/zhaocuit/article/details/100208879)：对象头部分包括两类信息。

- 用于存储对象`自身的运行时数据`：叫`Mark Word`（32位32bit，64位64bit），被设计成一个有着`动态定义的数据结构`，即根据自身状态复用存储空间。

  - **哈希码（HashCode）**、**GC分代年龄**、**锁状态标志**、**线程持有的锁**、**偏向线程ID**、**偏向时间戳**等。

  ![image-20200914212749892](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914212751.png)

- `类型指针：`即对象`指向它的类型元数据的指针`，Java虚拟机通过这个指针来确定该对象是哪个类的实例。

  - 并不是所有的虚拟机实现都必须在对象数据上保留类型指针，如果reference类型采用`句柄定位的方式，对象头中就没必要存储类型的指针`。
  - `如果对象是一个Java数组`，那在`对象头`中还必须`有`一块用于`记录数组长度的数据`，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果`数组的长度是不确定`的，将无法通过元数据中的信息推断出数组的大小。

- `实例数据：`对象真正存储的有效信息，即我们在**程序代码里面所定义的各种类型的字**

  **段内容**，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（-XX: Fields Allocation Sty le参数）和字段在Java源码中定义顺序的影响。

- `对齐填充：`它仅仅`起着占位符的作用`。由于 HotSpot虚拟机的自动内存管理系统要求`任何对象的大小都必须是8字节的整数倍`。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。（为什么?）

#### 对象的访问定位

Java程序会通过`栈上的 reference数据来操作堆上的具体对象`。

由于 `reference类型`在《Java虚拟机规范》里面`只规定了它是一个指向对象的引用`，并没有定义。

reference类型主流的访问：

句柄：Java堆中将可能会划分出一块内存来作为句柄池， `reference`中存储的就是对象的`句柄地址`，而`句柄中`包含了`对象实例数据`与`类型数据`各自具体的地址信息。

![image-20200914215057178](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914215058.png)

直接指针： reference中`存储`的直接就是在`Java堆中对象实例地址`，**对象头中存储有指向元数据类型实例的指针**。

![image-20200914215738526](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914215739.png)

`优缺点：`

- 使用`句柄`来访问的最大好处，就是 reference 中存储的是稳定的句柄地址，在`对象被移动`（垃圾收集时移动对象是非常普遍的行为）时`只会改变句柄中`的实例数据指针，而 `reference 本身不需要修改`。
- 使用`直接指针`访问方式，如果`只访问对象本身`的话，它`节省了一次指针定位的时间`开销，最大好处就是速度更快，，由于对象的访问在 Java 中非常频繁，并且也不经常访问数据类型，因此这类开销积少成多后也是一项非常可观的执行成本。

**HotSpot采用的是直接指针的方式**。

### Java内存模型

为了在同样的制程工艺下，追求最大的运算能力。人们用多核并发除了来提升计算机的运算加速能力。

随着并发处理的广泛应用是 `Amdahl（阿姆达尔）定律`代替 `摩尔定律`成为计算机性能发展源动力的根本原因，也是人类压榨计算机运算能力的最有力武器。

- Amdahl定律通过系统`中并行化与串行化的比重`来描述多处理器系统能获得的运算加速能力
- 摩尔定律则用于描述处`理器晶体管数量与运行效率`之间的发展关系。

这两个定律的更替代表了近年来硬件发展从`追求处理器频率到追求多核心并行处理的发展过程`。

“内存模型”：它可以理解为在特定的`操作协议`下，对特定的内存或高速缓存`进行读写访问`的过程抽象。

- 操作协议：为了`解决一致性`的问题，需要各个处理器访问缓存时都`遵循`一些`协议`，在`读写时`要根据协议来进行操作

#### 主内存与工作内存

为了获得更好的执行效能，Java内存模型并*没有限制*执行引擎使用处理器的特定寄存器或*缓存*来和主内存进行交互，*也没有限制*即时编译器是否要进行*调整代码执行顺序这类优化措施*。

Java内存模型的主要目的：

- `定义`程序中各种`变量的访问规则`，即关注在虚拟机中把变量值`存储`到内存和从内存中`取出`变量值这样的底层细节。
  
  - 此处的**变量（ Variables）**与Java编程中所说的变量有所区别，它包括了`实例字段`、`静态字段`和`构成数组对象的元素`，但是不包括局部变量与方法参数，因为`后者是线程私有`的，不会被共享，自然就不会存在竞争问题。
    - 如果局部变量是一个 reference类型，它引用的对象在Java堆中可被各个线程共享，但是 reference本身在Java栈的局部变量表中是线程私有的。
  
  

Java内存模型规定了所有的变量都存储在`主内存`（ Main memory）中。每条线程还有自己的`工作内存`（ Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存`副本【1】`，线程对变量的`所有操作`（读取、赋值等）都必须`在工作内存中`进行，而不能直接读写主内存中的数据【2】。不同的线程之间也无法直接访问对方工作内存中的变量，`线程间变量值的传递均需要通过主内存来完成`。

1. 有部分读者会对这段描述中的“副本”提出疑问，如“假设线程中访问一个10MB大小的对象，也会把这10MB的内存复制一份出来吗？”，事实上并不会如此，这个**对象的引用、对象中某个在线程访问到的字段是有可能被复制**的，但不会有虚拟机把整个对象复制一次
2.  volatile变量依然有工作内存的拷贝，但是由于**它特殊的操作顺序性规定**（后文会讲到），所以看起来如同直接在主内存中读写访问一般，因此这里的描述对于 volatile也并不存在例外。

线程、主内存、工作内存三者的交互关系如图所示：

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200915192525.png" alt="image-20200915192524484" style="zoom:33%;" />

![image-20200915192941238](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200915192943.png)



#### 内存交互操作

一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种**操作**都是**原子的**、**不可再分的**（对于 double和long类型的变量来说，load、 store、read和wite操作在某些平台上允许有例外，这个问题在12.3.4节会专门讨论）：

- lock（锁定）:作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- unlock（解锁）:作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）:作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的lad动作使用。
- load（载入）:作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）:作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
-  assign（赋值）:作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，当虚拟杋遇到一个给变量赋值的字节码指令时执行这个操作
- store（存储）:作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用。
- write（写入）:作用于主内存的变量，它把 store操作从工作内存中得到的变量的值放入主内存的变量中。

基于理解和严谨性考虑，Java设计团队已经放弃了采用这8种操作去定义**Java内存模型的访问协议**，将Java内存模型的`操作`简化为**read、 write、lock和 unlock**四种，但这只是语言描述上的等价化简，仅是描述方式改变了，Java内存模型的设计基础并没有改变。

Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：

- （1）：`不允许read和load、 store和 write操作之一单独出现（精简为 read、write）`，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。
- （2）：不允许一个线程丢弃它最近的 assign操作，即`变量在工作内存中改变了之后必须把该变化同步回主内存`。
- （3）：不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。`没有复制操作，不能重新写入主内存（即load进线程内部，没动，就不要写回去了，防止发生安全问题）`。
- （4）：一个*新的变量（不包含内部变量）*只能在主内存中“诞生”，`不允许在工作内存中直接使用一个未被初始化（load或assign）的变量`，换句话说就是对一个变量实施use、 store操作之前，必须先执行 assign和load操作。
- （5）：**一个变量在同一个时刻只允许一条线程对其进行lock操作**，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的 unlock操作，变量才会被解锁。
- （6）：如果对`一个变量执行lock操作，那将会清空工作内存中此变量的值`，在执行引擎*使用这个变量前，需要重新执行load或 assign操作以初始化变量的值*
- （7）：如果一个变量事先`没有被lock操作`锁定，那就`不允许`对它执行 `unlock`操作，也不允许去 unlock一个被其他线程锁定的变量。
- （8）：对一个变量执行 `unlock操作之前，必须先把此变量同步回主内存中`（执行 store、 write操作）

#### 内存模型中对于 volatile型变量的特殊规则

关键字 volatile可以说是Java虚拟机提供的最轻量级的同步机制（比synchronized轻得多），

了解 volatile变量的语义对后面理解多线程操作的其他特性很有意义。

`Java内存模型为 volatile专门`定义了一些`特殊的访问规则`。

volatile关键字的作用：当一个变量被定义成 volatile之后，它将具备两项特性

- 第一项是`保证此变量对所有线程的可见性，及保证使用前的一致性`，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的（从物理存储的角度看，各个线程的工作内存中 volatile变量也可以存在不一致的情况，但由于`每次使用之前都要先刷新`，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题）。

  - 但是Java里面的运算操作符并非原子操作，这导致 volatile变量的运算在并发下一样是不安全的。也就是说执行引擎`用（use）的时候`，其他的线程可能会修改。

  `volatile变量只能保证可见性`，只能在以下两种情况可以使用（其他情况我们仍然要通过加锁使用 synchronized、 javautil.concurrent中的锁或原子类来保证原子性）：

  - `运算结果并不依赖变量的当前值`，或者能够确保只有单一的线程修改变量的值。

  - 变量不需要与其他的状态变量共同参与不变约束。（？）

    `总结：`可以用来当标识。

- volatile变量的第二个语义是`禁止指令重排序优化`，普通的变量`仅会保证`在该方法的执行过程中所有依赖赋值结果的地方都能`获取到正确的结果`，而`不能保证变量赋值操作的顺序与程序代码中的执行顺序一致`。因为在同一个线程的方法执行过程中无法感知到变量的变化，只看见了最终结果。这就是Java内存模型中描述的所谓“`线程内表现为串行`的语义”（**注：**栈中的语句是执行的最终结果是一样的：线程不知道使用的对象有什么变化，只关注获取变量的结果。变量也不知道线程对自己做了什么操作，只关注写入的结果。在这之间就是指令重排优化的地方）。

  - 有 volatile修饰的变量，赋值后多执行了一个字节码指令（ `lock add$0x0,(％esp)`）操作，这个操作的作用相当于一个内存屏障（ `Memory Barrier`或 Memory Fence，`指重排序时不能把后面的指令重排序到内存屏障之前的位置`，注意不要与第3章中介绍的垃圾收集器用于捕获变量访问的内存屏障互相混淆）它的作用是将*本处理器*的*缓存*写入了内存，该写入动作也会引起**别的处理器或者别的内核无效化（ Invalidate）其缓存**，*即保证了禁止指令重排，又保证了所有线程的可见*。所以通过这样一个空操作，可让前面 volatile变量的修改对其他处理器立即可见。
    - 那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指处理器采用了`允许将多条指令不按程序规定的顺序分开发`送给各个相应的电路单元进行处理。但并不是说指令任意重排，处理器必须能正确处理指令依赖情况保障程序能得岀正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排—（A+10）*2与A*2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证处理器执行后面依赖到A、B值的操作时能获取正确的A和B值即可。所以在同一个处理器中，重排序过的代码看起来依然是有序的。因此， lock addISOx（0，（％esp）指令把`修改同步到内存时，意味着所有之前的操作都已经执行完成（同步到主内存前，处理器必须计算完成，即满足Java内存操作的第2条规则，处理器内部怎么指令重排不管）`，这样便*形成了“指令重排序无法越过内存屏障”*的效果。

  后续思考：

  <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200916192736.png" alt="image-20200916192727502" style="zoom:33%;" />

#### 对bong和 double型变量的特殊规则

`Java内存模型`要求lock、 unlock、read、load、 assign、use、 store、 write这八种操作都具有原子性，但是对于64位的数据类型（long和 double），在模型中特别定义了一条宽松的规定：允许虚拟机将没有被 volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、 store、read和 write这四个操作的原子性，这就是所谓的“`long和 double的非原子性协定`”（Non- Atomic Treatment of double and long Variables）。

而针对 double类型，由于现代中央处理器中一般都包含专门用于处理浮点数据的浮点运算器（ Floating point unit,FPU），用来专门处理单、双精度的浮点数据，所以哪怕是32位虚拟机中通常也不会岀现非原子性访问的问题，实际测试也证实了这一点。笔者的看法是，在实际开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码时`一般不需要`因为这个原因刻意把用到的long和 double变量专门声明为 volatile。


#### 原子性、可见性与有序性

1. 原子性（ Atomicity）

   - 由Java内存模型来直接保证的原子性变量操作包括read、load、 assign、use、 store和 write这六个。*单线程情况下*，`基本数据类型`的访问、读写都是`具备原子性`的（例外就是ong和 double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。
   - 更大范围的原子性保证（代码块）：Java内存模型还提供了`lock和unlock操作`来满足这种需求，尽管虚拟机未把lock和 unlock操作直接开放给用户使用，但是却提供了更高层次的*字节码指令* `monitorenter`和 `monitorexit`来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块— synchronized关键字，因此在 sy chroniκed块之间的操作也具备原子性。

2. 可见性（ Visibility）
   可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。

   - volatile**：Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性**的，*无论是普通变量还是 volatile变量都是如此*。

     - 普通变量与 volatile变量的区别是， **volatile的特殊规则保证**了新值能**立即同步**到主内存，以及每次使用前**立即**从主内存刷新。因此我们可以说 volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

   - synchronized：同步块的可见性是由“*对一个变量执行 unlock操作之前，必须先把此**变量**同步回主内存中（执行 store、 write操作）*”这条规则获得的

   -  final关键字： final关键字的可见性是指：被 final修饰的字段在构造器中**一旦被初始化完成**，并且构造器没有把“this”的引用传递出去（*this引用逃逸*是一件很危险的事情，其他线程有`可能通过这个引用访问到“初始化了一半”的对象`），那么在**其他线程中就能看见 final字段**的值。如代码所示，变量i与j都具备可见性，它们无须同步就能被其他线程正确访问。

     ```java
     public static final int i;
     public final int i;
     ```

3. 有序性（Ordering）

   Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“**线程内似表现为串行的语义**”（ Within- Thread As- f-Serial Semantics），后半句是指“**指令重排序**ˆ现象和**“工作内存与主内存同步延迟**'现象。

   如下图所示：*时间先后顺序与先行发生原则之间基本没有因果关系*，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，**一切必须以先行发生原则为准**。

   <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200916210147.png" alt="image-20200916210145150" style="zoom:50%;" />
   
   Java语言提供了 volatile和 synchronized两个关键字来保证线程之间操作的有序性， 
   
   - volatile：关键字本身就包含了禁止指令重排序的语义，
   - 而synchronized：是由“*一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的*，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

 synchronized关键字在需要这三种特性的时候都可以作为其中一种的解决方案。看起来很“万能”吧？的确，`绝大部分并发控制操作都能使用 synchronized来完成`。*越“万能”的并发控制，通常会伴随着越大的性能影响*。

#### 先行发生原则

为了程序员不陷入`苦涩难懂的Java内存模型`定义之中，判断数据是否存在竞争，线程是否安全定义了几条简单的规则，叫**“先行发生”（ Happens- Before）**的原则。一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题。（就是之前内存模型定义抽象出来的人话）

如果两个操作之间的关系`不在此列`，`并且无法`从下列规则`推导`出来，则它们就没有顺序性保障，`虚拟机可以对它们随意地进行重排序`，*遵守以下原则就能保证前一个操作是对后一个操作时可见的*。

- *程序次序规则（ Program Order rule）*：**在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作**。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
- `在一个线程内，使用变量前，变量必选赋值完毕`：前边变量assign之后，我后边再进行操作，至于你即时编译期做了什么优化，我不管。
  
- *管程锁定规则（ Monitor lock rule）*：一个 unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“**同一个锁**”，而“后面”是指时间上的先后。由以下2条规则保证：
- （6）：如果对`一个变量执行lock操作，那将会清空工作内存中此变量的值`，在执行引擎*使用这个变量前，需要重新执行load或 assign操作以初始化变量的值*
  - （8）：对一个变量执行 `unlock操作之前，必须先把此变量同步回主内存中`（执行 store、 write操作）
  
- *volatile变量规则（ Volatile variable rule）：*对一个 volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面同样是指时间上的先后。
- **volatile的特殊规则保证**了新值能**立即同步**到主内存，以及每次使用前**立即**从主内存刷新
  
- *线程启动规则（ Thread Start rule）:* Thread对象的 start方法先行发生于此线程的每一个动作
- 主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。
  
- *线程终止规则（ Thread Termination rule）:*线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread::join方法是否结束、 Thread::isAlive()的返回值等手段检测线程是否已经终止执行。
- （2）：不允许一个线程丢弃它最近的 assign操作，即`变量在工作内存中改变了之后必须把该变化同步回主内存`。

- *线程中断规则（ Thread Interruption Rule）:*对线程 `interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生`，可以通过 Thread: interrupted方法检测到是否有中断发生。
- *对象终结规则（ Finalizer rule）:*一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
  - 别还没初始化，就被垃圾回收器消灭了。
- *传递性（ Transitivity）:*如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

使用这些规则去判定操作间是否具备顺序性，对于读写共享变量的操作来说，就是线程是否安全。

### Java与线程

#### 线程的实现

线程是比进程更轻量级的调度执行单位。

线程的引入，可以*把一个进程的资源分配和执行调度分开*

- 各个线程既可以共享进程资源（内存地址、文件IO等），又可以独立调度。

目前*线程是Java里面进行处理器资源调度的最基本单位*。

- 如果日后Loom项目能成功为Java引入纤程（ Fiber）的话，可能就会改变这一点。

主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，**每个已经调用过 start（方法且还未结束的 Jjava. lang. Thread类的实例就代表着一个线程**。

- Java中的线程是线程的一种实现方式。而不是用Java实现的线程。

实现线程主要有三种方式:

- **使用内核线程实现（1:1实现）**：

  内核线程（ Kernel- Level thread，KLT）就是直接由操作系统内核完成线程切换、调度的线程。程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——**轻量级进程**（ LightWeight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，由于*每个轻量级进程都由一个内核线程*支持，因此只有先支持内核线程，才能有轻量级进程。

  - 局限性:首先，由于是基于内核线程实现的，所以*各种线程操作，如创建、析构及同步，都需要进行系统调用*。而`系统调用的代价相对较高`，需要在用户态（ User mode）和内核态（ Kernel mode）中来回切换（就是**轻量级进程LWT**和**内核线程KLT**来回切换）。
- 这两种状态的开销主要来自于**响应中断**、**保护**和**恢复**执行现场的成本。
  - <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200916213213.png" alt="image-20200916213211109" style="zoom: 25%;" />
    - p（用户）：JVM
    - LWP：轻量级进程（类似用户线程）
    - KLT：内核线程
    - ThreadScheduler：操作系统内核用来调度KLT的调度器
    - CPU：操作系统内核将任务从KLT分发给cpu

- `使用用户线程实现（1:N实现）`：

  - 而狭义上的用户线程指的是：完全建立在`用户空间`的线程库上，系统内核不能感知到用户线程的存在及如何实现的。`用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助`。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量。这种进程与用户线程之间1:N的关系称为一对多的线程模型，如图12-4所示。

    用户线程的*优势在于不需要系统内核支援，劣势也在于没有系统内核的支援*，所有的线程操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”·多处理器系统中如何将线程映射到其他处理器上”*这类问题解决起来将会异常困难，甚至有些是不可能实现的*。

  - Java、Ruby等语言都曾经使用过用户线程，最终又都放弃了使用它。但是近年来许多新的、以高并发为卖点的编程语言又普遍支持了用户线程，譬如 `Golanh`、 Erlang等，使得用户线程的使用率有所回升。

    <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200916214636.png" alt="image-20200916214635048" style="zoom: 25%;" />

- `使用用户线程加轻量级进程混合实现（N:M实现）`

  **内核线程和用户线程一起使用**的实现起使用的实现方式，被称为N:M实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的`轻量级进程则作为用户线程和内核线程之间`的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，是N:M的关系，如图12-5所示，这种就是多对多的线程模型。

  <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200916214922.png" alt="image-20200916214920158" style="zoom:25%;" />

##### Java线程的实现

HotSpot，它的`每一个Java线程都是直接映射到一个操作系统原生线程来实现`的，而且中间没有额外的间接结构，所以 `HotSpot自己是不会去干涉线程调度的`（*可以设置线程优先级给操作系统提供调度建议*），全权交给底下的操作系统去处理，所以**何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。**

线程模型只对线程的`并发规模和操作成本产生影响`，对Java程序的编码和运行过程来说，这些差异都是完全透明的。

个人总结：

​	内核线程实现（1:1实现）：好处是简单，`脏活累活都有操作系统干了`，坏处是并发规模受限

   用户线程实现（1:N实现）：操作系统是封装了一个通用的调度方式，你为了提升并发规模，想自定义，那`脏活累活就得自己干`，可能有的地方干的还不如操作系统呢。

   用户线程加轻量级进程混合实现（N:M实现）：属于典型的贪多嚼不烂，这玩意`没有“银弹”`，好处你贪了，两种方式的坏处肯定也带上了。

#### Java线程调度

`线程调度`是指**系统**`为线程分配处理器使用权`的过程，调度主要方式有两种，分别是协同式
（ Cooperative Threads- Scheduling）线程调度和抢占式（ Preemptive Threads- Scheduling）线程调度。

- `协同式线程调度`：*线程的执行时间由线程本身来控制*，线程把自己的工作执行完了之后，要*主动通知系统切换*到另外一个线程上去。
  - **好处：**协同式多线程的最大好处是`实现简单`，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以`一般没有什么线程同步`的问题。Lua语言中的“协同例程”就是这类实现。
  - **坏处：**它的坏处也很明显：`线程执行时间不可控制`，甚至如果一个线程的代码编写有问题，一直`不告知系统进行线程切换`，那么`程序`就会一直`阻塞`在那里。很久以前的 Windows3.x系统就是使用协同式来实现多进程多任务的，那是相当不稳定的，只要有*一个进程坚持不让岀处理器执行时间，就可能会导致整个系统崩溃*。
- `抢占式线程调度`：每个线程将由`系统来分配执行时间`，线程的切换不由线程本身来决定。譬如在Java中，*有 Thread:yield方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么办法的*。
  - **好处：**在这种实现线程调度的方式下，`线程的执行时间是系统可控的`，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。**Java使用的线程调度方式就是抢占式调度**。与前面所说的 Windows3x的例子相对，在 Windows9xNT内核中就是使用抢占式来实现多进程的，当一个进程出了问题，我们还可以使用任务管理器把这个进程杀掉，而不至于导致系统崩溃。
  - **坏处：线程切换不可知，会产生线程安全问题。**

虽然说Java线程调度是系统自动完成的，但是我们仍然可以**"建议"**操作系统给某些线程多分配点执行时间，另外的一些线程则可以少分配一点—这项操作是通过设置线程优先级来完成的。Java语言一共设置了10个级别的线程优先级（ `Thread.MIN_PRIORITY至 Thread.MAX_PRIORITY`）。在两个线程同时处于 Ready状态时，优先级越高的线程越容易被系统选择执行。

Java对应windows优先级神秘代码：`221221`

`线程优先级并不是一项稳定的调节手段`，这不仅仅体现在某些操作系统上不同的优先级实际会变得相同这一点上，还有其他情况让我们`不能过于依赖线`程优先级：

- 优先级可能会被系统自行改变，例如在 Windows系统中存在一个叫“优先级推进器”的功能（ Priority boosting，当然它可以被关掉），大致作用是当*系统发现一个线程被执行得特别频繁时，可能会越过线程优先级去为它分配执行时间，从而减少因为线程频繁切换而带来的性能损耗*。因此，我们并不能在程序中通过优先级来完全准确判断组状态都为 Ready的线程将会先执行哪一个。

#### 状态转换

见**并发**-*Java线程的生命周期*。

### Java与协程

Java语言抽象出来*隐藏了各种操作系统线程差异性的统一线程接口*。语言与框架已经*自动屏蔽了相当多同步和并发的复杂性*，对于普通开发者而言，几乎不需要专门针对多线程进行学习训练就能完成一般的并发任务。但是在**某些场景下，却也已经显现出了疲态**。

#### 内核线程的局限

目前Java线程面临的困境：

今天对Web应用的服务要求，不论是在请求数量上还是在复杂度上，与十多年前相比已不可同日而语，

- `业务量的增长`

- 为了应对业务复杂化而`不断进行的服务细分`

现代BS系统中一次对外部业务请求的响应，往往需要分布在不同机器上的`大量服务共同协作来实现`，这种服务细分的架构在*减少单个服务复杂度、增加复用性的同时，也不可避免地增加了服务的数量，缩短了留给每个服务的响应时间*。这要求**每一个服务都必须在极短的时间内完成计算**，这样组合多个服务的总耗时才不会太长;**也要求每个服务提供者都要能同时处理数量更庞大的请求**，这样才不会出现请求由于某个服务被阻塞而出现等待。



Java目前的并发编程杋制就与上述架构趋势产生了一些矛盾，*1:1的内核线程模型是如今Java虚拟机线程实现的主流选择*，但是这种映射到操作系统上的线程天然的*缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限*。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在*每个请求本身的执行时间变得很短、数量变得很多的前提下用户线程切换的开销甚至可能会接近用于计算本身的开销*，这就会造成严重的浪费。传统的 JJava Web服务器的线程池的容量通常在几十个到两百之间，当程序员把数以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。现实的需求在迫使。

#### 协程的复苏

因为映射到了系统的内核线程中，所以切换调度成本会比较高昂

##### 为什么内核线程调度切换起来成本就要更高？

内核线程的调度成本主要来自于用户态与核心态之间的状态转换，而这两种状态转换的开销主要来自于**响应中断**、**保护**和**恢复执行现场**的成本。

内核线程调度流程：

- 处理器要去执行线程A的程序代码时，并不是仅有代码程序就能跑得起来，*程序是数据与代码的组合体，代码执行时还必须要有上下文数据的支撑*。

  “上下文”：

  - 以**程序员**的角度来看，是*方法调用过程中的各种局部的变量与资源*;
  - 以**线程**的角度来看，是*方法的调用栈中存储的各类信息*;
  - 以**操作系统和硬件**的角度来看，则是**存储在内存、缓存和寄存器中的一个个具体数值**。物理硬件的

- **各种存储设备**和**寄存器**是被操作系统内**所有线程共享的资源**，
- **当中断发生**，从线程A切换到线程B去执行之前，*操作系统首先要把线程A的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到线程B挂起时候的状态*，这样线程B被重新激活后才能仿佛从来没有被挂起过。这种*保护和恢复现场的工作，涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作*。

如果说内核线程的切换开销是来自于保护和恢复现场的成本，那如*果改为采用用户线程，这部分开销就能够省略掉吗？答案是“不能”*。但是，一旦把保护、恢复现场及调度的工作从操作系统交到程序员手上，那我们就可以打开脑洞，通过玩出很多新的花样来缩减这些开销。

有一些古老的操作系统（譬如DOS）是单人单工作业形式的，天生就不支持多线程，自然也不会有多个调用栈这样的基础设施。而早在那样的蛮荒时代，就已经出现了今天被称为`栈纠缠（ StackTwine）`

由用户**自己模拟多线程、自己保护恢复现场的工作模式**。

- 其大致的原理是通过在**内存里给线程划出一片私有额外空间来模拟调用栈**，只要其他“**线程**”中方法**压栈、退栈时遵守规则**，不破坏这片空间即可，这样多段代码执行时就会像相互缠绕着一样，非常形象。

到后来，操作系统开始提供多线程的支持，靠应用自己模拟多线程的做法自然是变少了许多，但也并没有完全消失，而是`演化为用户线程继续存在`。

**用户线程是被设计成协同式调度（ Cooperative Scheduling）的，所以它有了一个别名—“协程”（ Coroutine）**。

- 又由于这时候的协程**会完整地做调用栈的保护、恢复工作**，所以今天也被称为“`有栈协程”（ Stackfull coroutineε）`。
- 与`“无栈协程”（ Stackless coroutine）`区分开。协程本质上是一种*有限状态机，状态保存在闭包里*，自然比有栈协程恢复调用栈要轻量得多。
  - 它的典型应用，即各种语言中的 await、 async、 yield这类关键字。
  - 无栈，但功能也相对更有限协程的**主要优势是轻量**。

无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多。如果进行量化的话，那么如果不显式设置-XsS或XX: Thread Stack size，则在**64位 Linux上 HotSpot的线程栈容量默认是1MB**，此外**内核数据结构（ Kernel data structures）还会额外消耗16KB内存**。

与之相对的，**一个协程的栈通常在几百个字节到几KB之间**，所以*Java虚拟机里线程池容量达到两百就已经不算小了，而很多支持协程的应用中，同时并存的协程数量可数以十万计*。

- 协程当然也有它的局限，需要在`应用层面实现的内容（调用栈、调度器这些）特别多`，这个缺点就不赘述了。
- 除此之外，协程在最初，甚至在今天很多语言和框架中会被**设计成协同式调度**，这样在语言运行平台或者框架上的调度器就可以做得非常简单。
- 不过有不少资料上显示，既然取了“协程‘这样的名字，它们之间就一定以协同调度的方式工作。笔者并没有査证到这种“规定”的出处，只能说这种提法在今天太过狭隘了，**非协同式、可自定义调度的协程的例子并不少见**。

具体到Java语言，还会有一些别的限制，譬如 Hot spot这样的虚拟机**，Java调用栈跟本地调用栈是做在一起的**。

- 如果在协程中**调用了本地方法**，还**能否正常切换**协程而不影响整个线程？
- 如果协程中**遇传统的线程冋步措施会怎样**？
  - 譬如`Kotlin`提供的协程实现，一旦遭遇 `synchronize`关键字，那**挂起来的仍将是整个线程**。

#### Java的解决方案

对于*有栈协程，有一种特例实现名为纤程（ Fiber）*，这个词最早是来自微软公司，后来微软还推出过系统层面的纤程包来方便应用做现场保存、恢复和纤程调度。

 OpenJDK在2018年创建了[Loom项目](https://zhuanlan.zhihu.com/p/96874807)，这是Java用来`应内核线程的局限`而提出的`官方解决方案`。日后该项目为Java语言引入的、*与现在线程模型平行的新并发编程机制*。

从 Oracle官方对“什么是纤程”的解释里可以看出，它就是一种`典型的有栈协程`。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200918093353.png" alt="image-20200918093351662" style="zoom:33%;" />

Loom项目背后的意图是`重新提供对用户线程的支持`，这些新功能*不是为了取代当前基于操作系统的线程实现，而是会有两个并发编程模型在Java虚拟机中并存*，可以在程序中同时使用。

新模型有意地*保持了与目前线程模型相似的API设计*，它们甚至可以拥有一个共同的基类，这样现有的代码就*不需要为了使用纤程而进行过多改动，甚至不需要知道背后釆用了哪个并发编程模型*。

Loom团队在 JVMLS2018大会上公布了他们对Jetty基于纤程改造后的测试结果，同样在5000QPS的压力下，

- 以**容量为400的线程池的传统模式**：请求响应延迟在10000至20000毫秒之间。
- **每个请求配以一个纤程的新并发处理模式**：延迟普遍在200毫秒以下。

![image-20200918093902470](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200918093903.png)



**同等的机器下，请求的延迟变短，意味着能支持更大的并发。那省出来的机器就是创造的价值。**



在新并发模型下，一段使用纤程并发的代码会被分为两部分—执行过程（ Continuation）和调度器（ Scheduler）。

- **执行过程**主要用于*维护执行现场，保护、恢复上下文状态*
- **调度器**则*负责编排所有要执行的代码的顺序*。

将**调度程序与执行过程分离的好处**是，*用户可以选择自行控制其中的一个或者多个*，而且Java中现有的调度器也可以被直接重用。事实上，*Loom中默认的调度器就是原来已存在的用于任务分解的 Fork/Join池*（JDK7中加入的 ForkJoinPool）。

Loom项目目前仍然在进行当中，还没有明确的发布日期，上面笔者介绍的内容日后都有被改动的可能。如果读者现在就想尝试协程，那可以在项目中使用 Quasar协程库口，这是一个不依赖Java虚拟杋的独立实现的协程库。**不依赖虚拟机来实现协程**是完全可能的， Kotlin语言的协程就已经证明了这一点。 Quasar的实现*原理是字节码注入，在字节码层面对当前被调用函数中的所有局部变量进行保存和恢复*。这种不依赖Java虚拟杋的现场保护虽然能够工作，但很影响性能，对即时编译器的干扰也非常大，而且必须要求用户手动标注每一个函数是否会在协程上下文被调用，这些都是未来Loom项目要解决的问题。

### 线程安全

#### 面向过程与面向对象

在软件业发展的初期，程序编写都是*以算法为核心*的，程序员会*把数据和过程分别作为独立的部分来考虑*，`数据代表问题空间中的客体，程序代码则用于处理这些数据`，这种思维方式**直接站在计算机的角度去抽象问题和解决问题**，被称为**面向过程的编程思想**。

与此相对，**面向对象**的编程思想则站`在现实世界的角度去抽象和解决问题，它把数据和行为都看作对象的一部分`，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。

面向对象的编程思想极大地提升了现代软件开发的效率和软件可以达到的规模，但是现实世界与计算机世界之间不可避免地存在一些差异。

- 例如，人们很难想象现实中的对象在一项工作进行期间，会被不停地中断和切换，对象的属性（数据）可能会在中断期间被修改和变脏，而这些事件在计算机世界中是再普通不过的事情。有时候，*良好的设计原则不得不向现实做出一些妥协，我们必须保证程序在计算机中正确无误地运行*，**然后再考虑如何将代码组织得更好，让程序运行得更快**。

高效并发：`首先`需要`保证并发的正确性`，`然后`在此基础上`来实现髙效`。本章就先从如何保证并发的正确性及如何实现线程安全说起。

#### Java语言中的线程安全

按照线程安全的“安全程度”由强至弱来排序，我们山可以将Java语言中各种操作共享的数据分为以下五类:

`不可变 < 绝对线程安全 < 相对线程安全 < 线程兼容 < 线程对立`

##### 1.不可变

在Java语言里面（*特指JDK5以后，即Java内存模型被修正之后的Java语言*），**不可变（ Immutable）的对象一定是线程安全**的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。

只要一个不可变的对象**被正确地构建出来**（`即没有发生this引用逃逸的情况`），那其*外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态*。“不可变”带来的安全性是最直接、最纯粹的。



Java语言中，如果多线程共享的数据是一个**基本数据类型**，那么只要在**定义时使用 final关键字修饰它就可以保证它是不可变的**。

如果*共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持*，那就需要`对象自行保证其行为不会对其状态产生任何影响才行`。

- 不妨类比 java.lang.String类的对象实例，它是一个典型的不可变对象，用户调用它的subString()、 replace()和 concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象保证对象行为不影响自己状态的途径:

创建不可变对象：

1. 

在Java类库AP中符合不可变要求的类型：

- `String`
- `枚举`类型
- `java.lang.Number的部分子类`，如`Long`和 `Double`等数值包装类型、`Biglnteger`和 `BigDecimal`等大数据类型。

*但同为 Number子类型的原子类 Atomiclnteger和 AtomicLong则是可变的*，不妨看看这两个原子类的源码，想一想为什么它们要设计成可变的。

##### 绝对线程安全

`绝对的线程安全`能够完全满足 Brian goetz给出的线程安全的定义：

一个类要达到“*不管运行时环境如何，调用者都不需要任何额外的同步措施*”可能需要付出非常高昂的甚至不切实际的代价。

在 Java aPI中标注自己是线程安全的类，大多数都不是绝对的线程安全。

如果说java.util.Vector是一个线程安全的容器，即使它所有的方法都被修饰成 synchronized，也不意味着调用它的时候就永远都不再需要同步手段了。

- 调用对象的方法是绝对线程安全的，但两个方法中间的间隔不是线程安全的。

假如 Vector定要做到绝对的线程安全，那就*必须在它内部维护一组一致性的快照访问*才行，每次对其中元素进行改动都要产生新的快照，这样要付出的时间和空间成本都是非常大的。

##### 相对线程安全

`相对线程安全`就是我们*通常意义上所讲的线程安全*，它需要保证对这个*对象单次的操作是线程安全*的，我们在调用的时候不需要进行额外的保障措施，但是对于*一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性*。

在Java语言中，大部分声称线程安全的类都属于这种类型，例如`Ⅴector`、 `HashTable`、 `Collections的synchronizedCollection（）方法包装`的集合等

##### 线程兼容

`线程兼容`是指*对象本身并不是线程安全*的，但是可以通过在*调用端正确地使用同步手段*来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，通常就是指这种情况。

Java类库APP中大部分的类都是线程兼容的，*如与前面的Ⅴector和 Hashtable相对应的集合类 Array list和HashMap等*。

##### 线程对立

`线程对立`是指*不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码*。

由于Java语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的，而且*通常都是有害的，应当尽量避免*。

一个线程对立的例子是 Thread类的 suspend和 resumed方法。

- 如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在死锁风险——假如 *suspend中断的线程就是即将要执行 resumed的那个线程，那就肯定要产生死锁了*。也正是这个原因， suspend()和 resumed方法都已经被声明废弃了。
- 常见的线程对立的操作还有 System.setIn()、 Sytem.setOut()和 System.runFinalizersOn Exit()等。
  - 如果程序调用了System.runFinalizerOnExit(true);，那么JVM会对所有的还未结束的对象调用Finalizer。

#### 线程安全的实现方法

如何实现线程安全与代码编写有很大的关系，但虚拟机提供的同步和锁机制也起到了至关重要的作用。

##### 1.互斥同步

`互斥同步（ Mutual exclusion＆ Sy nchronization）`是一种最常见也是最主要的并发正确性保障手段。*同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用*。

而互斥是实现同步的一种手段

- 临界区（ Critical section）
- 互斥量（ Mutex）
- 信号量（ Semaphore）都是常见的互斥实现方式。

因此在“互斥同步”这四个字里面，**互斥是因，同步是果;互斥是方法，同步是目的**。

在Java里面，最基本的互斥同步手段就是 `synchronized`关键字，是一种块结构的同步语法。 synchronized关键字`经过 Javac编译之后`，会在同步块的前后分别形成`monitorenter`和 `monitorexit`这两个字节码指令。这两个字节码指令都需要一个 `reference类型`的参数来指明要锁定和解锁的对象。

- 如果Java源码中的 sy nchronized明确指定了对象参数，那就以这个对象的引用作为 reference;
- 如果没有明确指定，那将根据 synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的 class对象来作为线程要持有的锁。

两个synchronized的直接推论：

- 被 synchronized修饰的同步块对同一条线程来说是**可重入**的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。

- 被 synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。
  - 这意味着无法像处理某些数据库中的锁那样，**强制已获取锁的线程释放锁**;也无法强制正在等待锁的线程中断等待或超时退出。

从执行成本的角度看，持有锁是一个重量级（ Heavy- Weight）的操作。

- Java的线程是**映射到操作系统的原生内核线程**之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入**用户态到核心态的转换中**，进行这种状态转换需要耗费很多的处理器时间。*如果代码特别简单状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。*

自JDK 5起（实现了JSR 166[1]），Java类库中新提供了java.util.concurrent包（下文称J.U.C包），其中的 java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够 `以非块结构（Non-Block Structured）来实现互斥同步`，从而摆脱了语言特性的束缚，改为在类库层面 去实现同步，这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔 的空间。
       ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：

- `等待可中断：`是指当持有锁的线程长期不释放锁的时候，*正在等待的线程可以选择放弃等待*，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。 
- 公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁
  - synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平 锁。*不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量*。
- 锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。

当JDK 6中加入了大量针对 synchronized锁的优化措施（下一节我们就会讲解这些优化措施）之后，相同的测试中就发现 synchronized与ReentrantLock的性能基本上能够持平。


			根据上面的讨论，ReentrantLock在功能上是synchronized的超集，在性能上又至少不会弱于
synchronized，那synchronized修饰符是否应该被直接抛弃，不再使用了呢？当然不是

- `synchronized`是在Java语法层面的同步，`足够清晰，也足够简单`。
- *Lock应该确保在finally块中释放锁*，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确 保即使出现异常，锁也能被自动释放。
- 从长远来看，*Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象 的元数据中记录synchronized中锁的相关信息*，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。

##### 2.非阻塞同步

**互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销**，因此这种同步也被称为阻塞同步（Blocking Synchronization）。互斥同步属于一种悲观的并发策略，将会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。

随着硬件指令集的发展，非阻塞同步：**基于冲突检测的乐观并发策略**。

- 不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；

- 如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现 没有竞争的共享数据为止。

使用乐观并发策略需要“`硬件指令集的发展`”？

因为我们必须`要求操作和冲突检测这两个步骤具备原子性`。靠什么来保证原子性？如果这里再使用互斥同步来保证就完全失去意义了，所 以我们只能靠硬件来实现这件事情，硬件保证某些从语义上看起来需要多次操作的行为可以只通过一 条处理器指令就能完成，这类指令常用的有：

- 测试并设置（Test-and-Set）； 
- 获取并增加（Fetch-and-Increment）； 
- 交换（Swap）； 
- **比较并交换（Compare-and-Swap，下文称CAS）；** 
- 加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）。

CAS指令需要有三个操作数:

- 分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V
  表示）
- 旧的预期值（用A表示）
- 准备设置的新值（用B表示）。

CAS指令执行时，`当且仅当V符合 A时，处理器才会用B更新V的值，否则它就不执行更新`。但是，`不管是否更新了V的值，都会返回V的 旧值`，上述的处理过程是一个`原子操作`，执行期间不会被其他线程中断。

在JDK 5之后，*Java类库中才开始使用CAS操作*，该操作由`sun.misc.Unsafe类`里面的
`compareAndSwapInt()`和`compareAndSwapLong()`等几个方法包装提供。

- HotSpot虚拟机在内部对这些方 法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程， 或者可以认为是无条件内联进去了[5]。

- 不过由于*Unsafe类*在设计上就*不是提供给用户程序调用的类* （Unsafe::getUnsafe()的代码中限制了*只有启动类加载器（Bootstrap ClassLoader）加载的Class才能访问它*）
  - 在JDK 9之前只有Java类库可以使用CAS，譬如J.U.C包里面的整数原子类，其中的 `compareAndSet()`和`getAndIncrement()`等方法*都使用了Unsafe类的CAS操作来实现*。
  - 如果用户程序也有使用CAS操作的需求，那要么`就采用反射手段突破Unsafe的访问限制`，要么就只能通过Java类库API来间接使用它。
  - 直到`JDK 9之后`，Java类库才在`VarHandle类`里开放了面向用户程序使用的`CAS操作`。

20 个线程自增10000次的操作来证明volatile变量不具备原子性，那么如何才能让它具备原子性呢？

```java
public static AtomicInteger race = new AtomicInteger(0)
```

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200919212505.png" alt="image-20200919212504170" style="zoom:50%;" />

incrementAndGet()自增方法的原子性：

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200919212649.png" alt="image-20200919212647738" style="zoom:50%;" />

incrementAndGet()方法在`一个无限循环中`，不断尝试将`一个比当前值大一的新值赋值给自己`。如果失败了，那说明在执行CAS操作的时候，旧值已经发生改变，于是再次循环进行下一次操作，`直到设置成功为止`。
       CAS存在一个逻辑漏洞：如果一个变量V初次读取的时候是A 值，并且在准备赋值的时候检查到它仍然为A值，那就能说明它的值没有被其他线程改变过了吗？

这是不能的，因为如果在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从 来没有被改变过。这个漏洞称`为CAS操作的“ABA问题”`。

- J.U.C包为了解决这个问题，提供了一个带有标记的`原子引用类AtomicStampedReference`，它可以*通过控制变量值的版本来保证CAS的正确性*。
- 不过 目前来说这个类处于相当鸡肋的位置，大部分情况下`ABA问题不会影响程序并发`的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更为高效。

##### 3.无同步方案

**同步只是保障存在共享数据争用时正确性的手段**，如果能让一个方法本来就**不涉及共享数据**，那它自然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的。

其中的两类。

1. **可重入代码（Reentrant Code）**：这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不 会出现任何错误，也不会对结果有所影响。
   可重入代码有一些共同的特征

   - 不依赖全局变量
   - 存储在堆上的数据
   - 公用的系统资源，
   - 用到的状态量都由参数中传入，
   - 不调用非可重入的方法等。

   我们可以通过一个比较简单的原则来判断代码是否具备可重入性：*如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的*。

2. **线程本地存储（Thread Local Storage）**：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些*共享数据的代码是否能保证在同一个线程中执行*。如果**能**保证，我们就可以**把共享数据的可见范围限制在同一个线程之**内，这样，无须同步也能保证线程之间不出现数据争用的问题。

   - 大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中 的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以**使用线程本地存储来解决线程安全问题**。
   - Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字将它声明为“易变的”；如果**一个变量只要被某个线程独享**，我们还是可以通过**java.lang.ThreadLocal类来实现线程本地存储的功能**。
     
     - 每一个线程的`Thread对象中都有一个ThreadLocalMap对象`
     
     - 这个对象存储了一组`以ThreadLocal.threadLocalHashCode为键`，`以本地线程变量为值`的K-V值对
     
     - `ThreadLocal对象`就是当前线程的ThreadLocalMap的`访问入口`，`每一个 ThreadLocal对象`都包含了一个独一无二的`threadLocalHashCode`值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。详见**并发 ThreadLocal**
     
       ```java
       private final int threadLocalHashCode = nextHashCode();
       ```
     
       - threadLocalHashCode：用AtomicInteger的getAndAdd方法
     
       - ```java
         unsafe.getAndAddInt()
         ```



### 锁优化

高效并发是从JDK 5`升级到JDK 6`后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量的资源去实现`各种锁优化技术`，如*适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）等*，这些技术都是**为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率**。

![interview-12-05](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200920105918.png)



偏向锁CAS操作：操作前线测试下对象头中是否存储着当前线程ID。存在直接进入同步块

	1. 比较：判断存储指针的位置是否为空
 	2. 交换：为空，就将当前线程ID填入对象头中

轻量级锁加锁CAS操作：

	1. 比较：和拷贝到栈中的锁记录比较，看是否一致
 	2. 交换：将对象头中的MarkWord 替换成指向当前线程锁记录的指针

释放轻量锁CAS操作：

1. 比较：比较对象头中和自己栈中锁记录的指针 
2. 交换：把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来



<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200921145238.png" alt="image-20200921145228497" style="zoom:50%;" />

#### 自旋锁与自适应自旋 

互斥同步对`性能最大的影响是阻塞的实现`，*挂起线程和恢复线程的操作都需要转入内核态中完成*，这些操作给Java虚拟机的并发性能带来了很大的压力。

许多应用上，共享数据的*锁定状态只会持续很短的一段时间*，为了这段时间去挂起和恢复线程并不值得。

现在绝大多数的个人电脑和服务器都是多路（核）处理器系 统，如果物理机器有一个以上的处理器或者处理器核心，能让`两个或以上的线程同时并行执行`，我们 就可以让后面请求锁的那个线程“`稍等一会`”，但`不放弃处理器的执行时间`，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让`线程执行一个忙循环（自旋）`，这项技术就是`所谓的自旋锁`。

自旋等待本身虽然**避免了线程切换的开销**，但它是要**占用处理器时间**的，所以如果锁被占用的时间很**短**，自旋等待的**效果就会非常好**，反之如果锁**被占用**的时间很**长**，那么自旋的线程只会白白**消耗处理器资源**，而不会做任何有价值的工作，这就会带来性能的浪费。

因此自旋等待的时间**必须有一定的限度**，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的**默认值是十次**，用户也可以使用参数-XX：PreBlockSpin来自行更改。
		不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。在*JDK 6中对自旋锁的优化，引入了自适应的自旋*。

自适应意味着自旋的时间不再是固定的了，而是由**前一次在同一个锁上的自旋时间**及**锁的拥有者的状态**来决定的。

- 如果在同一个锁对象上，自旋等待*刚刚成功获得过锁*，*并且持有锁的线程正在运行中*，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许*自旋等待持续相对更长*的时间，比如持续100次忙循环。
- 另一方面，如果对于某个锁，*自旋很少成功获得过锁*，那在以后要获取这个锁时将有可能*直接省略掉自旋过程*，以避免浪费处理器资 源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况 预测就会越来越精准，虚拟机就会变得越来越“聪明”了。

#### 锁消除 

锁消除是指虚拟机`即时编译器在运行时`，对一些代码要求同步，但是对`被检测到不可能存在共享数据竞争的锁进行消除`。

锁消除的**主要判定依据来源于逃逸分析的数据支持**，

如果判断到一段代码中，*在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行*。
		有许多同步措施并不是程序员自己加入的，

例子：

```java
public String concatString(String s1, String s2, String s3) { 
	return s1 + s2 + s3;
}
```

JDK5之前用的是线程安全的StringBuffer.append()方法拼接的资产，锁的是方法内部的sb对象。会被消除。

JDK6版本开始会转化为非线程安全的`StringBuilder`来完成字符串拼接，并不会加锁。

#### 锁粗化 

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。

大多数情况下，上面的原则都是正确的，但是*如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导 致不必要的性能损耗。*
如果虚拟机探测到有这样**一串零碎的操作都对同一个对象加锁**，将会把加锁同步的**范围扩展（粗化）到整个操作序列的外部**，这样**只需要加锁一次**就可 以了。

#### 轻量级锁 

轻量级锁是*JDK 6时加入的新型锁机制*，它名字中的“轻量级”是相对于使用*操作系统互斥量来实现的传统锁而言*的，因此传统的锁机制就被称为“重量级”锁。

不过，需要强调一点，**轻量级锁并不是用来代替重量级锁的**，它设计的初衷是在没有多线程竞争的前提下，**减少传统的重量级锁使用**操作系统互斥量产生的性能消耗。
		要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须要对HotSpot虚拟机*对象的内存布局（尤其是对象头部分）*有所了解。

HotSpot虚拟机的对象头（Object Header）分为两部分，

- 第一部分用于`存储对象自身的运行时数据`，如哈希码（HashCode）、GC分代年龄（Generational GC Age） 等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“Mark Word”。这部分是**实现轻量级锁和偏向锁的关键**。
- 另外一部分用于**存储指向方法区对象类型数据的指针**，如果是**数组对象**，还会有一个额外的部分**用于存储数组长度**。这些对象内存布局的详细内容，我 们已经在第2章中学习过，在此不再赘述，只针对锁的角度做进一步细化。

由于*对象头信息是与对象自身定义的数据无关的额外存储成本*，考虑到Java虚拟机的空间使用效率，MarkWord被设计成一个**非固定的动态数据结构**，以便在极小的空间内存储尽量多的信息。它会 根据对象的状态复用自己的存储空间。

- 在`32位的HotSpot虚拟机`中对象头MarkWord

  ![image-20200920114408517](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200920114411.png)

  <img src="https://img-blog.csdnimg.cn/20190612142936955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

- 在`64位的HotSpot虚拟机`中[对象头MarkWord](https://blog.csdn.net/zhanglong_4444/article/details/91492985)

  ![image-20200920114543756](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200920114545.png)

  - 注：Epoch：保存偏向时间戳
  - cms_free：是CMS垃圾收集器用的

​    <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200921145320.png" alt="image-20200921145316745" style="zoom:50%;" />



##### 轻量级锁工作过程：

在代码即将进入同步块的时候，如果此同步对象`没有被锁定`（锁标志位为`“01”`状态），虚拟机首先将在`当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间`，用于**存储**锁对象目前的**Mark Word的拷贝**（官方为 这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图13-3所示。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200920134451.png" alt="image-20200920134449331" style="zoom: 25%;" />

然后，虚拟机将*使用CAS操作*`尝试`*把对象的Mark Word更新为指向Lock Record的指针*。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的 最后两个比特）将`转变为“00”`，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如 图13-4所示。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200920135042.png" alt="image-20200920135040944" style="zoom:25%;" />

如果这个**更新操作失败**了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。

- 虚拟机首先会**检查对象的Mark Word是否指向当前线程的栈帧**，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，
- 否则就说明这个锁对象**已经被其他线程抢占了**。如果出现*两条以上的线程争用同一个锁*的情况，那轻量级锁就不再有效，必须要**膨胀为重量级锁**，锁标志 的状态值变为`“10”`，此时Mark Word中存储的就是**指向重量级锁（互斥量）的指针**，后*面等待锁的线程也必须进入阻塞状态*。



##### 解锁过程

也同样是通过CAS操作来进行的，

- 如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。
  - 假如能够`成功替换`，那整个同步过程就`顺利完成`了；
  - 如果`替换失败`，则说明有*其他线程尝试过获取该锁，并且获取锁失败了，膨胀成重量级锁了*。需要就要在释放锁的同时，唤醒被挂起的线程。

轻量级锁能提升程序同步性能的依据是“*对于绝大部分的锁，在整个同步周期内都是不存在竞争*
*的*”这一经验法则（**非阻塞同步：乐观并发策略**）。

- 如果`没有竞争`，轻量级锁便通过CAS操作成功`避免了使用互斥量的开销`；
- 但如果确 `实存在锁竞争`，`除了互斥量的本身开销外`，还`额外发生了CAS操作的开销`。因此在**有竞争的情况下， 轻量级锁反而会比传统的重量级锁更慢**。

#### 偏向锁 

偏向锁也是*JDK 6中引入的一项锁优化措施*，它的目的是`消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能`。

如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那**偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了**。
		偏向锁中的“偏”，就是**偏心的“偏”**、偏袒的“偏”。

它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，*该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步*。如果读者理解了前面轻量级锁中关于对象头Mark Word与线程之间的操作过程，那偏向锁的原理就会很容易理解。

假设当前虚拟机启用了偏向锁（启用参数-XX：+UseBiased Locking，这是自JDK 6 起HotSpot虚拟机的默认值），那么

- 当锁对象`第一次被线程获取的时候`，虚拟机将会把对象头中的`标志位设置为“01”`、`把偏向模式设置为“1”`，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程 的ID记录在对象的Mark Word之中。
- 如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时（），虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作 等）。

一旦出现`另外一个线程去尝试获取这个锁`的情况，`偏向模式就马上宣告结束`。

根据锁*对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），*

撤销后标志位恢复到`未锁定（标志位 为“01”）`或`轻量级锁定（标志位为“00”）的状态`，后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图13-5所示。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200920142325.png" alt="image-20200920142321830" style="zoom:25%;" />

当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原 来对象的哈希码怎么办呢？

- `在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变`（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的*Object::hashCode()方法，返回的是对象的一致性哈希 码（Identity Hash Code）*，这个值是*能强制保证不变的*，它通过`在对象头中存储计算结果来保证第一 次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。`
- 因此，当一个对象*已经计算过一 致性哈希码后，它就再也无法进入偏向锁状态了*；而当一个对象当前正处于偏向锁状态，*又收到需要计算其一致性哈希码请求（这里说的计算请求应来自于对Object::hashCode()或者System::identityHashCode(Object)方法的 调用，如果重写了对象的hashCode()方法，计算哈希码时并不会产生这里所说的请求）时*，它的**偏向状态会被立即撤销，并且锁会膨胀为重量级锁**。
  - 在**重量级锁的实现**中，对象头指向了重量级锁的位置，代表**重量级锁的ObjectMonitor类**里`有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码`。

**偏向锁可以提高带有同步但无竞争的程序性能**，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果**程序中大多数的锁都总是被多个不同的线程访 问，那偏向模式就是多余的**。在具体问题具体分析的前提下，有时候使用参数-XX：UseBiasedLocking来禁止偏向锁优化反而可以提升性能。

### 如何确定垃圾？

引用计数法

在为对象添加一个引用时，引用计数加 1；在为对象删除一个引用时，引进计数减1；如果一个对象的引用计数为 0，则表示此刻该对象没有被引用，可以被回收。

容易产生循环引用的问题，即互为引用，引用计数一直为1。

![image-20200910215537317](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910215539.png)

![image-20200911165721598](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911165730.png)

可达性分析通过根搜索算法（GC Roots Tracing）来实现。

首先定义GC Roots对象，以`GC Roots对象作为起点`根据`引用关系`向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡，但不可达对象要经过至少两次标记才能判定其是否可以被回收。

根搜索算法主要针对栈中的引用、方法区中的静态引用和JNI中的引用展开分析。

#### Java中哪些是GC Root是对象？

在Java技术体系里面，固定可作为 GC Roots的对象包括以下几种：

- 在虚拟机栈（`栈帧中的本地变量表`）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的`参数、局部变量、临时变量`等。

- 在`方法区中类静态属性引用的对象`，譬如Java类的`引用类型静态变量`。

- 在`方法区中常量引用的对象`，譬如`字符串常量池`（ String Table）里的引用。

- 在本地方法栈中JNⅠ（即通常所说的 Native方法）引用的对象。

- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些`常驻的异常对象`（比如NullPointExcepiton、 OutOfMemoryError）等，还有`系统类加载器`。

- 所有`被同步锁`（ synchronized关键字）`持有的对象`

- 反映Java虚拟机内部情况的JMⅹBean、JMTI中注册的回调、本地代码缓存等。

  除了这些固定的 GC Roots集合以外，根据`用户所选用的垃圾收集器以及当前回收的内存区域不同`，还可以有其他对象“`临时性`”地加入，共同构成完整 GC Roots集合。

  譬如后文将会提到的分代收集和局部回收（ Partial gc），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到`内存区域`是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更`不是孤立封闭`的，所以`某个区域里的对象完全有可能被位于堆中其他区域的对象所引用`，这时候就需要将这些关联区域的对象也一并加GC Roots集合中去，才能保证可达性分析的正确性

  目前最新的几款垃圾收集器(OpenJDK中的G1、 Shenandoah、ZGC),无一例外都具备了局部回收的特征，为了避免 GC Roots包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。

#### Java中的四种引用类型

在Java中一切皆对象，对象的操作是通过该对象的引用（Reference）实现的，Java中的引用类型有4种，分别为强引用、软引用、弱引用和虚引用。

- 强引用：最传统的引用定义，值代码之中普遍存在的引用赋值。在把`一个对象赋给一个引用变量即 new`时，这个引用变量就是一个`强引用`。有强引用的对象定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成Java内存泄漏（ Memory link）的主要原因。
  - 定义：如果 reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference数据是代表某块内存、某个对象的引用。
- 软引用：描述一些还有用，但非必须的对象。如果一个对象`只有软引用`，在系统将要发生`内存溢出异常前`，会把这些对象`列进回收范围`之中进行第`二次回收`，如果这次回收还没有足够的内存，才会抛出内存溢出异常。软引用通过 SoftReference类实现
- 弱引用：描述一些非必须的对象，如果一个对象只有弱引用，则在`垃圾回收过程中一定会`被回收。弱引用通过 WeakReference类实现。
- 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也`无法`通过虚引用来`取得一个对象实例`。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器`回收时收到一个系统通知`。`虚引用和引用队列联合使用`，主要用于跟踪对象的垃圾回收状态。虚引用通过 PhantomReference类实现

#### 对象真正死亡？

真正宣告一个对象死亡，至少要经历两次标记，一次可达性分析标记，一次在判定有必要执行 finalized方法判定后，放入F- Queue中等待Finalizer线程去执行，之后收集器将对F- Queue中的对象进行第二次小规模的标记。：

- 如果对象在进行可达性分析后发现`没有与 GC Roots`相连接的`引用链`，那它将会被第一次标记，
- 随后`进行一次筛选`，筛选的条件是此对象是否有必要执行 finalized方法。假如对象没有覆盖 finalized方法，或者 finalize方法已经被虚拟机调用过，那这个对象就死了。
- 如果这个对象被判定为确`有必要执行 finalized方法`，那么该对象将会被放置在一个名为`F- Queue的队列`之中，并在稍后由一条由虚拟机自动建立的、`低调度优先级`的 `Finalizer线程去执行`它们的 finalized方法。这里所说的“执行”是指虚拟机会`触发`这个方法开始`运行`，但并`不承诺`一定会`等待`它运行`结束`。这样做的原因是，如果某个对象的 finalize方法`执行缓慢`，或者更极端地发生了`死循环`，将很可能导致F- Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。
- finalized方法是对象逃脱死亡命运的最后一次机会，`稍后收集器将对F- Queue中的对象进行第二次小规模的标记`，如果对象要在 finalized中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，`譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量`，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。
  - 注：但也`不是百分百成功`，因为不知道收集器啥时候来遍历F-Queue，所以不能做关闭资源的操作。 而且finalize方法只能被系统调用一次。


#### 方法区垃圾回收

虽然方法区垃圾回收性价比低，回收的判断条件苛刻，但是在大量使用反射、动态代理、 CGLib等`动态生成字节码`的框架，动态生成JSP以及OSGi这类`频繁自定乂类加载器`的场景中，通常都需要Java虚拟机`具备类型卸载`的能力，以保证不会对方法区造成过大的内存压力。

方法区的垃圾收集主要回收两部分内容

- `废弃`的常量：回收常量池中的字面量，接口、方法、字段的符号引用等。
  
  - `字面量：`假如一个字符串“java曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经`没有任何字符串对象引用`常量池中的“java常量，且虚拟机中`也没有其他地方引用`这个字面量。如果JVM判断`有必要的话会进行回收`。
- `不再使用的类型`：判断一个类是否属于不再使用的类，需满足以下三个条件。
  - 该类`所有的实例`都已经`被回收`，也就是Java堆中不存在该类及其任何派生子类的实例。
  
  - `加载该类的类加载器已经被回收`，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
  
  - 该类对应的 `java. lang.Class`对象没有在任何地方被引用，无法在任何地方通过`反射`访问该类的方。
  
    注：Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“`被允许`”，而`并不是和对象一样，没有引用了就必然会回收`。关于是否要对类型进行回收， Hot spot虚拟机提供了Xnoclassgc参数进行控制。



### 垃圾回收算法？

垃圾回收算法，始于分带收集理论。

而分带收集理论建立在两个分代假说之上：绝大多数对象都是朝生夕灭的，熬过越多次垃圾收集过程的对象就越难以消亡。

这两个假说奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

将大多数对象都是朝生夕灭对象集中放在一起，每次回收时`只关注如何保留少量存活`，而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间。

如果剩下的都是`难以消亡`的对象，那把它们集中放在一块，虚拟机便可以使用`较低的频率`来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

`划分出不同的区域之后`，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——才有了“ MinorGC MajorGC Full Go”这样的`回收类型的划分`；

也才能够`针对不同的区域安排与里面存储对象存亡特征相匹配`的垃圾收集算法。



但分带收集不是简单的划分内存，对象存在跨代引用。在新生代用数据结构标识出老年代哪些地方存在跨代引用。MinorGC时将其加入到GC Roots扫描。



通常能单独发生收集行为的只是新生代，所以这里“反过来”的情况只是理论上允许，实际上除了CMS收集器，其他都不存在只针对老年代的收集。

分代收集算法根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代和老年代。

- `新生代：`主要存放新生成的对象，其特点是对象数量多，但是小而且生命周期短，采用复制算法。
- `老年代：`主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。采用标记清楚。

Jaa中常用的垃圾回收算法有

- `标记-清除算法：`执行效率随内存增长而降低，内存碎片化。

- `标记-复制算法：`将内存分为两块，每次只使用一块，用完后，将存活对象复制到另一块，已用过的内存，一次性清理掉。

  内存清理销量高，且易于实现，并且没有空间碎片 。

  但由于同一时刻只有一个内存区域可用，因此存在大量的内存浪费。但如果有大量长时间存活的对象时，这些对象的来回复制也会影响系统的运行效率。因此，该算法只在对象为“朝生夕死”状态时运行效率较高。

  优化：因为98%的对象熬不过第一轮垃圾收集。为了针对空间浪费情况，设计出Eden，和两个survivor，为8:1:1，这样只浪费了10%。并提供了分配担保机制，如果存活大于10%，这些对象讲直接进入老年代。不能用在老年代的原因：存活率较高时，复制效率低，并且需要分配担保。

- `标记-整理算法：`标记整理算法结合了标记清除算法和复制算法的优点，其标记阶段和标记清除算法的标记阶段相同，在标记完成后将存活的对象移到内存的另一端，然后清除该端的对象并释放内存。但标记整理是一种移动式的回收算法，在老年代这种大量存活对象的区域，移动对象并更新所有引用这些对象的地方将是极为负重的操作，并且移动时需要暂停用户应用程序（STW）。

#### 分代收集算法和分区收集算法

  - 分代收集算法：JVM根据对象存活周期的不同将内存划分为新生代、老年代和永久代，并根据各年代的特点分别采用不同的GC算法。
    - `新生代：`主要存放新生成的对象，其特点是对象数量多，但是小而且生命周期短，采用复制算法。
    - `老年代：`主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。采用标记清楚。
  - 分区收集算法：分区算法将整个堆空间`划分为连续的大小不同的小区域`，对每个小区域都`单独进行内存使用和垃圾回收`，这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。
    分区收集算法可以根据系统可接受的停顿时间，`每次都快速回收若干个小区域`的内存，`以缩短垃圾回收时系统停顿的时间`，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。如果垃圾回收机制一次回收整个堆内存，则需要更长的系统停顿时间，长时间的系统停顿将影响系统运行的稳定性。

### 为什么MajorGC之前，要进行一次MinorGC？



因为老代空间中的对象可能持有对年轻代空间中的对象的引用。如果年轻代空间没有被垃圾收集，那么在老代空间中`持有对年轻代空间中的对象的引用`的任何`对象`都`不能`被垃圾收集。

![image-20200911171512671](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911171514.png)

老年代的是GC root是？？  这

### 垃圾收集器





## 熟悉

### （新）多线程

​	JVM中的线程与操作系统中的线程是相互对应的。在JVM线程的本地存储、缓冲区分配、同步对象、栈、程序计数器等准备工作都完成时，JVM会调用操作系统的接口创建一个与之对应的原生线程。
​	操作系统负责调度所有线程，并为其分配CPU时间片，在原生线程初始化完毕时，就会调用Java线程的run()执行该线程，在线程结束时，会释放原生线程和Java线程所对应的资源。
​	JVM后台运行的线程主要有

- 虚拟机线程（ JVMThread）：虚拟机线程在JVM到达安全点（ SafePoint）时出现
- 周期性仼务线程：通过定时器调度线程来实现周期性操作的执
- GC线程：GC线程支持JⅥM中不同的垃圾回收活动	
- 编译器线程：编译器线程在运行时将字节码动态编译成本地平台机器码，是JWM跨平台的具体实现
- 信号分发线程：接收发送到JM的信号并调用JVM方法。





## 了解



### 内存和硬盘

内存条才是电脑真正的内存，硬盘是电脑的外存，即存储设备，IO设备。外存中任何数据只有调入内存中才能真正使用。