# JVM

## 精通

### 如何确定垃圾？

引用计数法

在为对象添加一个引用时，引用计数加 1；在为对象删除一个引用时，引进计数减1；如果一个对象的引用计数为 0，则表示此刻该对象没有被引用，可以被回收。

容易产生循环引用的问题，即互为引用，引用计数一直为1。

![image-20200910215537317](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910215539.png)

可达性分析通过根搜索算法（GC Roots Tracing）来实现。

首先定义GC Roots对象，以GC Roots对象作为起点向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡，但不可达对象要经过至少两次标记才能判定其是否可以被回收。

根搜索算法主要针对栈中的引用、方法区中的静态引用和JNI中的引用展开分析。

#### 举例子，哪些是GC Root是对象，并说下跟搜索算法？

### （新）垃圾回收算法？

Jaa中常用的垃圾回收算法有

- `标记清除算法：`内存碎片化

- `复制算法：`内存清理销量高，且易于实现 。但由于同一时刻只有一个内存区域可用，因此存在大量的内存浪费。在系统中有大量长时间存活的对象时，这些对象的来回复制也会影响系统的运行效率。因此，该算法只在对象为“朝生夕死”状态时运行效率较高。

- `标记整理算法：`标记整理算法结合了标记清除算法和复制算法的优点，其标记阶段和标记清除算法的标记阶段相同，在标记完成后将存活的对象移到内存的另一端，然后清除该端的对象并释放内存。

- `分代收集算法：`无论是标记清除算法、复制算法还是标记整理算法，都无法对所有类型（长生命周期、短生命周期、大对象、小对象）的对象都进行垃圾回收。因此，针对不同的对象类型，JVM采用了不同的垃圾回收算法，该算法被称为分代收集算法。

  分代收集算法根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代和老年代。

  - `新生代：`主要存放新生成的对象，其特点是对象数量多，但是小而且生命周期短，采用复制算法。
  - `老年代：`主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。采用标记清楚。

### Java中的四种引用类型

在Java中一切皆对象，对象的操作是通过该对象的引用
（ Reference）实现的，Java中的引用类型有4种，分别为强引用、软引用、弱引用和虚引用，如图1-13所示。
（1）强引用：在Java中最常见的就是强引用。在把一个对象赋给一个引用变量时，这个引用变量就是一个强引用。有强引用的对象定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成Java内存泄漏（ Memory link）的主要原因。
（2）软引用：软引用通过 SoftReference类实现。如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。
（3）弱引用：弱引用通过 WeakReference类实现，如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。
（4）虚引用：虚引用通过 PhantomReference类实现，虚引用和引用队列联合使用，主要用于跟踪对象的垃圾回收状态。

### 为什么MajorGC之前，要进行一次MinorGC？



因为老代空间中的对象可能持有对年轻代空间中的对象的引用。如果年轻代空间没有被垃圾收集，那么在老代空间中持有对年轻代空间中的对象的引用的任何对象都不能被垃圾收集。

## 熟悉

## 了解

