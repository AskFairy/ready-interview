# JVM

## 精通

### （待整理）内存区域

线程到底在私有区域在干什么？哪些是在栈中的？概述

每个区域都是干什么的，都存储了什么

### （新）如何确定垃圾？

引用计数法

在为对象添加一个引用时，引用计数加 1；在为对象删除一个引用时，引进计数减1；如果一个对象的引用计数为 0，则表示此刻该对象没有被引用，可以被回收。

容易产生循环引用的问题，即互为引用，引用计数一直为1。

![image-20200910215537317](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910215539.png)

![image-20200911165721598](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911165730.png)

可达性分析通过根搜索算法（GC Roots Tracing）来实现。

首先定义GC Roots对象，以`GC Roots对象作为起点`根据`引用关系`向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡，但不可达对象要经过至少两次标记才能判定其是否可以被回收。

根搜索算法主要针对栈中的引用、方法区中的静态引用和JNI中的引用展开分析。

#### Java中哪些是GC Root是对象？

在Java技术体系里面，固定可作为 GC Roots的对象包括以下几种：

- 在虚拟机栈（`栈帧中的本地变量表`）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的`参数、局部变量、临时变量`等。

- 在`方法区中类静态属性引用的对象`，譬如Java类的`引用类型静态变量`。

- 在`方法区中常量引用的对象`，譬如`字符串常量池`（ String Table）里的引用。

- 在本地方法栈中JNⅠ（即通常所说的 Native方法）引用的对象。

- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些`常驻的异常对象`（比如NullPointExcepiton、 OutOfMemoryError）等，还有`系统类加载器`。

- 所有`被同步锁`（ synchronized关键字）`持有的对象`

- 反映Java虚拟机内部情况的JMⅹBean、JMTI中注册的回调、本地代码缓存等。

  除了这些固定的 GC Roots集合以外，根据`用户所选用的垃圾收集器以及当前回收的内存区域不同`，还可以有其他对象“`临时性`”地加入，共同构成完整 GC Roots集合。

  譬如后文将会提到的分代收集和局部回收（ Partial gc），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到`内存区域`是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更`不是孤立封闭`的，所以`某个区域里的对象完全有可能被位于堆中其他区域的对象所引用`，这时候就需要将这些关联区域的对象也一并加GC Roots集合中去，才能保证可达性分析的正确性

  目前最新的几款垃圾收集器(OpenJDK中的G1、 Shenandoah、ZGC),无一例外都具备了局部回收的特征，为了避免 GC Roots包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。

#### Java中的四种引用类型

在Java中一切皆对象，对象的操作是通过该对象的引用（Reference）实现的，Java中的引用类型有4种，分别为强引用、软引用、弱引用和虚引用。

- 强引用：最传统的引用定义，值代码之中普遍存在的引用赋值。在把`一个对象赋给一个引用变量即 new`时，这个引用变量就是一个`强引用`。有强引用的对象定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成Java内存泄漏（ Memory link）的主要原因。
  - 定义：如果 reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference数据是代表某块内存、某个对象的引用。
- 软引用：描述一些还有用，但非必须的对象。如果一个对象`只有软引用`，在系统将要发生`内存溢出异常前`，会把这些对象`列进回收范围`之中进行第`二次回收`，如果这次回收还没有足够的内存，才会抛出内存溢出异常。软引用通过 SoftReference类实现
- 弱引用：描述一些非必须的对象，如果一个对象只有弱引用，则在`垃圾回收过程中一定会`被回收。弱引用通过 WeakReference类实现。
- 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也`无法`通过虚引用来`取得一个对象实例`。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器`回收时收到一个系统通知`。`虚引用和引用队列联合使用`，主要用于跟踪对象的垃圾回收状态。虚引用通过 PhantomReference类实现

#### 对象真正死亡？

真正宣告一个对象死亡，至少要经历两次标记，一次可达性分析标记，一次在判定有必要执行 finalized方法判定后，放入F- Queue中等待Finalizer线程去执行，之后收集器将对F- Queue中的对象进行第二次小规模的标记。：

- 如果对象在进行可达性分析后发现`没有与 GC Roots`相连接的`引用链`，那它将会被第一次标记，
- 随后`进行一次筛选`，筛选的条件是此对象是否有必要执行 finalized方法。假如对象没有覆盖 finalized方法，或者 finalize方法已经被虚拟机调用过，那这个对象就死了。
- 如果这个对象被判定为确`有必要执行 finalized方法`，那么该对象将会被放置在一个名为`F- Queue的队列`之中，并在稍后由一条由虚拟机自动建立的、`低调度优先级`的 `Finalizer线程去执行`它们的 finalized方法。这里所说的“执行”是指虚拟机会`触发`这个方法开始`运行`，但并`不承诺`一定会`等待`它运行`结束`。这样做的原因是，如果某个对象的 finalize方法`执行缓慢`，或者更极端地发生了`死循环`，将很可能导致F- Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。
- finalized方法是对象逃脱死亡命运的最后一次机会，`稍后收集器将对F- Queue中的对象进行第二次小规模的标记`，如果对象要在 finalized中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，`譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量`，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。
  - 注：但也`不是百分百成功`，因为不知道收集器啥时候来遍历F-Queue，所以不能做关闭资源的操作。 而且finalize方法只能被系统调用一次。


#### 方法区垃圾回收

虽然方法区垃圾回收性价比低，回收的判断条件苛刻，但是在大量使用反射、动态代理、 CGLib等`动态生成字节码`框架，动态生成JSP以及OSGi这类`频繁自定乂类加载器`的场景中，通常都需要Java虚拟机`具备类型卸载`的能力，以保证不会对方法区造成过大的内存压力。

方法区的垃圾收集主要回收两部分内容

- `废弃`的常量：回收常量池中的字面量、接口、方法、字段的符号引用等。
  
  - `字面量：`假如一个字符串“java曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经`没有任何字符串对象引用`常量池中的“java常量，且虚拟机中`也没有其他地方引用`这个字面量。如果JVM判断`有必要的话会进行回收`。
- `不再使用的类型`：判断一个类是否属于不再使用的类，需满足以下三个条件。
  - 该类`所有的实例`都已经`被回收`，也就是Java堆中不存在该类及其任何派生子类的实例。
  
  - `加载该类的类加载器已经被回收`，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
  
  - 该类对应的 `java. lang.Class`对象没有在任何地方被引用，无法在任何地方通过`反射`访问该类的方。
  
    注：Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“`被允许`”，而`并不是和对象一样，没有引用了就必然会回收`。关于是否要对类型进行回收， Hot spot虚拟机提供了Xnoclassgc参数进行控制。



### （新）垃圾回收算法？

垃圾回收算法，始于分带收集理论。

而分带收集理论建立在两个分代假说之上：绝大多数对象都是朝生夕灭的，熬过越多次垃圾收集过程的对象就越难以消亡。

这两个假说奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

将大多数对象都是朝生夕灭对象集中放在一起，每次回收时`只关注如何保留少量存活`，而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间。

如果剩下的都是`难以消亡`的对象，那把它们集中放在一块，虚拟机便可以使用`较低的频率`来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

`划分出不同的区域之后`，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——才有了“ MinorGC MajorGC Full Go”这样的`回收类型的划分`；

也才能够`针对不同的区域安排与里面存储对象存亡特征相匹配`的垃圾收集算法。



但分带收集不是简单的划分内存，对象存在跨代引用。在新生代用数据结构标识出老年代哪些地方存在跨代引用。MinorGC时将其加入到GC Roots扫描。



通常能单独发生收集行为的只是新生代，所以这里“反过来”的情况只是理论上允许，实际上除了CMS收集器，其他都不存在只针对老年代的收集。

分代收集算法根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代和老年代。

- `新生代：`主要存放新生成的对象，其特点是对象数量多，但是小而且生命周期短，采用复制算法。
- `老年代：`主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。采用标记清楚。

Jaa中常用的垃圾回收算法有

- `标记-清除算法：`执行效率随内存增长而降低，内存碎片化。

- `标记-复制算法：`将内存分为两块，每次只使用一块，用完后，将存活对象复制到另一块，已用过的内存，一次性清理掉。

  内存清理销量高，且易于实现，并且没有空间碎片 。

  但由于同一时刻只有一个内存区域可用，因此存在大量的内存浪费。但如果有大量长时间存活的对象时，这些对象的来回复制也会影响系统的运行效率。因此，该算法只在对象为“朝生夕死”状态时运行效率较高。

  优化：因为98%的对象熬不过第一轮垃圾收集。为了针对空间浪费情况，设计出Eden，和两个survivor，为8:1:1，这样只浪费了10%。并提供了分配担保机制，如果存活大于10%，这些对象讲直接进入老年代。不能用在老年代的原因：存活率较高时，复制效率低，并且需要分配担保。

- `标记-整理算法：`标记整理算法结合了标记清除算法和复制算法的优点，其标记阶段和标记清除算法的标记阶段相同，在标记完成后将存活的对象移到内存的另一端，然后清除该端的对象并释放内存。但标记整理是一种移动式的回收算法，在老年代这种大量存活对象的区域，移动对象并更新所有引用这些对象的地方将是极为负重的操作，并且移动时需要暂停用户应用程序（STW）。

#### 分代收集算法和分区收集算法

  - 分代收集算法：JVM根据对象存活周期的不同将内存划分为新生代、老年代和永久代，并根据各年代的特点分别采用不同的GC算法。
    - `新生代：`主要存放新生成的对象，其特点是对象数量多，但是小而且生命周期短，采用复制算法。
    - `老年代：`主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。采用标记清楚。
  - 分区收集算法：分区算法将整个堆空间`划分为连续的大小不同的小区域`，对每个小区域都`单独进行内存使用和垃圾回收`，这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。
    分区收集算法可以根据系统可接受的停顿时间，`每次都快速回收若干个小区域`的内存，`以缩短垃圾回收时系统停顿的时间`，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。如果垃圾回收机制一次回收整个堆内存，则需要更长的系统停顿时间，长时间的系统停顿将影响系统运行的稳定性。

### 为什么MajorGC之前，要进行一次MinorGC？



因为老代空间中的对象可能持有对年轻代空间中的对象的引用。如果年轻代空间没有被垃圾收集，那么在老代空间中`持有对年轻代空间中的对象的引用`的任何`对象`都`不能`被垃圾收集。

![image-20200911171512671](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911171514.png)

老年代的是GC root是？？  这

### 垃圾收集器





## 熟悉



## 了解

