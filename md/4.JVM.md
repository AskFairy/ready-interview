# JVM

## 精通

### [JAVA中类、实例与Class对象](https://blog.csdn.net/djzhao/article/details/79107071)

**类：**类是面向对象编程语言的`一个重要概念`，它是`对一项事物的抽象概括，可以包含该事物的一些属性定义，以及操作属性的方法`。

类只是信息描述的，写明了有哪些内部属性及接口，你可以理解为是程序员定义了一套规则。

面向对象编程中，我们都是以类来编码。

**Class：**在包 java.lang 下继承Object特殊的**Class类**，它内部可以记录类的成员、接口等信息，也就是在Java里，Class是一个用来`表示类的类`，让JVM`看懂的一套模板`。（Class是一个实实在在的类，可以为它创建实例，也就是本文后面提到的Class对象，也叫做Class实例：就是类加载器加载到内存中的模板。）。

java提供了下面几种获取到类的Class对象的方法：

- （1）利用对象实例调用getClass()方法获取该对象的Class实例；

- （2）运用类名.class 的方式来获取Class实例；

- （3）使用Class类的静态方法forName("包名+类名")，用类的名字获取一个Class实例

  ![image-20200913202846994](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200913202855.png)

**实例：**简单理解，就是new，就是对类的实例化，创建这个`类对应的实际对象`，`类只是对事物的描述`，而`实例化`就相当于为`这个描述新开辟了一块内存`，可以改变这块区域里的各种属性（成员变量），用操作方法。当然，也可以实例化多块区域，只是不同的对象而已。

总结：在java里，`类只是信息描述`的，写明了有哪些内部属性及接口，你可以理解为是定义了`一套规则`；而`Class对象`在java里被用来对类的情况进行表述的一个实例，也就是是`类的实际表征`，可以理解为是对规则的图表化，这样`JVM才能直观的看懂，可以看做是一个模版`；而类的`实例化对象，就是通过模版，开辟出的一块内存进行实际的使用`。

### （新）JVM的运行机制？

运行Java字节码的虚拟机，包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器。
	**Java源文件被编译器编译成.Class文件，.Class文件被解释器解释成机器码，机器码调用相应操作系统的本地方法库执行相应的方法**。
	在一个Java进程开始运行后，虚拟机就开始**实例化**了，**有多个进程启动就会实例化多个虚拟机实例**。虚拟机实例之间不能共享数据。

### （新）JVM虚拟机有哪些部分组成？

- `类加载器：`于将编译好的. Class文件加载到JVM中
- `运行时数据区：`用于存储在JVM运行过程中产生的数据，包括程序计数器、方法区、本地方法区、虚拟机栈和虚拟机堆；
- `执行引擎：`包括`即时编译器`和`垃圾回收器`，即时编译器用于将Java字节码编译成具体的机器码，垃圾回收器用于回收在运行过程中不再使用的对象
- `本地接口库`用于调用操作系统的本地方法库完成具体的指令操

![image-20200912193207228](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912193208.png)



### （新）运行时数据区（内存区域）

线程到底在私有区域在干什么？哪些是在栈中的？概述

每个区域都是干什么的，都存储了什么

![image-20200912194906222](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912194907.png)

**线程私有区域**：

- `程序计数器：`**记录当前运行线程在该方法中执行的字节码指令位置（行号指示器）**。在方法正在执行时，该方法的程序计数器记录的是实时虚拟机字节码指令的地址，Native方法，程序计数器的值为空（undefined）。唯一**无内存溢出**（Out Of Memory）问题的地方。

- `虚拟机栈：`描述的是**Java方法的执行的线程内存模型**。在方法被执行时虚拟机会为其创建一个与之对应的栈帧，里面存储：局部变量表、操作栈、动态链接、方法出口等信息。`方法的执行和返回对应栈帧在虚拟机栈的入栈和出栈`。每个运行中的线程当前只有一个栈帧处于活动状态（线程执行代码是顺序的）。
  	  	`栈帧存储：`
  
  - `局部变量表`：存放`编译期可知的数据类型`，数据类型在局部变量表中的存储空间以局部变量槽（Sot）来表示，其中64位长度的`long和double类型`的数据会占用`两个变量槽`，`其余`的数据类型只`占用一个`。数据类型所需空间在编译期完成，进入方法前已经确定，运行期间不会改变局部变量表大小。
    - 基本数据类型
    - 对象引用
    - returnAddress（指向了一条字节码的地址）
  - `操作栈`：
  - `动态链接`：
  - `方法出口等`：
  
  ​		异常：
    				StackOverflowError：请求栈大于虚拟机深度
    				OutOfMemoryError：虚拟机栈容量可以动态扩展，但无法申请足够的内存。
  
- `本地方法栈：` 线程私有，本地方法区和虚拟机栈的作用类似，区别是虚拟机栈为执行Java 方法服务，`本地方法栈为Native方法服务`	

**线程共享区域**：

- 堆：虚拟机管理最大的区域，`虚拟机启动时创建`。在JVM运行过程中**几乎**所有的**对象实例**和**产生的数据**都被存储在堆中。垃圾回收器（GC）工作的区域。

  JDK8：

  - 对象实例
  - 运行时常量池
    - 字符串常量池：存的是在堆中的字符串的引用？还是字符串对象？

  **注1：**对堆的区域划分，仅仅是垃圾收集器的设计风格，一种概念，而非JVM具体实现的固有布局。

  **注2：**字符串常量池存的是引用值？，还是对象存在于运行时常量池之中？。

  **注3：**类（.class文件）加载到内存中后，jvm就会将`静态常量池中的内容存放到运行时常量池`中，运行时常量池更重要的的特征：`动态性`。Java要求，编译期静态常量池的内容可以进入运行时常量池（字符串），运行时产生的常量也可以放入池中：常用的是String类的intern()方法。（类加载器不是一次将所有的的.class文件都加载进内存）

  注4：几乎？：值类型的支持，以及编译技术进步，逃逸分析，栈上分配，标量替换优化手段导致一些微妙的变化，对象都分配到栈上已经不那么绝对了。

- 方法区：（`Java8元空间概念所在，采用本地内存实现`）用于存储已被虚拟机加载的**静态常量池**，**类型信息（即时编译器编译后的机器码）**等数据。垃圾回收器主要做针对**常量池的回收**，和**类型的卸载**。（所有的Class文件一次性都加载进内存？）

  - 静态常量池

    - 字面量
    - 符合引用

    ![image-20200912205138122](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912205139.png)

  **注：**而当类加载到内存中后，jvm就会将`静态常量池中的内容存放到运行时常量池`中。在静态常量池的符号引用有`一部分是会被转变为直接引用`的，比如说**类的静态方法或私有方法，实例构造方法，父类方法**，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被**第一次调用（线程调用到虚拟机栈？）**的时候才会将符号引用转变为直接引用的。

**直接内存：**

直接内存也叫作堆外内存，它**并不是JVM运行时数据区**的一部分，但在并发编程中被频繁使用。
		例如：JDK的**NIO模块提供的基于 通道（Channel）与缓冲区（Buffer）的I/O操作方式**就是基于堆外内存实现的，NIO模块通过**调用Native函数库直接在操作系统上分配堆外内存**，然后使用DirectByteBuffer对象作为这块内存的引用对内存进行操作
					Java进程可以通过堆外内存技术**避免在Java堆和 Native堆中来回复制数据带来的资源占用和性能消耗**，因此堆外内存在高并发应用场景下被广泛使用（ Netty、F1ink、 HBase、 Hadoop都有用到堆外内存）

#### 静态常量池在Class文件中的位置

![image-20200912211433506](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912211434.png)

从上图可以看出，Class文件中包括：

魔数：它的唯一作用是确定这个文件是否可以被JVM接受。很多文件储存标准中都使用魔数来进行身份识别的，其占用这个文件的前四个字节。

版本号：第5和第6个字节是副版本号，第7个和第8 个是主版本号。

常量池计数器：也就是常量池的入口，代表常量池的容量计数器。

常量池：常量池中主要存放两类常量：字面量和符号引用。字面量比较接近Java语言层面的常量概念。就是我们什么提到的常量。而符号引用则属于编译原理的方面的概念。包括以下三类常量：

（1）类和接口的全限定名

（2）字段的名称和描述符

（3）方法的名称和描述符

### 对象

对象的创建过程：通常指new[^其他创建方式]一个对象[^讨论对象]

1. 当Java虚拟机遇到一条字节码`new指令`时，首先将去检査这个指令的参数是否能在`常量池中定位到个类的符号引用`，并且检査这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。





[^其他创建方式]:clone，反序列化
[^讨论对象]:普通Java对象，不包含数组，Class对象

### 如何确定垃圾？

引用计数法

在为对象添加一个引用时，引用计数加 1；在为对象删除一个引用时，引进计数减1；如果一个对象的引用计数为 0，则表示此刻该对象没有被引用，可以被回收。

容易产生循环引用的问题，即互为引用，引用计数一直为1。

![image-20200910215537317](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910215539.png)

![image-20200911165721598](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911165730.png)

可达性分析通过根搜索算法（GC Roots Tracing）来实现。

首先定义GC Roots对象，以`GC Roots对象作为起点`根据`引用关系`向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡，但不可达对象要经过至少两次标记才能判定其是否可以被回收。

根搜索算法主要针对栈中的引用、方法区中的静态引用和JNI中的引用展开分析。

#### Java中哪些是GC Root是对象？

在Java技术体系里面，固定可作为 GC Roots的对象包括以下几种：

- 在虚拟机栈（`栈帧中的本地变量表`）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的`参数、局部变量、临时变量`等。

- 在`方法区中类静态属性引用的对象`，譬如Java类的`引用类型静态变量`。

- 在`方法区中常量引用的对象`，譬如`字符串常量池`（ String Table）里的引用。

- 在本地方法栈中JNⅠ（即通常所说的 Native方法）引用的对象。

- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些`常驻的异常对象`（比如NullPointExcepiton、 OutOfMemoryError）等，还有`系统类加载器`。

- 所有`被同步锁`（ synchronized关键字）`持有的对象`

- 反映Java虚拟机内部情况的JMⅹBean、JMTI中注册的回调、本地代码缓存等。

  除了这些固定的 GC Roots集合以外，根据`用户所选用的垃圾收集器以及当前回收的内存区域不同`，还可以有其他对象“`临时性`”地加入，共同构成完整 GC Roots集合。

  譬如后文将会提到的分代收集和局部回收（ Partial gc），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到`内存区域`是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更`不是孤立封闭`的，所以`某个区域里的对象完全有可能被位于堆中其他区域的对象所引用`，这时候就需要将这些关联区域的对象也一并加GC Roots集合中去，才能保证可达性分析的正确性

  目前最新的几款垃圾收集器(OpenJDK中的G1、 Shenandoah、ZGC),无一例外都具备了局部回收的特征，为了避免 GC Roots包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。

#### Java中的四种引用类型

在Java中一切皆对象，对象的操作是通过该对象的引用（Reference）实现的，Java中的引用类型有4种，分别为强引用、软引用、弱引用和虚引用。

- 强引用：最传统的引用定义，值代码之中普遍存在的引用赋值。在把`一个对象赋给一个引用变量即 new`时，这个引用变量就是一个`强引用`。有强引用的对象定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成Java内存泄漏（ Memory link）的主要原因。
  - 定义：如果 reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference数据是代表某块内存、某个对象的引用。
- 软引用：描述一些还有用，但非必须的对象。如果一个对象`只有软引用`，在系统将要发生`内存溢出异常前`，会把这些对象`列进回收范围`之中进行第`二次回收`，如果这次回收还没有足够的内存，才会抛出内存溢出异常。软引用通过 SoftReference类实现
- 弱引用：描述一些非必须的对象，如果一个对象只有弱引用，则在`垃圾回收过程中一定会`被回收。弱引用通过 WeakReference类实现。
- 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也`无法`通过虚引用来`取得一个对象实例`。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器`回收时收到一个系统通知`。`虚引用和引用队列联合使用`，主要用于跟踪对象的垃圾回收状态。虚引用通过 PhantomReference类实现

#### 对象真正死亡？

真正宣告一个对象死亡，至少要经历两次标记，一次可达性分析标记，一次在判定有必要执行 finalized方法判定后，放入F- Queue中等待Finalizer线程去执行，之后收集器将对F- Queue中的对象进行第二次小规模的标记。：

- 如果对象在进行可达性分析后发现`没有与 GC Roots`相连接的`引用链`，那它将会被第一次标记，
- 随后`进行一次筛选`，筛选的条件是此对象是否有必要执行 finalized方法。假如对象没有覆盖 finalized方法，或者 finalize方法已经被虚拟机调用过，那这个对象就死了。
- 如果这个对象被判定为确`有必要执行 finalized方法`，那么该对象将会被放置在一个名为`F- Queue的队列`之中，并在稍后由一条由虚拟机自动建立的、`低调度优先级`的 `Finalizer线程去执行`它们的 finalized方法。这里所说的“执行”是指虚拟机会`触发`这个方法开始`运行`，但并`不承诺`一定会`等待`它运行`结束`。这样做的原因是，如果某个对象的 finalize方法`执行缓慢`，或者更极端地发生了`死循环`，将很可能导致F- Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。
- finalized方法是对象逃脱死亡命运的最后一次机会，`稍后收集器将对F- Queue中的对象进行第二次小规模的标记`，如果对象要在 finalized中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，`譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量`，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。
  - 注：但也`不是百分百成功`，因为不知道收集器啥时候来遍历F-Queue，所以不能做关闭资源的操作。 而且finalize方法只能被系统调用一次。


#### 方法区垃圾回收

虽然方法区垃圾回收性价比低，回收的判断条件苛刻，但是在大量使用反射、动态代理、 CGLib等`动态生成字节码`的框架，动态生成JSP以及OSGi这类`频繁自定乂类加载器`的场景中，通常都需要Java虚拟机`具备类型卸载`的能力，以保证不会对方法区造成过大的内存压力。

方法区的垃圾收集主要回收两部分内容

- `废弃`的常量：回收常量池中的字面量，接口、方法、字段的符号引用等。
  
  - `字面量：`假如一个字符串“java曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经`没有任何字符串对象引用`常量池中的“java常量，且虚拟机中`也没有其他地方引用`这个字面量。如果JVM判断`有必要的话会进行回收`。
- `不再使用的类型`：判断一个类是否属于不再使用的类，需满足以下三个条件。
  - 该类`所有的实例`都已经`被回收`，也就是Java堆中不存在该类及其任何派生子类的实例。
  
  - `加载该类的类加载器已经被回收`，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
  
  - 该类对应的 `java. lang.Class`对象没有在任何地方被引用，无法在任何地方通过`反射`访问该类的方。
  
    注：Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“`被允许`”，而`并不是和对象一样，没有引用了就必然会回收`。关于是否要对类型进行回收， Hot spot虚拟机提供了Xnoclassgc参数进行控制。



### 垃圾回收算法？

垃圾回收算法，始于分带收集理论。

而分带收集理论建立在两个分代假说之上：绝大多数对象都是朝生夕灭的，熬过越多次垃圾收集过程的对象就越难以消亡。

这两个假说奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

将大多数对象都是朝生夕灭对象集中放在一起，每次回收时`只关注如何保留少量存活`，而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间。

如果剩下的都是`难以消亡`的对象，那把它们集中放在一块，虚拟机便可以使用`较低的频率`来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

`划分出不同的区域之后`，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——才有了“ MinorGC MajorGC Full Go”这样的`回收类型的划分`；

也才能够`针对不同的区域安排与里面存储对象存亡特征相匹配`的垃圾收集算法。



但分带收集不是简单的划分内存，对象存在跨代引用。在新生代用数据结构标识出老年代哪些地方存在跨代引用。MinorGC时将其加入到GC Roots扫描。



通常能单独发生收集行为的只是新生代，所以这里“反过来”的情况只是理论上允许，实际上除了CMS收集器，其他都不存在只针对老年代的收集。

分代收集算法根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代和老年代。

- `新生代：`主要存放新生成的对象，其特点是对象数量多，但是小而且生命周期短，采用复制算法。
- `老年代：`主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。采用标记清楚。

Jaa中常用的垃圾回收算法有

- `标记-清除算法：`执行效率随内存增长而降低，内存碎片化。

- `标记-复制算法：`将内存分为两块，每次只使用一块，用完后，将存活对象复制到另一块，已用过的内存，一次性清理掉。

  内存清理销量高，且易于实现，并且没有空间碎片 。

  但由于同一时刻只有一个内存区域可用，因此存在大量的内存浪费。但如果有大量长时间存活的对象时，这些对象的来回复制也会影响系统的运行效率。因此，该算法只在对象为“朝生夕死”状态时运行效率较高。

  优化：因为98%的对象熬不过第一轮垃圾收集。为了针对空间浪费情况，设计出Eden，和两个survivor，为8:1:1，这样只浪费了10%。并提供了分配担保机制，如果存活大于10%，这些对象讲直接进入老年代。不能用在老年代的原因：存活率较高时，复制效率低，并且需要分配担保。

- `标记-整理算法：`标记整理算法结合了标记清除算法和复制算法的优点，其标记阶段和标记清除算法的标记阶段相同，在标记完成后将存活的对象移到内存的另一端，然后清除该端的对象并释放内存。但标记整理是一种移动式的回收算法，在老年代这种大量存活对象的区域，移动对象并更新所有引用这些对象的地方将是极为负重的操作，并且移动时需要暂停用户应用程序（STW）。

#### 分代收集算法和分区收集算法

  - 分代收集算法：JVM根据对象存活周期的不同将内存划分为新生代、老年代和永久代，并根据各年代的特点分别采用不同的GC算法。
    - `新生代：`主要存放新生成的对象，其特点是对象数量多，但是小而且生命周期短，采用复制算法。
    - `老年代：`主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。采用标记清楚。
  - 分区收集算法：分区算法将整个堆空间`划分为连续的大小不同的小区域`，对每个小区域都`单独进行内存使用和垃圾回收`，这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。
    分区收集算法可以根据系统可接受的停顿时间，`每次都快速回收若干个小区域`的内存，`以缩短垃圾回收时系统停顿的时间`，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。如果垃圾回收机制一次回收整个堆内存，则需要更长的系统停顿时间，长时间的系统停顿将影响系统运行的稳定性。

### 为什么MajorGC之前，要进行一次MinorGC？



因为老代空间中的对象可能持有对年轻代空间中的对象的引用。如果年轻代空间没有被垃圾收集，那么在老代空间中`持有对年轻代空间中的对象的引用`的任何`对象`都`不能`被垃圾收集。

![image-20200911171512671](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911171514.png)

老年代的是GC root是？？  这

### 垃圾收集器





## 熟悉

### （新）多线程

​	JVM中的线程与操作系统中的线程是相互对应的。在JVM线程的本地存储、缓冲区分配、同步对象、栈、程序计数器等准备工作都完成时，JVM会调用操作系统的接口创建一个与之对应的原生线程。
​	操作系统负责调度所有线程，并为其分配CPU时间片，在原生线程初始化完毕时，就会调用Java线程的run()执行该线程，在线程结束时，会释放原生线程和Java线程所对应的资源。
​	JVM后台运行的线程主要有

- 虚拟机线程（ JVMThread）：虚拟机线程在JVM到达安全点（ SafePoint）时出现
- 周期性仼务线程：通过定时器调度线程来实现周期性操作的执
- GC线程：GC线程支持JⅥM中不同的垃圾回收活动	
- 编译器线程：编译器线程在运行时将字节码动态编译成本地平台机器码，是JWM跨平台的具体实现
- 信号分发线程：接收发送到JM的信号并调用JVM方法。

## 了解



