# JVM

## 精通

### 如何确定垃圾？

引用计数法

在为对象添加一个引用时，引用计数加 1；在为对象删除一个引用时，引进计数减1；如果一个对象的引用计数为 0，则表示此刻该对象没有被引用，可以被回收。

容易产生循环引用的问题，即互为引用，引用计数一直为1。

![image-20200910215537317](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910215539.png)

可达性分析通过根搜索算法（GC Roots Tracing）来实现。

首先定义GC Roots对象，以GC Roots对象作为起点向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡，但不可达对象要经过至少两次标记才能判定其是否可以被回收。

根搜索算法主要针对栈中的引用、方法区中的静态引用和JNI中的引用展开分析。

#### 举例子，哪些是GC Root是对象，并说下跟搜索算法？

### （新）垃圾回收算法？

Jaa中常用的垃圾回收算法有

- `标记清除：`内存碎片化

- `复制：`清理销量高，且易于实现 。但由于同一时刻只有一个内存区域可用，因此存在大量的内存浪费。在系统中有大量长时间存活的对象时，这些对象的来回复制也会影响系统的运行效率。因此，该算法只在对象为“朝生夕死”状态时运行效率较高。
- `标记整理：`标记整理算法结合了标记清除算法和复制算法的优点，其标记阶段和标记清除算法的标记阶段相同，在标记完成后将存活的对象移到内存的另一端，然后清除该端的对象并释放内存。
- 分代收集

### 为什么MajorGC之前，要进行一次MinorGC？



因为老代空间中的对象可能持有对年轻代空间中的对象的引用。如果年轻代空间没有被垃圾收集，那么在老代空间中持有对年轻代空间中的对象的引用的任何对象都不能被垃圾收集。

## 熟悉

## 了解

