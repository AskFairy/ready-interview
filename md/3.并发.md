



# 并发

## 精通

### （新）简述线程、进程、程序的基本概念？

`程序`，存储在磁盘上的能够`被系统运行`的含有`指令`和`数据`的文件。

`进程`，是系统运行程序的基本单位。当程序在执行时，将会被操作系统载入内存中，计算机运行程序的指令，去操作数据，`正在执行中的程序，就是进程`。

`线程`，与进程相似，但线程是一个比进程更小的执行单位，被称为轻量级进程。一个进程在其执行的过程中可以产生多个线程。在Java中，多个线程共享进程的堆和方法区（J0K1.8之后的元空间）资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。

基本上各进程是独立的，但同一进程中的线程极有可能会，互相协作，相互影响。

`线程可以理解为需要CPU处理的细分任务，进程就是线程汇总出来为人类实现特定功能，它和卖CPU说的8核16线程可不是一个概念，16线程相当于16个虚拟核心`。

### （新）多线程的优缺点？

1）好处

- 使用多线程可以把`程序中占据时间长的任务放到后台`去处理，如图片、视屏的下载。
- 发挥`多核处理器的优势`，并发执行让系统运行的更快、更流畅，用户体验更好。

2）坏处

- 大量的线程`降低代码的可读性`。
- 更多的线程需要`更多的内存空间`。
- 当多个线程对同一个资源出现争夺时候要注意`线程安全的问题`。

### （新）什么是多线程上下文切换？

多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要`轮转使用 CPU` 。CPU利用时间片轮询来为每个任务都服务一定的时间，然后把当前任务的状态保存下来，继续服务下一个任务。`任务的状态保存及再加载就叫作线程的上下文切换`。线程切换时CPU寄存器和程序计数器所保存的当前线程的信息，就是上下文。

- 进程：指一个运行中的程序的实例。在一个进程内部可以有多个线程在同时运行，并与创建它的进程共享同一地址空间（一段内存区域）和其他资源。
- 上下文：指线程切换时CPU寄存器和程序计数器所保存的当前线程的信息。
- 寄存器：指**CPU内部容量较小但速度很快的内存区域**（与之对应的是CPU外部相对较慢的RAM主内存）。寄存器**通过对常用值（通常是运算的中间值）的快速访问来加快计算机程序运行的速度**。
- 程序计数器：是**一个专用的寄存器**，用于`表明指令序列中CPU正在执行的位置`，存储的值为正在执行的指令的位置或者下一个将被执行的指令的位置，这依赖于特定的系统。

#### 上下文切换流程？

- （1）挂起一个进程，将这个进程在CPU中的状态（`上下文信息`）
  `存储于内存的PCB中`
- （2）在PCB中检索下一个进程的上下文并`将其在CPU的寄存器中恢复`
- （3）`跳转到程序计数器所指向的位置`（即跳转到进程被中断时的代码行）并恢复该进程

![image-20200912173053210](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912173054.png)

#### 引起线程上下文切换的原因引起线程上下文切换（线程让出CPU的情况）的原因？

- 当前正在执行的任务完成，系统的`CPU正常调度`下一个任务
- 当前正在执行的任务遇到`I0等阻塞操作，调度器挂起此任务`，继续调度下一个任务。
- 多个任务并发抢占锁资源，`当前任务没有抢到锁资源`，`被调度器挂起`，继续调度下一个任务
- 用户的`代码挂起当前任务`，比如线程执行 `sleep方法，让出CPU`
- `硬件中断`。

### （新）进程调度算法

系统`多进程分时复用`

进程调度算法包括：

- 优先调度算法
  - `先来先服务调度算法：`运行最早进入的任务，实现简单相对公平
  - `短作业优先调度算法：`估运行时间最短的进程，为其分配CPU资源并运行。该算法优`先运行短时间作业`，以提高CPU整体的`利用率和系统运行效率`，某些大任务可能会出现长时间得不到调度的情况（**饥饿**）。

- 高优先权优先调度算法
  - `非抢占式优先杈算法：`该算法**优先运行优先权高**的作业，且一旦将CPU分配给某个进程，就**不会主动回收CPU资源**，直到任务主动放弃。
  - `抢占式优先权调度算法：`抢占式优先调度算法首先把**CPU资源分配**给优先权最高的任务并运行，但如果在运行过程中出现比当前运行**任务优先权更高**的任务，调度算法就会暂停运行该任务并回收CPU资源，为其分配新的优先权更高的任务。该算法真正保障了CPU在整个运行过程中**完全按照任务的优先权分配资源**，这样如果临时有紧急作业，则也可以保障其第一时间被执行。
  - `高响应比优先调度算法：`高响应比优先调度算法使用了动态优先权的概念，即任务的`执行时间越短，其优先权越高，任务的等待时间越长，优先权越高`。
    高响应比优先调度算法在`保障效率`（短作业优先能在很大程度上提高CPU的使用率和系统性能）的基础上`尽可能提高了调度的公平性`（随着任务等待时间的增加，优先权提高，遵循了先来先到原则）。

- 基于时间片的轮转调度算法。

  - `时间片轮转算法：`时间片轮转法指按照`先来先服务原则`从就绪队列中取出一个仼务，并为该任务分配一定的CPU时间片去运行，在进程使用完CPU`时间片后由一个时间计时器发出时钟中断请求`，`调度器`在收到时钟中断请求信号后停止该进程的运行并将该进程放入就绪`队列的队尾`，然后从就绪队列的队首取出一个任务并为其分配CPU时间片去执行。这样，就绪队列中的任务就将轮流获取一定的CPU时间片去运行

  - 多级反馈队列调度算法：多级反馈队列调度算法`在时间片轮询算法的基础上`设置`多个就绪队列`，并为每个就绪队列都设置不同的优先权。队列的优先权越高队列中的任务被分配的时间片就越大。默认第一个队列优先权最高，其他次之。

    调度流程：

    - 任务进来，先放第一个队列末尾，规定时间内任务没有运行完成，将此任务放入第二队列，以此类推。前面队列的任务的全部完成后，调度器才回调度当前队列，并且前面队列有新任务进来时，它还会被停止，然后放入队列末尾。

    先来先服务调度算法和时间片轮询算法的优势，使得对进程的调度更加合理。

### Java 中用到的线程调度算法是什么？

一个多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。Java 虚拟机的一项任务就是负责按照特定机制为多个线程分配 CPU 的使用权。

Java 虚拟机采用`抢占式调度模型`，是指优先让可运行池中`优先级高的线程占用 CPU` ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。优先级低的线程只是获取CPU时间片的优先级被降低，但**不会永久分配不到CPU时间片**。Java的线程调度在保障效率的前提下尽可能保障线程调度的公平性。容易`导致其他线程饥饿`。

#### 什么是线程饥饿？

饥饿，一个或者多个线程因为种种原因无法获得所需要的资源（数据、CPU时间片、运行指令等），导致一直无法执行的状态。

Java 中导致饥饿的原因：

- `高优先级线程`吞噬所有的低优先级线程的 CPU 时间。
- `线程被永久堵塞在一个等待进入同步块的状态`，因为其他线程总是能在它之前持续地对该同步块进行访问。
- `线程在等待一个本身也处于永久等待完成的对象`(比如调用这个对象的 `wait 方法`)，因为其他线程总是被持续地获得唤醒。

#### 你对线程优先级的理解是什么？

每一个线程都是有优先级的，一般来说，`高优先级的线程在运行时会具有优先权`。线程优先级是一个 int 变量(从`1-10`)，1 代表最低优先级，10 代表最高优先级。我们可以定义线程的优先级，但是这并`不能保证高优先级`的线程会在低优先级的线程前`执行`。Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。

### （新）什么叫线程安全？

线程安全，指某个函数、函数库在多线程环境中被调用时，`能够正确地处理多个线程之间的共享变量`，使程序功能正确完成。可能会带来内存泄漏、上下文切换、死锁等问题。

### （新）并发原理

#### 并发编程需要解决的核心问题？

**分工**：指的是如何`高效地拆解任务并分配给线程`，直接决定了并发程序的性能。一个任务下发了，怎么执行能更快的完成。

**同步（协作）**：指的是线程之间如何协作，一个线程执行完了一个任务，如何通知执行后续任务的线程开工。即当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行。

**互斥**：也叫线程安全。是保证同一时刻只允许一个线程访问共享资源。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。可以看做一种特殊的协作。

Java解决并发编程：

![image-20200912162649563](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912162658.png)



#### 并发产生的原因？

为了平衡CPU、内存、I/O 设备三者速度的差异：

`缓存：CPU 增加了缓存`，以均衡与内存的速度差异。但在多核时代，每颗 CPU 都有自己的缓存，存在CPU 缓存与内存的数据一致性问题。一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。

`指令优化：`为了使得`缓存`和`处理器的内部单元`能够得到更加合理地`利用`，编译程序优化`指令执行次序`。

`线程切换：`操作系统增加了进程、线程，用以`分时复用 CPU`，进而均衡 CPU 与 I/O 设备的速度差异。`但操作系统切换线程可以在任何一条CPU指令完成后`，所以无法保证高级语言的操作符的原子性。我们把一个或者多个操作在 `CPU 执行的过程中不被中断`的特性称为`原子性`：解决原子性问题，是要保证中间状态对外不可见。

**为了获得更好的执行效能**，Java内存模型**并没有限制执行引擎**使用处理器的特定寄存器或缓存来和主内存进行交互，也**没有限制即时编译器**是否要进行调整代码执行顺序这类优化措施。

#### Java如何解决可见性、有序性、原子性？

Java 内存模型是一个规范，规范了 JVM 如何提供按需禁用缓存和编译优化的方法以保证有序性问题。包括volatile、synchronized 和 final 三个关键字，以及8项 Happens-Before 规则保证前面一个操作的结果对后续操作是可见的。

**三个关键字：**

volatile：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。并在1.5版本通过程序顺序性、volatile 变量规则、传递性这三项Happens-Before规则，对volatile进行了语义增强，如下所示： 

![image-20200914155306845](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914155308.png)

`final：`这个变量生而不变，可以可劲儿优化。

- Java 编译器在 1.5 以前的版本会因构造函数的错误重排导致线程可能看到 final 变量的值会变化。1.5以后对final类型变量得类型变量的重排进行了约束，但要避免构造函数溢出。

  ![image-20200914155058458](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914155100.png)

  将this赋值给global.obj时，this还没有初始化完

`synchronized：`为了保证`操作`的`原子性`，在多核CPU时代，不需要`禁止线程切换`，还需要“同一时刻只有一个线程执行”这个条件，称之为`线程互斥`。Java提供了锁技术，锁并不能改变CPU时间片切换的特点，只是保证当CPU走了后，不让其他线程操作数据。当其他线程要访问锁修饰的这个资源时，发现锁还未释放，所以只能在外面等待，以此来保证操作的原子性。并根据 Happens-Before 中的`管程中锁的规则`，保证后续线程`加锁时`对受保护资源的`可见性`。

`（保护资源）对象`：每个对象都有唯一的一把锁。加锁只会保证框定的区域（临界区）里，对保护资源  `操作`  （方法：可以有多个操作）的原子性，所以不能多把锁保护同一个资源。

锁，一定有一个要锁定的对象（临界区），至于这个`锁定的对象要保护的”资源“`以及在哪里加锁 / 解锁（门），就属于设计层面的事情了，受保护资源和锁之间合理的关联关系应该是 `N:1` 的关系。

- 同步代码块：锁定指定的一个 obj 对象
- 修饰非静态方法：当前实例对象 this
- 修饰静态方法：锁定的是当前类的 Class 对象，在上面的例子中就是 Class X

`原理：`

加锁的本质（待整理）：synchronized的理解是这样，它并不能改变CPU时间片切换的特点，只是当其他线程要访问这个资源时，发现锁还未释放，所以只能在外面等待。

Sync优化：sync锁的对象monitor指针指向一个ObjectMonitor对象，所有线程加入他的entrylist里面，去cas抢锁，更改state加1拿锁，执行完代码，释放锁state减1，和aqs机制差不多，只是所有线程不阻塞，cas抢锁，没有队列，属于非公平锁。 wait的时候，线程进waitset休眠，等待notify唤醒。

**8项 Happens-Before 规则：**

- `程序的顺序性规则:``一个线程`中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。
- `volatile 变量规则：`这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。
- `传递性：` 这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。
- `管程中锁的规则：`是指对`一个锁的解锁` Happens-Before 于后续对这个锁的加锁。线程B进入同步块后能看见线程A的写操作
- `线程 start() 规则：`它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。
- `线程 join() 规则：`这条是关于线程等待的。`它是指主线程 A 等待子线程 B 完成`（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），`主线程能够看到子线程的操作`。
- `线程中断规则:`对线程interrupt（）方法的调用happen—before发生于被中断线程的代码检测到中断时事件的发生。可以通过Thread::interrupted（）方法检查是否有中断发生。
- `对象终结规则：`一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始。

### 互斥锁

#### 锁和资源

`不能用，可变对象做锁`：我觉得不能用balance和password做为锁对象。这两个对象balance是Integer，password是String都是不可变变对象，一但对他们进行赋值就会变成新的对象，加的锁就失效了。

##### 保护没有关联关系的多个资源

各自用一把锁。

用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字，叫`细粒度锁。`

##### 保护有关联关系（之间有数据交换）的多个资源

转账问题：锁能覆盖所有受保护资源，即多个对象共用一把锁。

注：转账实际使用数据库事务+乐观锁的方式解决（select * from account where account_id = ? for update 加锁，锁住锁定两条记录）。并且实际中转账和到账操作有延迟，转入操作放到mq里面，mq消费失败会重试，所以能保证最终一致性。

- 创建多个对象时，`传入唯一的lock对象来当锁`。万一不是一样的对象，就没用了，并且会出现，锁自家门来保护他家资产的荒唐事。

- 用 `Account.class 作为共享的锁`。这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。`但所有的转账操作都变成串行，不可行`。

  - 还可以在Account中添加一个final静态object，通过锁这个object来实现一个锁保护多个资源。这种方式比锁class更安全。如果用 Account.class 的话，其他使用的者也可以用这个锁，可以说这种锁是暴露的，而这种则是私有的锁，不会有暴露的风险。

    ![image-20200914171740854](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914171742.png)

#### 死锁

 Account.class 作为互斥锁，虽然这个方案不存在并发问题，但是所有账户的转账操作都是串行的。解决这个问题，可以`一次性获取两把锁`：转出账户 this锁，转入账户锁。

![image-20200914173910745](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914173912.png)

将锁的细粒度变小，使用`细粒度锁`可以提高并行度，是性能优化的一个重要手段。

`但代价`就是可能会导致`死锁`:一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。

以下四个条件`都发生`时才会出现`死锁`：

- `互斥`，共享资源 X 和 Y 只能被一个线程占用；
- `占有且等待`，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
- `不可抢占`，其他线程不能强行抢占线程 T1 占有的资源；
- `循环等待`，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

破坏其中一个，就可以成功避免死锁的发生：

- `互斥：`无法破坏，用`锁为的就是互斥`。

- `占用且等待：`我们可以`一次性申请所有的资源`。需要一个`管理员角色：Allocator`（Java 里面的类）来管理这个临界区，用来同时申请资源，同时释放资源。账户 Account 类里面持有一个 `Allocator 的单例`（管理员必须是唯一的）。

  <img src="upload\image-20200914180535649.png" alt="image-20200914180535649" style="zoom:25%;" />

- `不可抢占：`占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。`synchronized 是做不到`，synchronized 申请资源的时候，如果申请不到，线程直接进入`阻塞状态`。java.util.concurrent 这个包下面提供的 `Lock` 是可以轻松`解决`这个问题的

- `循环等待：`可以靠`先排序`，然后`按序申请资源`来预防。按照序号从小到大的顺序锁定账户。<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914181031.png" alt="image-20200914181029958" style="zoom:25%;" />

**总结：**用细粒度锁来锁定多个资源时，要注意死锁的问题。识别出风险很重要。

`破坏占用且等待条件`，我们也是`锁了所有的账户`，而且还是用了`死循环` while(!actr.apply(this, target));(**方法实际项目中，应该加个timeout避免一直阻塞**），不过好在 apply() 这个方法基本不耗时。 在转账这个例子中，`破坏循环等待条件就是成本最低`的一个方案。

所以我们在选择具体方案的时候，还需要`评估一下操作成本`，从中选择一个成本最低的方案。

##### “等待-通知”机制`优化while循环等待`

用死循环的方式来循环等待，如果 apply() 操作耗时非常短，而且并发冲突量也不大时，方案可行。但如果`apply() 耗时长，并发大`，循环获取锁太`耗CPU`。需要`等待通知机制`去优化。

`等待 - 通知机制`：线程首先**获取互斥锁**，当线程要求的条件**不满足**时，**释放互斥锁**，进入等待状态；当要求的条件**满足**时，**通知等待的线程，重新获取互斥锁**。

- 获取锁，`获取不到`，将线程放入对象等待池里等待。（对象、互斥锁、对象等待池一一对应）

- 线程进入临界区后，某些`条件不满足`，线程需要调`用对象的wait()方法`，将自己放入`对象等待池`里，并释放持有的互斥锁。

- 当条件满足时调用 notifyAll()，会通知`对象等待池中的线程`，告诉它条件`曾经满足过`（只保证通知的那个时间点条件满足，不保证被唤醒的线程执行时满足，有人可能插队），即将线程`从对象等待池中`的所有线程都移动到该对象的`锁标志等待池`，线程开始抢占锁标志（`只有锁标志等待池中的线程可以获取锁标志`）。

  - 为了解决曾经满足这个问题，当wait()满足时，需要重新检查等待条件。MESA 管程经典范式：

    ```java
    while(条件不满足) {
        wait();
    }
    ```

    用了等待-通知机制，就干掉了Account中的while循环，如果线程获取不到锁，让线程`到Allocator的等待队列里去等`。等别人还回来的通知。

    <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914195703.png" alt="image-20200914195701587" style="zoom:25%;" />

注：除非深思熟虑，否则尽量使用 notifyAll()。notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等待队列中的所有线程。notify() 的随机通知，可能会导致`真正该唤醒的再也没有机会被唤醒`。

何时使用notify() ，满足以下三个条件:

- 所有等待线程拥有`相同的等待条件`；
- 所有等待线程被唤醒后，`执行相同的操作`；
- `只需要唤醒一个线程`。

### （新）安全性、活跃性，以及性能问题

#### 安全性问题

线程安全：其实本质上就是`正确性`，而正确性的含义就`是程序按照我们期望`的执行，不要让我们感到意外。

`理论上`线程安全的程序，就要`避免出现原子性问题、可见性问题和有序性问题`。

`什么情况下`需要分析线程安全问题：存在共享数据并且该数据会发生变化，通俗地讲就是`有多个线程会同时读写同一数据`。

- 那如果能够做到`不共享数据`或者`数据状态不发生`变化，就能够保证线程的安全性。
  - 线程本地存储（Thread Local Storage，TLS）
  - 不变模式

`数据竞争`：当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug

`竞态条件：`指的是程序的执行结果依赖线程执行的顺序。

XX是线程安全带指的是它`方法单独执行的时候没有并发正确性`问题，并不代表把它的操作组合在一起问木有。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200915152625.png" alt="image-20200915152617838" style="zoom:33%;" />

- 在并发场景中，程序的执行依赖于某个状态变量，也就是类似于下面这样：

  ```java
  if (状态变量 满足 执行条件) {
      执行操作
  }
  ```

#### 活跃性问题

指的是某个操作无法执行下去

##### 死锁

线程互相等待，并且一直等待下去

##### 活锁

有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。

理解：线程间`互相谦让`，但再获取时又撞到一起了，又再次谦让，不断循环的情况。

解决：`谦让时，尝试等待一个随机的时间`。降低再次相撞的概率。

案例：Raft 这样知名的分布式一致性算法中。

##### 饥饿

`饥饿：`指的是线程因无法访问所需资源而无法执行下去的情况。

- 如果线程`优先级“不均”`，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；
- `持有锁的线程，如果执行的时间过长`，也可能导致“饥饿”问题。

解决饥饿方案：

- 保证资源充足
- 公平地分配资源：主要是`使用公平锁`。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。
- 避免持有锁的线程长时间执行：

这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。

#### 性能问题

`互斥锁本质`上是管程思想的实现，为了保证线程安全，将`并行的程序串行化`。所以锁的过度使用可能导致串行化的范围过大。

那怎么才能避免锁带来的性能问题呢？

Java SDK 并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能。

- 既然使用锁会带来性能问题，那最好的方案自然就是使用`无锁的算法和数据结构`。
  - 线程本地存储 (Thread Local Storage, TLS)
  - 写入时复制 (Copy-on-write)
  - 乐观锁
  - Java 并发包里面的原子类也是一种无锁的数据结构
  - Disruptor 则是一个无锁的内存队列
- `减少锁持有的时间`：使用管程思想，用**并发包实现更细粒度的锁**
  - 使`用细粒度的锁`：Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术。1.8后没有分段锁 ，是syn + cas
  - `读写锁：`也就是读是无锁的，只有写的时候才会互斥

性能方面的度量指标：

1. `吞吐量：`指的是`单位时间`内能处理的请求数量。吞吐量越高，说明性能越好。
2. `延迟：`指的是从发出请求到收到`响应的时间`。延迟越小，说明性能越好。
3. `并发量：`指的是能`同时处理的请求数量`，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。

#### 总结

并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则表现为安全性、活跃性以及性能问题。

我们在设计并发程序的时候，`主要是从宏观出发，也就是要重点关注它的安全性、活跃性以及性能`。安全性方面要注意数据竞争和竞态条件，活跃性方面需要注意死锁、活锁、饥饿等问题，性能方面我们虽然介绍了两个方案，但是遇到具体问题，你还是要具体分析，根据特定的场景选择合适的数据结构和算法。

### 管程：并发编程的万能钥匙（synchronized：管程的实现）

#### Java管程：MESA模型

`管程技术：`Java 语言在 1.5 之前，提供的唯一的并发原语就是用synchronized实现的管程，而且 1.5 之后提供的 SDK 并发包，也是以管程技术为基础的。

Java 采用的是管程技术，**synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分**。而**管程和信号量是等价的**，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。但是管程更容易使用，所以 Java 选择了管程。

`Monitor(管程/监视器)`：指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。Java 领域的语言，就是`管理类的成员变量`和`成员方法`，让这个类是线程安全的。管程是实现对象监视器的思想。

并发编程领域，有两大核心问题：

- 一个是**互斥**，即同一时刻只允许一个线程访问共享资源：管程解决互斥问题的思路很简单，就是`将共享变量及其对共享变量的操作统一封装起来`

- 另一个是**同步**，即线程之间如何通信、协作：

  - MESA 模型的主要组成部分：每个**条件变量（对象等待池细分：能唤醒对象等待池区域）**都对应有一个**等待队列**

    - 条件等待队列（对象等待池）
    - 入口等待队列（锁标识等待池）

    <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200915162425.png" alt="image-20200915162417017" style="zoom:50%;" />

- **同步一般是建立在互斥**的基础上，只有**资源具有排它性**才需要同步来解决并发编程过程中对资源的协作问题



利用管程思想，实现一个线程安全的阻塞队列：利用Java可重入锁(ReentrantLock)实现。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200915163632.png" alt="image-20200915163630622" style="zoom: 33%;" />

#### Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别：

Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别就是当条件满足后，`如何通知相关线程`。管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行呢？

- `Hasen 模型（嗨森）`里面，要求 `notify() 放在代码的最后`，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。
- `Hoare 模型（霍尔）`里面，T2 通知完 T1 后，`T2 阻塞`，T1 马上执行；等 T1 执行完，`再唤醒 T2`，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤醒操作。（但两个线程，满足你的条件与我何干）
- `MESA 管程（麦撒）`里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，`仅仅是从条件变量的等待队列进到入口等待队列里面（对象等待池->锁标志等待池）`。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个`副作用（曾经满足）`，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。

`MESA模型`和其他两种模型相比可以实现`更好的公平性`，因为唤醒只是把你放到队列里而不保证你一定可以执行，最后能不能执行还是要看你自己可不可以抢得到执行权也就是入口，`其他两种模型是显式地唤醒`，有点`内定`的意思了。

#### 总结

`总结：`Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA 模型中，条件变量可以有多个，`Java 语言内置的管程（synchronized）里只有一个条件变量`。具体如下图所示。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200915164909.png" alt="image-20200915164907349" style="zoom:33%;" />

Java 内置的管程方案（synchronized）使用简单，`synchronized` 关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是`仅支持一个条件变量`；

而 `Java SDK 并发包`实现的管程`支持多个条件变量`，不过**并发包里的锁，需要开发人员自己进行加锁和解锁操作**。

**问题：**wait() 方法，在 Hasen 模型和 Hoare 模型里面，都是没有参数的，而在 MESA 模型里面，增加了超时参数，你觉得这个参数有必要吗？

wait() 方法，增加超时参数，避免没有人唤醒，傻等。如果能时间随机还能避免**活锁**。但是唤醒仅仅保证你有机会争抢锁，如果你优先级比较低，可能会被**饿死**（CPU繁忙，饥饿性死锁）。

### 线程的生命周期？

线程的生命周期，需要搞懂生命周期中各个*节点*的**状态转换机制**。

#### 通用的线程生命周期

通用的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态。

<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200916143232.png" alt="image-20200916143159072" style="zoom: 33%;" />

1. `初始状态`，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是`在编程语言层面被创建`，而在操作系统层面，真正的线程还没有创建。
2. `可运行状态`，`指的是线程可以分配 CPU 执行`。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。
3. 当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被`分配到 CPU` 的线程的状态就转换成了`运行状态`。
4. 运行状态的线程如果调用一个`阻塞的 API`（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会`转换到休眠状态`，同时`释放 CPU 使用权`，*休眠状态的线程永远没有机会获得 CPU 使用权*。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。
5. 线程执行完或者出现异常就会进入`终止状态`，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着`线程的生命周期结束`了。

这五种状态在不同编程语言里会有简化合并。例如，C 语言的 POSIX Threads 规范，就把初始状态和可运行状态合并了；Java 语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而 JVM 层面不关心这两个状态，因为 JVM 把线程调度交给操作系统处理了。除了简化合并，这五种状态也有可能被细化，比如，Java 语言里就细化了休眠状态（这个下面我们会详细讲解）。

线程的生命周期分为新建（NeW）、就绪（ Runnable）、运行（ Running）、阻塞（ Blocked）和死亡（Dead）这5种状态。

![image-20200910153023382](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910153025.png)

- `新建状态：New`在Java中使用new关键字创建一个线程，新创建的线程将处于新建状态。在创建线程时主要是`为线程分配内存(线程私有的区域：程序计数器、虚拟机栈、本地方法栈)并初始化其成员变量的值`

- `就绪状态：Runnab1e`新建的线程对象在调用 start方法之后将转为就绪状态。此时JVM完成了方法调用栈和程序计数器的创建，等待该线程的调度和运行（JVM会调用操作系统的接口创建一个与之对应的原生线程）。

- `运行状态：Running`就绪状态的线程在竞争到CPU的使用权并开始执行run方法的线程执行体时，会转为运行状态，处于运行状态的线程的主要任务就是执行run方法中的逻辑代码。

- `阻塞状态：Waitting` 运行中的线程会主动或被动地放弃CPU的使用权并暂停运行，此时该线程将转为阻塞状态，直到再次进入可运行状态，才有机会再次竞争到CPU使用权并转为运行状态。阻塞的状态分为以下三种。

  1. 等待阻塞：在运行状态的线程调用o.wait方法时，JVM会把该线程放入等待队列（ Waitting Queue）中，线程转为阻塞状态。
  2. 同步阻塞：在运行状态的线程尝试获取正在被其他线程占用的对象同步锁时，JVM会把该线程放入锁池（ Lock Poo1）中，此时线程转为阻塞状态。
  3. 其他阻塞：运行状态的线程在执行 Thread. sleep（long ms）、 Thread.join、 调用socket的 recelver、 accept方法或者发出I/0请求时，，JVM会把该线程转为阻塞状态。直到 sleep()状态超时、 Thread. join等待线程终止或超时，或者I/0处理完毕，线程才重新转为可运行状态。

  ![img](http://static2.iocoder.cn/04a277229fd3b24e058417f9c571681c)

- `线程死亡：Dead`线程在以下面三种方式结束后转为死亡状态。

  - 线程正常结東：run方法或ca11方法执行完成。
  - 线程异常退出：运行中的线程抛出一个 Error或未捕获的Exception，线程异常退出
  - 手动结束：调用线程对象的stop方法手动结束运行中的线程该方式会瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，不推荐使用。



### 线程的基本方法？

线程相关的基本方法有wait、 notify、 notifyAll、 sleep join、 yield等，这些方法控制线程的运行，并影响线程的状态变化。

- `线程等待：wait方法`调用wait方法的线程会进入 WAITING状态，只有等到其他线程的通知或被中断后才会返回。需要注意的是，在调用wait方法后会释放对象的锁，因此wait方法一般被用于同步方法或同步代码块中。

- `线程睡眠：sleep方法`调用 sleep方法会导致当前线程休眠。与wait方法不同的是， sleep方法不会释放当前占有的锁，会导致线程进入 TIMED-WATING状态，而wai方法会导致当前线程进入 WATING状态

- `线程让步：yield方法`调用 yield方法会使当前线程让出（释放）CPU执行时间片，与其他线程一起重新竞争CPU时间片。在一般情况下，优先级高的线程更有可能竞争到CPU时间片，但这不是绝对的，有的操作系统对线程的优先级并不敏感。

- `线程中断：interrupt方法`Interrupt方法用于向线程发行一个`终止通知信号`，会影响该线程内部的一个中断标识位，这个线程木身并不会因为调用了 interrupt方法而改变状态（阻塞、终止等）。状态的具体变化需要等待接收到中断标识的程序的最终处理结果来判定。对 interrupt方法的理解需要注意以下4个核心点
  - `调用 interrupt方法并不会中断一个正在运行的线程`，也就是说处于 Running状态的线程并不会因为被中断而终止，仅仅改变了内部维护的中断标识位而已。
  - 若因为调用 sleep方法而使线程处于 TIMED- WATING状态，则这时调用 interrupt方法会抛出 InterruptedException，使线程提前结東TIMED-WATING状态
  - 许多声明抛出 InterruptedException的方法如Thread. sleep（ long mills），`在抛出异常前都会清除中断标识位`，所以在抛出异常后调用 interrupted方法将会返回 false。
  - 中断状态是线程固有的一个标识位，可以通过此标识位安全终上线程。比如，在想终止一个线程时，可以先调用该线程的 Interrupt方法，然后在线程的run方法中根据该线程 isInterrupted方法的返回状态值安全终止线程
  
- `线程加入：join方法`join方法用于等待其他线程终止，如果在当前线程中调用一个线程的join方法，则当前线程转为阻塞状态，等到另一个线程结束，前线程再由阻塞状态转为就绪状态，等待获取CPU的使用权。在很多情况下，主线程生成并启动了子线程，需要等到子线程返回结果并收集和处理再退出，这时就要用到join方法，具体的使用方法如下![](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910173847.png)

- `线程唤醒：notify方法`Object类有个 notify方法，用于唤醒在此对象监视器上等待的一个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的。
  `实战：`我们通常调用其中一个对象的wait方法在对象的监视器上等待，直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他线程竞争。类似的方法还有 notify1l，用于唤醒在监视器上等待的所有线程
  
- `后台守护线程：setDaemon方法`setDaemon方法用于定义一个守护线程，也叫作“服务线程”，该线程是后台线程，有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。
  
  守护线程的`优先级较低`，用于为系统中的其他对象和线程提供服务。将一个用户线程设置为守护线程的方法是在线程`对象创建之前（start之前）`用线程对象的 setDaemon（true）来`设置`。
  
  在后台守护线程中定义的线程（子线程）也是后台守护线程。后台`守护线程是JVM级别`的，比如垃圾回收线程就是一个经典的守护线程，在我们的程序中不再有任何线程运行时，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以在回收JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态下运行，用于实时监控和管理系统中的可回收资源。
  `实战：`守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。也就是说，守护线程`不依赖于终端，但是依赖于JVM，与JVM“同生共死”`。在JM中的所有线程都是守护线程时，JVM就可以退出了，如果还有一个或一个以上的非守护线程，则JVM不会退出。

![image-20200910175149849](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910175151.png)

####  （待整理）sleep方法与wait方法的区别？

- sleep方法属于 `Thread类`的静态方法，wait方法则属于 `Object类`。
-  wait只能在同步方法和同步块中使用，而`sleep任何地方`都可以。
- wait无需捕捉异常，而sleep需要捕捉`抛出 InterruptException异常`。
- 线程调用当前对象的wait()方法会`让渡CPU`执行时间，并释放对象的“`锁标志`”，将该线程放入`对象等待池（wait pool）`。只有调用对象的notify() 和 notifyAll()方法时，才会把线程从对象等待池挪到`锁标志等待池（lock pool）`中去让他们重新争抢锁标识，线程重新`获得对象的锁就可以进入就绪状态`。
- sleep方法暂停执行指定的时间，`让出CPU`给其他线程，但`不会释放对象锁`，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。其他线程依旧在对象等待池，在`指定的时间过后又会自动恢复到就绪状态`。
- 在调用 `sleep方法`的过程中，线程`不会释放对象锁`。

#### start方法与run方法的区别?

- start方法用于启动线程，真正实现了多线程运行。在调用了线程的 start方法后，线程会在`后台执行`，`无须等待run方法体的代码执行完毕`，就可以继续执行下面的代码
- 在通过调用 Thread类的 `start方法启动`一个线程时，此线程处于`就绪状态`，并没有运行。
- run方法也叫作线程体，包含了要执行的线程的逻辑代码，`在调用run方法后`，不会创建线程，线程就进入`运行状态`，开始运行run方法中的代码。`在run方法运行结束后，该线程终止`，CPU再调度其他线程。（不会创建线程，就一个普通方法）

#### 线程的 sleep 方法和 yield 方法有什么区别？

- `sleep 方法`给其他线程运行机会时`不考虑线程的优先级`，因此会给低优先级的线程以运行的机会。`yield 方法只会给相同优先级或更高优先级的线程以运行的机会`。
- 线程执行 `sleep 方法后转入阻塞（blocked）状态`，而执行 `yield 方法后转入就绪（ready）状态`。
- sleep 方法声明抛出 InterruptedException 异常，而 yield 方法没有声明任何异常。
- `sleep 方法`比 yield 方法（跟操作系统 CPU 调度相关）`具有更好的可移植性`。

#### 为什么 Thread 类的 sleep 和 yield 方法是静态的？

Thread 类的 sleep 和 yield 方法，将在`当前正在执行的线程上运行`。

所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。

#### sleep(0) 有什么用途？

`Thread#sleep(0)` 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 `Thread#sleep(0)` 方法，把当前线程确实的被冻结了一下，`让其他线程有机会优先执行`。`Thread#sleep(0)` 方法，是你的线程`暂时放弃 CPU` ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个**让位动作**。

为了防止循环检查条件时，一直占用CPU时间片做无用功。交出CPU时间片，让别人干。

[《Sleep(0) 的妙用》](https://blog.csdn.net/qiaoquan3/article/details/56281092) ：假如AB两个线程为合作关系，A线程处理一些原始数据，数据处理到一定程度，交给B线程处理，在A处理原始数据的时候，B也要做一些准备工作，所以，AB是并发的，但是B做好准备之后，需要等待A处理好那些数据，接过A的数据，继续处理，因此，这个等待，如果A不使用信号或者等待条件来通知B的话，那么B必须一直轮询，查看A是否已完成，B线程所做的这个轮询是否会一直占用CPU来做无用的循环查看呢？因此B这个时候占用的cpu时间片做的是无用功，因此，这里sleep(0)就有作用，当B查看A没处理完数据的时候，B马上sleep(0)交出B的时间片，让操作系统调度A来运行(假设只有AB两个线程），那么这个时候，A就会得到充分的时间来处理它的数据。

![image-20200910195136862](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910195138.png)

#### 定义一个可以安全退出的线程？

![image-20200910173135789](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910173137.png)

注：`在抛出异常前都会清除中断标识位`，所以需要在catch里重新设置中断标识。方便后续判断，做一些资源释放工作。

### 终止线程的4中方式？

1. `正常运行结束`指线程体执行完成，线程自动结束

2. `使用退出标志退出`可以使用一个变量来控制循环，比如设置一个 boolean类型的标志，并通过设置这个标志为true或false来控制 while循环是否退出，在定义exit时使用了一个Java关键字 `volatile`，这个关键字用于使exit线程同步安全，也就是说在同一时刻只能有一个线程修改exit的值，在exit为true时， While循环退出。

   ![image-20200910162721647](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910162722.png)

3. 使用interrupted方法终止线程，有一线两种情况：

   - 线程处于阻塞状态。当线程处于阻塞状态：s`leep()、wait()、join()或者调用 socket的 recelver、 accept等方法时`。在调用该线程的 Interrupt方法时，会抛出 InterruptException异常。我们通过代码捕获该异常，然后通过 break跳出状态检测循环(`在抛出异常前都会清除中断标识位，不break就会死循环`)，可以有机会结束这个线程的执行。

   - 线程未处于阻塞状态。此时，使用 isInterrupt方法判断线程的中断标志来退出循环（当标识用）。在调用 interrupt方法时，中断标志会被设置为true，并不能立刻退出线程，而是执行线程终止前的资源释放操作，等待资源释放完毕后退出该线程。

     ![image-20200910164038659](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910164040.png)

4. `使用stop方法终止线程：不安全`就像突然关闭计算机的电源，可能会产生不可预料的后果。在程序使用 Thread.stop方法终止线程时，瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，被保护的数据就可能岀现不一致的情况，并不推荐采用这种方法终止线程。

#### interrupted 和 isInterrupted 方法的区别？

`Thread#interrupted()` **静态**方法，查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 `#interrupted()` 方法则返回 `true` ，第二次和后面的就返回 `false` 了。线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程（用是否抛出异常来判断）的状态为并做处理。

`Thread#isInterrupted()` 方法，查询指定线程的中断状态，不会清除原状态。

### 为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？为什么 wait 和 notify 方法要在同步块中调用？

这三个是方法用于Java中锁对于线程间的等待通知机制的实现。三个方法能够被调用的前提是已经获取了对象的互斥锁。

Java提供的锁是属于对象的，每个对象都有唯一的一把锁标识。通过让线程争抢唯一的锁标识，并让争抢锁失败、或者主动放弃锁的线程，进入对象等待池中，来保证在线程并发的情况下，对共享资源操作的原子性，和先线程间的互斥。

wait()是让线程主动放弃锁，并进入对象等待池。而notify() 和 notifyAll()是把线程从对象等待池挪到锁标志等待池中去让他们重新争抢锁标识。

总之对象负责协调线程的工作，而 wait, notify 和 notifyAll 方法是对象协调线程互斥的手段。所以这三个方法需要放到Object中。

#### [为什么 wait 和 notify 方法要在同步块中调用？](https://blog.csdn.net/lsgqjh/article/details/61915074)

- wait()、notify()、notifyAll() 这三个方法能够被调用的`前提`是已经`获取了相应的互斥锁。`所以是在 synchronized{}内部被调用的。

- Java API 强制要求这样做，如果在synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，你的代码会`抛出 IllegalMonitorStateException异常`。
- 还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。

## 熟悉

### 常见的Java线程的4种创建方式

常见的Java线程的4种创建方式分别为：继承 Thread类、实现Runnable接口、通过 ExecutorService和 Callable< Class>实现有返回值的线程、基于线程池。

### ThreadPoolExecutor构造函数的具体参数?

corePoolSize:线程池核心线程数

![image-20200910142116416](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910142118.png)

### Java线程池的工作流程？

线程池刚被创建时，只是向系统申请个用于执行线程队列和管理线程池的线程资源。在调用 execute()添加一个任务时，线程池会按照以下流程执行任务:

- 如果正在运行的线程数量少于 corepoolsize（用户定义的核心线程数），线程池就会立刻创建线程并执行该线程任务
- 如果正在运行的线程数量大于等于 corepoolsize，该任务就将被放入阻塞队列中
- 在阻塞队列已满且正在运行的线程数量少于 maximumPoolsize时，线程池会创建非核心线程立刻执行该线程任务。
- 在阻塞队列已满且正在运行的线程数量大于等于maximumPoolsize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。
- 在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行。
- 在线程处于空闲状态的时间超过 keepAliveTime时间时，正在运行的线程数量超过 corepoolsize，该线程将会被认定为空闲线程并停止。因此在线程池中所有线程任务都执行完毕后，线程池会收缩到corepoo1Size大小

![image-20200910142404013](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910142405.png)

### 线程池的拒绝策略有哪些？

ThreadPoolExecutor 默认有四个拒绝策略：

- `ThreadPoolExecutor.AbortPolicy()` ，直接抛出异常 RejectedExecutionException 。
- `ThreadPoolExecutor.CallerRunsPolicy()` ，直接调用 run 方法并且阻塞执行。（不会真的丢弃任务）
- `ThreadPoolExecutor.DiscardPolicy()` ，直接丢弃后来的任务。
- `ThreadPoolExecutor.DiscardOldestPolicy()` ，丢弃在队列中队首的任务，并尝试提交当前任务。

如果我们有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑。当然，绝大多数是不需要的。

### 创建线程池的几种方式？

Java 类库提供一个灵活的线程池以及一些有用的默认配置，我们可以通过Executors 的静态方法来创建线程池。

- - 1、

    ```java
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads);
    ```

    方法，创建一个固定长度的线程池。

    - 每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，新任务将在阻塞队列中排队。
    - 当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

  - 2、

    ```java
    ExecutorService cacheThreadPool = Executors.newCachedThreadPool();
    ```

     方法，创建一个可缓存的线程池。

    - 创建新线程时如果有可重用的线程，则重用它们，否则重新创建一个新的线程并将其添加到线程池中。
    - 在线程池的 keepAliveTime时间超过默认的60秒后，该线程会被终止并从缓存中移除，因此在没有线程任务运行时， newCachedThreadPool将不会占用系统的线程资源
    - 创建新线程复杂，且耗时。在有执行时间很短的大量任务需要执行的情况下， newCachedThreadPool能够很好地复用运行中的线程（任务已经完成但未关闭的线程）资源来提高系统的运行效率。

  - 3、

    ```java
    ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();
    ```

    方法，创建一个单线程的线程池。

    - 它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。
    - 它的特点是，能确保依照任务在队列中的顺序来串行执行。

  - 4、

    ```java
    ExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(int corePoolSize);
    ```

    方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。

  - 5、

    ```java
    ExecutorService newWorkStealingPool = Executors.newWorkStealingPool();
    ```

    - 创建持有足够线程的抢占式线程池来达到快速运算的目的，在内部通过使用多个队列来减少各个线程调度产生的竞争。
    - 足够的线程就是处理器的数量一样多的线程，`Runtime.getRuntime().availableProcessors()`以保障线程的快速执行，并很大程度地使用系统资源，提高并发计算的效率，省去用户根据CPU瓷源估算并行度的过程。
    - 如果开发者想自己定义线程的并发数，则也可以将其作为参数传入。



## 了解

### （新）并发编程和并行编程有什么区别？

并发（Concurrency）和并行（Parallellism）是：

并行编程是指同一时刻没有关系的两个事件执行各自的任务

并发编程是指在一个时间段两个事件相互协作，为了完成一个任务。

所以并发编程的目标是，充分的利用处理器的每一个核，以达到最高的处理性能。

#### 并发和并行的区别？

- 并发：同一时间段，多个任务都在执行（单位时间内不一定同时执行）；
- 并行：单位时间内，多个任务同时执行。

### （新）同步和异步有何异同，在什么情况下分别使用他们？

如果`数据将在线程间共享`。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行**同步**存取。

当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用**异步**编程，在很多情况下采用异步途径往往更有效率。

### 一个线程运行时发生异常会怎样？

如果异常没有被捕获该线程将会停止执行。

`Thread.UncaughtExceptionHandler` 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 `Thread#getUncaughtExceptionHandler()` 方法来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 `#uncaughtException(exception)` 方法进行处理。

具体的使用，可以看看 [《JAVA 多线程之 UncaughtExceptionHandler —— 处理非正常的线程中止》](https://blog.csdn.net/u013256816/article/details/50417822) 。

### notify 和 notifyAll 有什么区别？

当一个线程进入 wait 之后，就必须等其他线程 notify/notifyAll 。

- 使用 `notifyAll,可以唤醒所有处`于 wait 状态的线程，使其重新进入锁的争夺队列中，而 `notify 只能唤醒`一个。
- 如果没把握，建议 notifyAll ，防止 notify 因为信号丢失而造成程序错误（`真正该唤醒的线程就再也没有机会被唤醒`）。

`注：`假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。

关于 notify 的信息丢失，可以看看 [《wait 和 notify 的坑》](https://www.jianshu.com/p/91d95bb5a4bd) 文章。

### 为什么你应该在循环中检查等待条件？

处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。

所以，我们不能写 `if (condition)` 而应该是 `while (condition)` ，特别是 CAS 竞争的时候。示例代码如下：

```
// The standard idiom for using the wait method
synchronized (obj) {
    while (condition does not hold) {
        obj.wait(); // (Releases lock, and reacquires on wakeup)
    }
    ... // Perform action appropriate to condition
}
```

- 另外，也可以看看 [《wait 必须放在 while 循环里面的原因探析》](https://blog.csdn.net/qq_35181209/article/details/77362297)

### 你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？

> 考点，就是 join 方法。

我们可以使用 Thread 类的 `#join()` 方法，来确保所有程序创建的线程在 main 方法退出前结束。

### （新）什么是CPU超线程技术？

超线程技术通俗来讲就是一个人干活慢，于是就又模拟出另一个人一起干活，但实际工作人数未增加。通过特殊硬件指令，将两个逻辑内核模拟为两个物理芯片。让一个物理核心充当两个核心的角色，原本任务只能有一颗核心用单一线程进行处理，但在超线程技术的加持下，单颗核心可以同时对多个任务同时展开工作，利用了CPU的空闲时间，增加了芯片的工作效率，性能得到有效的提升。

### （新）XXX是线程安全的吗？

#### Servlet 是线程安全吗？

Servlet `不是`线程安全的，Servlet 是`单实例多线程`的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。

#### Struts2 是线程安全吗

Struts2 的 Action 是`多实例多线程`的，`是`线程安全的，每个请求过来都会 `new` 一个新的 Action 分配给这个请求，请求完成后销毁。

#### SpringMVC 是线程安全吗？

`不是`的，和 Servlet 类似的处理流程。

### （新）何在两个线程间共享数据？

在两个线程间**共享变量**，即可实现共享。

一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。

### （新）怎么检测一个线程是否拥有锁？

调用 `Thread#holdsLock(Object obj)` **静态**方法，它返回 `true` 如果当且仅当当前线程拥有某个具体对象的锁。代码如下：

```
// Thread.java

public static native boolean holdsLock(Object obj);
```

### （新）如何判断多线程的阻塞导致的问题？

可以用top命令查看Java线程的cpu利用率，用jstack来dump线程。开发环境可以用 java visualvm查看线程执行情况

### （新）10 个线程和 2 个线程的同步代码，哪个更容易写？

从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。

但是同步策略的选择依赖于线程的数量，`因为越多的线程意味着更大的竞争`，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。

### 我们用多核多线程相比单核单线程能提速多少呢？

有个阿姆达尔（Amdahl）定律，代表了处理器并行运算之后效率提升的能力，它正好可以解决这个问题，具体公式如下：

![image-20200915154642053](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200915154643.png)

公式里的 n 可以理解为 CPU 的核数，p 可以理解为并行百分比，那（1-p）就是串行百分比了，也就是我们假设的 5%。我们再假设 CPU 的核数（也就是 n）无穷大，那加速比 S 的极限就是 20。也就是说，如果我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。

串行百分比一般怎么得出来呢？

临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比

### （待整理）Java 语言提供的 Vector 是一个线程安全的容器，有同学写了下面的代码，你看看是否存在并发问题呢？

```java

void addIfNotExist(Vector v, 
    Object o){
  if(!v.contains(o)) {
    v.add(o);
  }
}
```

Vector实现线程安全是通过给主要的写方法加了synchronized，类似contains这样的读方法并没有synchronized，该题的问题就出在不是线程安全的contains方法，两个线程如果同时执行到if(!v.contains(o)) 是可以都通过的，这时就会执行两次add方法，重复添加。也就是老师说的竞态条件。

vector是线程安全，指的是它方法单独执行的时候没有并发正确性问题，并不代表把它的操作组合在一起问木有，而这个程序显然有老师讲的竞态条件问题。

解决方案：给Vector对象加锁

```java
void addIfNotExist(Vector v,
    Object o){
synchronized(v) {
  if(!v.contains(o)) {
    v.add(o);
  }
}
}
```

为什么给addIfNotExist方法加锁不行。

- 因为addIfNotExist不是Vector方法，可能代码其他地方也在调用Vector::add方法，改变数组内容。

### （待整理）信号量和管程

信号量机制是可以解决同步/互斥的问题的，但是信号量的操作分散在各个进程或线程中，不方便进行管理，因每次需调用PV操作，还可能导致死锁或破坏互斥请求的问题。

管程是定义了一个数据结构和能为并发所执行的一组操作，这组操作能够进行同步和改变管程中的数据。这相当于对临界资源的同步操作都集中进行管理，凡是要访问临界资源的进程或线程，都必须先通过管程，由管程的这套机制来实现多进程或线程对同一个临界资源的互斥访问和使用。管程的同步主要通过condition类型的变量（条件变量），条件变量可执行操作wait()和signal()。管程一般是由语言编译器进行封装，体现出OOP中的封装思想，也如老师所讲的，管程模型和面向对象高度契合的。