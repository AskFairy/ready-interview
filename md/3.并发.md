# 并发

## 精通

### （新）简述线程、进程、程序的基本概念？

`程序`，存储在磁盘上的能够`被系统运行`的含有`指令`和`数据`的文件。

`进程`，是系统运行程序的基本单位。当程序在执行时，将会被操作系统载入内存中，计算机运行程序的指令，去操作数据，`正在执行中的程序，就是进程`。

`线程`，与进程相似，但线程是一个比进程更小的执行单位，被称为轻量级进程。一个进程在其执行的过程中可以产生多个线程。

基本上各进程是独立的，但同一进程中的线程极有可能会，互相协作，相互影响。

`线程可以理解为需要CPU处理的细分任务，进程就是线程汇总出来为人类实现特定功能，它和卖CPU说的8核16线程可不是一个概念，16线程相当于16个虚拟核心`。

### （新）多线程的优缺点？

1）好处

- 使用多线程可以把`程序中占据时间长的任务放到后台`去处理，如图片、视屏的下载。
- 发挥`多核处理器的优势`，并发执行让系统运行的更快、更流畅，用户体验更好。

2）坏处

- 大量的线程`降低代码的可读性`。
- 更多的线程需要`更多的内存空间`。
- 当多个线程对同一个资源出现争夺时候要注意`线程安全的问题`。

### （新）什么是多线程上下文切换？

多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU 。

`不同的线程切换使用 CPU 发生的切换数据`等，就是上下文切换。

### Java 中用到的线程调度算法是什么？

一个多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。Java 虚拟机的一项任务就是负责按照特定机制为多个线程分配 CPU 的使用权。

有两种调度模型：分时调度模型和抢占式调度模型。

- `分时调度模型`是指让所有的线程`轮流`获得 CPU 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。
- Java 虚拟机采用`抢占式调度模型`，是指优先让可运行池中`优先级高的线程占用 CPU` ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 。容易`导致其他线程饥饿`。

#### 什么是线程饥饿？

饥饿，一个或者多个线程因为种种原因无法获得所需要的资源（数据、CPU时间片、运行指令等），导致一直无法执行的状态。

Java 中导致饥饿的原因：

- `高优先级线程`吞噬所有的低优先级线程的 CPU 时间。
- `线程被永久堵塞在一个等待进入同步块的状态`，因为其他线程总是能在它之前持续地对该同步块进行访问。
- `线程在等待一个本身也处于永久等待完成的对象`(比如调用这个对象的 `wait 方法`)，因为其他线程总是被持续地获得唤醒。

#### 你对线程优先级的理解是什么？

每一个线程都是有优先级的，一般来说，`高优先级的线程在运行时会具有优先权`。线程优先级是一个 int 变量(从`1-10`)，1 代表最低优先级，10 代表最高优先级。我们可以定义线程的优先级，但是这并`不能保证高优先级`的线程会在低优先级的线程前`执行`。Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。

### 线程的生命周期？

线程的生命周期分为新建（NeW）、就绪（ Runnable）、运行（ Running）、阻塞（ Blocked）和死亡（Dead）这5种状态。

![image-20200910153023382](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910153025.png)

- `新建状态：New`在Java中使用new关键字创建一个线程，新创建的线程将处于新建状态。在创建线程时主要是`为线程分配内存(线程私有的区域：程序计数器、虚拟机栈、本地方法栈)并初始化其成员变量的值`

- `就绪状态：Runnab1e`新建的线程对象在调用 start方法之后将转为就绪状态。此时JVM完成了方法调用栈和程序计数器的创建，等待该线程的调度和运行（JVM会调用操作系统的接口创建一个与之对应的原生线程）。

- `运行状态：Running`就绪状态的线程在竞争到CPU的使用权并开始执行run方法的线程执行体时，会转为运行状态，处于运行状态的线程的主要任务就是执行run方法中的逻辑代码。

- `阻塞状态：Waitting` 运行中的线程会主动或被动地放弃CPU的使用权并暂停运行，此时该线程将转为阻塞状态，直到再次进入可运行状态，才有机会再次竞争到CPU使用权并转为运行状态。阻塞的状态分为以下三种。

  1. 等待阻塞：在运行状态的线程调用o.wait方法时，JVM会把该线程放入等待队列（ Waitting Queue）中，线程转为阻塞状态。
  2. 同步阻塞：在运行状态的线程尝试获取正在被其他线程占用的对象同步锁时，JVM会把该线程放入锁池（ Lock Poo1）中，此时线程转为阻塞状态。
  3. 其他阻塞：运行状态的线程在执行 Thread. sleep（long ms）、 Thread.join、 调用socket的 recelver、 accept方法或者发出I/0请求时，，JVM会把该线程转为阻塞状态。直到 sleep()状态超时、 Thread. join等待线程终止或超时，或者I/0处理完毕，线程才重新转为可运行状态。

  ![img](http://static2.iocoder.cn/04a277229fd3b24e058417f9c571681c)

- `线程死亡：Dead`线程在以下面三种方式结束后转为死亡状态。

  - 线程正常结東：run方法或ca11方法执行完成。
  - 线程异常退出：运行中的线程抛出一个 Error或未捕获的Exception，线程异常退出
  - 手动结束：调用线程对象的stop方法手动结束运行中的线程该方式会瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，不推荐使用。



### 线程的基本方法？

线程相关的基本方法有wait、 notify、 notifyAll、 sleep join、 yield等，这些方法控制线程的运行，并影响线程的状态变化。

- `线程等待：wait方法`调用wait方法的线程会进入 WAITING状态，只有等到其他线程的通知或被中断后才会返回。需要注意的是，在调用wait方法后会释放对象的锁，因此wait方法一般被用于同步方法或同步代码块中。

- `线程睡眠：sleep方法`调用 sleep方法会导致当前线程休眠。与wait方法不同的是， sleep方法不会释放当前占有的锁，会导致线程进入 TIMED-WATING状态，而wai方法会导致当前线程进入 WATING状态

- `线程让步：yield方法`调用 yield方法会使当前线程让出（释放）CPU执行时间片，与其他线程一起重新竞争CPU时间片。在一般情况下，优先级高的线程更有可能竞争到CPU时间片，但这不是绝对的，有的操作系统对线程的优先级并不敏感。

- `线程中断：interrupt方法`Interrupt方法用于向线程发行一个`终止通知信号`，会影响该线程内部的一个中断标识位，这个线程木身并不会因为调用了 interrupt方法而改变状态（阻塞、终止等）。状态的具体变化需要等待接收到中断标识的程序的最终处理结果来判定。对 interrupt方法的理解需要注意以下4个核心点
  - `调用 interrupt方法并不会中断一个正在运行的线程`，也就是说处于 Running状态的线程并不会因为被中断而终止，仅仅改变了内部维护的中断标识位而已。
  - 若因为调用 sleep方法而使线程处于 TIMED- WATING状态，则这时调用 interrupt方法会抛出 InterruptedException，使线程提前结東TIMED-WATING状态
  - 许多声明抛出 InterruptedException的方法如Thread. sleep（ long mills），`在抛出异常前都会清除中断标识位`，所以在抛出异常后调用 interrupted方法将会返回 false。
  - 中断状态是线程固有的一个标识位，可以通过此标识位安全终上线程。比如，在想终止一个线程时，可以先调用该线程的 Interrupt方法，然后在线程的run方法中根据该线程 isInterrupted方法的返回状态值安全终止线程
  
- `线程加入：join方法`join方法用于等待其他线程终止，如果在当前线程中调用一个线程的join方法，则当前线程转为阻塞状态，等到另一个线程结束，前线程再由阻塞状态转为就绪状态，等待获取CPU的使用权。在很多情况下，主线程生成并启动了子线程，需要等到子线程返回结果并收集和处理再退出，这时就要用到join方法，具体的使用方法如下![](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910173847.png)

- `线程唤醒：notify方法`Object类有个 notify方法，用于唤醒在此对象监视器上等待的一个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的。
  `实战：`我们通常调用其中一个对象的wait方法在对象的监视器上等待，直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他线程竞争。类似的方法还有 notify1l，用于唤醒在监视器上等待的所有线程
  
- `后台守护线程：setDaemon方法`setDaemon方法用于定义一个守护线程，也叫作“服务线程”，该线程是后台线程，有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。
  
  守护线程的`优先级较低`，用于为系统中的其他对象和线程提供服务。将一个用户线程设置为守护线程的方法是在线程`对象创建之前（start之前）`用线程对象的 setDaemon（true）来`设置`。
  
  在后台守护线程中定义的线程（子线程）也是后台守护线程。后台`守护线程是JVM级别`的，比如垃圾回收线程就是一个经典的守护线程，在我们的程序中不再有任何线程运行时，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以在回收JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态下运行，用于实时监控和管理系统中的可回收资源。
  `实战：`守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。也就是说，守护线程`不依赖于终端，但是依赖于JVM，与JVM“同生共死”`。在JM中的所有线程都是守护线程时，JVM就可以退出了，如果还有一个或一个以上的非守护线程，则JVM不会退出。

![image-20200910175149849](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910175151.png)

####  sleep方法与wait方法的区别？

- sleep方法属于 `Thread类`的静态方法，wait方法则属于 `Object类`。
- sleep方法暂停执行指定的时间，`让出CPU`给其他线程，但其监控状态依然保持，在指定的时间过后又会自动恢复到就绪状态。
- 在调用 `sleep方法`的过程中，线程`不会释放对象锁`。
- 在调用`wait方法`时，线程会`放弃对象锁`，进入等待此对象的`等待池（wait pool）`，只有针对此对象`调用 notify方法后`，才能唤醒等待池中的线程进入`等锁池（lock pool）`，如果线程重新获得对象的锁就可以进入就绪状态。

#### start方法与run方法的区别?

- start方法用于启动线程，真正实现了多线程运行。在调用了线程的 start方法后，线程会在`后台执行`，`无须等待run方法体的代码执行完毕`，就可以继续执行下面的代码
- 在通过调用 Thread类的 `start方法启动`一个线程时，此线程处于`就绪状态`，并没有运行。
- run方法也叫作线程体，包含了要执行的线程的逻辑代码，`在调用run方法后`，不会创建线程，线程就进入`运行状态`，开始运行run方法中的代码。`在run方法运行结束后，该线程终止`，CPU再调度其他线程。（不会创建线程，就一个普通方法）

#### 线程的 sleep 方法和 yield 方法有什么区别？

- `sleep 方法`给其他线程运行机会时`不考虑线程的优先级`，因此会给低优先级的线程以运行的机会。`yield 方法只会给相同优先级或更高优先级的线程以运行的机会`。
- 线程执行 `sleep 方法后转入阻塞（blocked）状态`，而执行 `yield 方法后转入就绪（ready）状态`。
- sleep 方法声明抛出 InterruptedException 异常，而 yield 方法没有声明任何异常。
- `sleep 方法`比 yield 方法（跟操作系统 CPU 调度相关）`具有更好的可移植性`。

#### 为什么 Thread 类的 sleep 和 yield 方法是静态的？

Thread 类的 sleep 和 yield 方法，将在`当前正在执行的线程上运行`。

所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。

#### sleep(0) 有什么用途？

`Thread#sleep(0)` 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 `Thread#sleep(0)` 方法，把当前线程确实的被冻结了一下，`让其他线程有机会优先执行`。`Thread#sleep(0)` 方法，是你的线程`暂时放弃 CPU` ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个**让位动作**。

为了防止循环检查条件时，一直占用CPU时间片做无用功。交出CPU时间片，让别人干。

[《Sleep(0) 的妙用》](https://blog.csdn.net/qiaoquan3/article/details/56281092) ：假如AB两个线程为合作关系，A线程处理一些原始数据，数据处理到一定程度，交给B线程处理，在A处理原始数据的时候，B也要做一些准备工作，所以，AB是并发的，但是B做好准备之后，需要等待A处理好那些数据，接过A的数据，继续处理，因此，这个等待，如果A不使用信号或者等待条件来通知B的话，那么B必须一直轮询，查看A是否已完成，B线程所做的这个轮询是否会一直占用CPU来做无用的循环查看呢？因此B这个时候占用的cpu时间片做的是无用功，因此，这里sleep(0)就有作用，当B查看A没处理完数据的时候，B马上sleep(0)交出B的时间片，让操作系统调度A来运行(假设只有AB两个线程），那么这个时候，A就会得到充分的时间来处理它的数据。

![image-20200910195136862](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910195138.png)

#### 定义一个可以安全退出的线程？

![image-20200910173135789](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910173137.png)

注：`在抛出异常前都会清除中断标识位`，所以需要在catch里重新设置中断标识。方便后续判断，做一些资源释放工作。

### 终止线程的4中方式？

1. `正常运行结束`指线程体执行完成，线程自动结束

2. `使用退出标志退出`可以使用一个变量来控制循环，比如设置一个 boolean类型的标志，并通过设置这个标志为true或false来控制 while循环是否退出，在定义exit时使用了一个Java关键字 `volatile`，这个关键字用于使exit线程同步安全，也就是说在同一时刻只能有一个线程修改exit的值，在exit为true时， While循环退出。

   ![image-20200910162721647](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910162722.png)

3. 使用interrupted方法终止线程，有一线两种情况：

   - 线程处于阻塞状态。当线程处于阻塞状态：s`leep()、wait()、join()或者调用 socket的 recelver、 accept等方法时`。在调用该线程的 Interrupt方法时，会抛出 InterruptException异常。我们通过代码捕获该异常，然后通过 break跳出状态检测循环(`在抛出异常前都会清除中断标识位，不break就会死循环`)，可以有机会结束这个线程的执行。

   - 线程未处于阻塞状态。此时，使用 isInterrupt方法判断线程的中断标志来退出循环（当标识用）。在调用 interrupt方法时，中断标志会被设置为true，并不能立刻退出线程，而是执行线程终止前的资源释放操作，等待资源释放完毕后退出该线程。

     ![image-20200910164038659](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910164040.png)

4. `使用stop方法终止线程：不安全`就像突然关闭计算机的电源，可能会产生不可预料的后果。在程序使用 Thread.stop方法终止线程时，瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，被保护的数据就可能岀现不一致的情况，并不推荐采用这种方法终止线程。

#### interrupted 和 isInterrupted 方法的区别？

`Thread#interrupted()` **静态**方法，查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 `#interrupted()` 方法则返回 `true` ，第二次和后面的就返回 `false` 了。线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程（用是否抛出异常来判断）的状态为并做处理。

`Thread#isInterrupted()` 方法，查询指定线程的中断状态，不会清除原状态。

### 为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？

锁要保护的是代码对数据的操作不出错。在java面向对象思想中，资源就是对象。所以Java 提供的锁是对象级的，锁属于对象。并且每个对象都有锁，可以通过线程获得。 

wait，notify 和 notifyAll 方法都是锁用于线程之间通信的，通知线程什么时间该来，什么时间可以离开干别的，所以把它们定义在 Object 类中。

`一个是从观察者模式的角度，对象是被观察者，线程是观察者。被观察者的状态如果发生变化，理应有被观察者去轮询通知观察者，否则的话，观察者怎么知道notify方法应该在哪个时刻调用？n个观察者的notify又如何做到同时调用？再说了，在Thread里，谁调用啊？没人调用就不干活了？`

#### [为什么 wait 和 notify 方法要在同步块中调用？](https://blog.csdn.net/lsgqjh/article/details/61915074)

- Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。
- 还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。

## 熟悉

### 常见的Java线程的4种创建方式

常见的Java线程的4种创建方式分别为：继承 Thread类、实现Runnable接口、通过 ExecutorService和 Callable< Class>实现有返回值的线程、基于线程池。

### ThreadPoolExecutor构造函数的具体参数?

corePoolSize:线程池核心线程数

![image-20200910142116416](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910142118.png)

### Java线程池的工作流程？

线程池刚被创建时，只是向系统申请个用于执行线程队列和管理线程池的线程资源。在调用 execute()添加一个任务时，线程池会按照以下流程执行任务:

- 如果正在运行的线程数量少于 corepoolsize（用户定义的核心线程数），线程池就会立刻创建线程并执行该线程任务
- 如果正在运行的线程数量大于等于 corepoolsize，该任务就将被放入阻塞队列中
- 在阻塞队列已满且正在运行的线程数量少于 maximumPoolsize时，线程池会创建非核心线程立刻执行该线程任务。
- 在阻塞队列已满且正在运行的线程数量大于等于maximumPoolsize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。
- 在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行。
- 在线程处于空闲状态的时间超过 keepAliveTime时间时，正在运行的线程数量超过 corepoolsize，该线程将会被认定为空闲线程并停止。因此在线程池中所有线程任务都执行完毕后，线程池会收缩到corepoo1Size大小

![image-20200910142404013](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910142405.png)

### 线程池的拒绝策略有哪些？

ThreadPoolExecutor 默认有四个拒绝策略：

- `ThreadPoolExecutor.AbortPolicy()` ，直接抛出异常 RejectedExecutionException 。
- `ThreadPoolExecutor.CallerRunsPolicy()` ，直接调用 run 方法并且阻塞执行。（不会真的丢弃任务）
- `ThreadPoolExecutor.DiscardPolicy()` ，直接丢弃后来的任务。
- `ThreadPoolExecutor.DiscardOldestPolicy()` ，丢弃在队列中队首的任务，并尝试提交当前任务。

如果我们有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑。当然，绝大多数是不需要的。

### 创建线程池的几种方式？

Java 类库提供一个灵活的线程池以及一些有用的默认配置，我们可以通过Executors 的静态方法来创建线程池。

- - 1、

    ```java
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads);
    ```

    方法，创建一个固定长度的线程池。

    - 每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，新任务将在阻塞队列中排队。
    - 当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

  - 2、

    ```java
    ExecutorService cacheThreadPool = Executors.newCachedThreadPool();
    ```

     方法，创建一个可缓存的线程池。

    - 创建新线程时如果有可重用的线程，则重用它们，否则重新创建一个新的线程并将其添加到线程池中。
    - 在线程池的 keepAliveTime时间超过默认的60秒后，该线程会被终止并从缓存中移除，因此在没有线程任务运行时， newCachedThreadPool将不会占用系统的线程资源
    - 创建新线程复杂，且耗时。在有执行时间很短的大量任务需要执行的情况下， newCachedThreadPool能够很好地复用运行中的线程（任务已经完成但未关闭的线程）资源来提高系统的运行效率。

  - 3、

    ```java
    ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();
    ```

    方法，创建一个单线程的线程池。

    - 它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。
    - 它的特点是，能确保依照任务在队列中的顺序来串行执行。

  - 4、

    ```java
    ExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(int corePoolSize);
    ```

    方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。

  - 5、

    ```java
    ExecutorService newWorkStealingPool = Executors.newWorkStealingPool();
    ```

    - 创建持有足够线程的抢占式线程池来达到快速运算的目的，在内部通过使用多个队列来减少各个线程调度产生的竞争。
    - 足够的线程就是处理器的数量一样多的线程，`Runtime.getRuntime().availableProcessors()`以保障线程的快速执行，并很大程度地使用系统资源，提高并发计算的效率，省去用户根据CPU瓷源估算并行度的过程。
    - 如果开发者想自己定义线程的并发数，则也可以将其作为参数传入。



## 了解

### 一个线程运行时发生异常会怎样？

如果异常没有被捕获该线程将会停止执行。

`Thread.UncaughtExceptionHandler` 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 `Thread#getUncaughtExceptionHandler()` 方法来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 `#uncaughtException(exception)` 方法进行处理。

具体的使用，可以看看 [《JAVA 多线程之 UncaughtExceptionHandler —— 处理非正常的线程中止》](https://blog.csdn.net/u013256816/article/details/50417822) 。

### notify 和 notifyAll 有什么区别？

当一个线程进入 wait 之后，就必须等其他线程 notify/notifyAll 。

- 使用 notifyAll,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。
- 如果没把握，建议 notifyAll ，防止 notify 因为信号丢失而造成程序错误。

关于 notify 的信息丢失，可以看看 [《wait 和 notify 的坑》](https://www.jianshu.com/p/91d95bb5a4bd) 文章。

### 为什么你应该在循环中检查等待条件？

处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。

所以，我们不能写 `if (condition)` 而应该是 `while (condition)` ，特别是 CAS 竞争的时候。示例代码如下：

```
// The standard idiom for using the wait method
synchronized (obj) {
    while (condition does not hold) {
        obj.wait(); // (Releases lock, and reacquires on wakeup)
    }
    ... // Perform action appropriate to condition
}
```

- 另外，也可以看看 [《wait 必须放在 while 循环里面的原因探析》](https://blog.csdn.net/qq_35181209/article/details/77362297)

### 你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？

> 考点，就是 join 方法。

我们可以使用 Thread 类的 `#join()` 方法，来确保所有程序创建的线程在 main 方法退出前结束。

### 什么是CPU超线程技术？

超线程技术通俗来讲就是一个人干活慢，于是就又模拟出另一个人一起干活，但实际工作人数未增加。通过特殊硬件指令，将两个逻辑内核模拟为两个物理芯片。让一个物理核心充当两个核心的角色，原本任务只能有一颗核心用单一线程进行处理，但在超线程技术的加持下，单颗核心可以同时对多个任务同时展开工作，利用了CPU的空闲时间，增加了芯片的工作效率，性能得到有效的提升。