# 并发

## 精通

### （新）简述线程、进程、程序的基本概念？

`程序`，存储在磁盘上的能够`被系统运行`的含有`指令`和`数据`的文件。

`进程`，是系统运行程序的基本单位。当程序在执行时，将会被操作系统载入内存中，计算机运行程序的指令，去操作数据，`正在执行中的程序，就是进程`。

`线程`，与进程相似，但线程是一个比进程更小的执行单位，被称为轻量级进程。一个进程在其执行的过程中可以产生多个线程。在Java中，多个线程共享进程的堆和方法区（J0K1.8之后的元空间）资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。

基本上各进程是独立的，但同一进程中的线程极有可能会，互相协作，相互影响。

`线程可以理解为需要CPU处理的细分任务，进程就是线程汇总出来为人类实现特定功能，它和卖CPU说的8核16线程可不是一个概念，16线程相当于16个虚拟核心`。

### （新）多线程的优缺点？

1）好处

- 使用多线程可以把`程序中占据时间长的任务放到后台`去处理，如图片、视屏的下载。
- 发挥`多核处理器的优势`，并发执行让系统运行的更快、更流畅，用户体验更好。

2）坏处

- 大量的线程`降低代码的可读性`。
- 更多的线程需要`更多的内存空间`。
- 当多个线程对同一个资源出现争夺时候要注意`线程安全的问题`。

### （新）什么是多线程上下文切换？

多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要`轮转使用 CPU` 。CPU利用时间片轮询来为每个任务都服务一定的时间，然后把当前任务的状态保存下来，继续服务下一个任务。`任务的状态保存及再加载就叫作线程的上下文切换`。线程切换时CPU寄存器和程序计数器所保存的当前线程的信息，就是上下文。

- 进程：指一个运行中的程序的实例。在一个进程内部可以有多个线程在同时运行，并与创建它的进程共享同一地址空间（一段内存区域）和其他资源。
- 上下文：指线程切换时CPU寄存器和程序计数器所保存的当前线程的信息。
- 寄存器：指**CPU内部容量较小但速度很快的内存区域**（与之对应的是CPU外部相对较慢的RAM主内存）。寄存器**通过对常用值（通常是运算的中间值）的快速访问来加快计算机程序运行的速度**。
- 程序计数器：是**一个专用的寄存器**，用于`表明指令序列中CPU正在执行的位置`，存储的值为正在执行的指令的位置或者下一个将被执行的指令的位置，这依赖于特定的系统。

#### 上下文切换流程？

- （1）挂起一个进程，将这个进程在CPU中的状态（`上下文信息`）
  `存储于内存的PCB中`
- （2）在PCB中检索下一个进程的上下文并`将其在CPU的寄存器中恢复`
- （3）`跳转到程序计数器所指向的位置`（即跳转到进程被中断时的代码行）并恢复该进程

![image-20200912173053210](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912173054.png)

#### 引起线程上下文切换的原因引起线程上下文切换（线程让出CPU的情况）的原因？

- 当前正在执行的任务完成，系统的`CPU正常调度`下一个任务
- 当前正在执行的任务遇到`I0等阻塞操作，调度器挂起此任务`，继续调度下一个任务。
- 多个任务并发抢占锁资源，`当前任务没有抢到锁资源`，`被调度器挂起`，继续调度下一个任务
- 用户的`代码挂起当前任务`，比如线程执行 `sleep方法，让出CPU`
- `硬件中断`。

### （新）进程调度算法

系统`多进程分时复用`

进程调度算法包括：

- 优先调度算法
  - `先来先服务调度算法：`运行最早进入的任务，实现简单相对公平
  - `短作业优先调度算法：`估运行时间最短的进程，为其分配CPU资源并运行。该算法优`先运行短时间作业`，以提高CPU整体的`利用率和系统运行效率`，某些大任务可能会出现长时间得不到调度的情况（**饥饿**）。

- 高优先权优先调度算法
  - `非抢占式优先杈算法：`该算法**优先运行优先权高**的作业，且一旦将CPU分配给某个进程，就**不会主动回收CPU资源**，直到任务主动放弃。
  - `抢占式优先权调度算法：`抢占式优先调度算法首先把**CPU资源分配**给优先权最高的任务并运行，但如果在运行过程中出现比当前运行**任务优先权更高**的任务，调度算法就会暂停运行该任务并回收CPU资源，为其分配新的优先权更高的任务。该算法真正保障了CPU在整个运行过程中**完全按照任务的优先权分配资源**，这样如果临时有紧急作业，则也可以保障其第一时间被执行。
  - `高响应比优先调度算法：`高响应比优先调度算法使用了动态优先权的概念，即任务的`执行时间越短，其优先权越高，任务的等待时间越长，优先权越高`。
    高响应比优先调度算法在`保障效率`（短作业优先能在很大程度上提高CPU的使用率和系统性能）的基础上`尽可能提高了调度的公平性`（随着任务等待时间的增加，优先权提高，遵循了先来先到原则）。

- 基于时间片的轮转调度算法。

  - `时间片轮转算法：`时间片轮转法指按照`先来先服务原则`从就绪队列中取出一个仼务，并为该任务分配一定的CPU时间片去运行，在进程使用完CPU`时间片后由一个时间计时器发出时钟中断请求`，`调度器`在收到时钟中断请求信号后停止该进程的运行并将该进程放入就绪`队列的队尾`，然后从就绪队列的队首取出一个任务并为其分配CPU时间片去执行。这样，就绪队列中的任务就将轮流获取一定的CPU时间片去运行

  - 多级反馈队列调度算法：多级反馈队列调度算法`在时间片轮询算法的基础上`设置`多个就绪队列`，并为每个就绪队列都设置不同的优先权。队列的优先权越高队列中的任务被分配的时间片就越大。默认第一个队列优先权最高，其他次之。

    调度流程：

    - 任务进来，先放第一个队列末尾，规定时间内任务没有运行完成，将此任务放入第二队列，以此类推。前面队列的任务的全部完成后，调度器才回调度当前队列，并且前面队列有新任务进来时，它还会被停止，然后放入队列末尾。

    先来先服务调度算法和时间片轮询算法的优势，使得对进程的调度更加合理。

### Java 中用到的线程调度算法是什么？

一个多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。Java 虚拟机的一项任务就是负责按照特定机制为多个线程分配 CPU 的使用权。

Java 虚拟机采用`抢占式调度模型`，是指优先让可运行池中`优先级高的线程占用 CPU` ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。优先级低的线程只是获取CPU时间片的优先级被降低，但**不会永久分配不到CPU时间片**。Java的线程调度在保障效率的前提下尽可能保障线程调度的公平性。容易`导致其他线程饥饿`。

#### 什么是线程饥饿？

饥饿，一个或者多个线程因为种种原因无法获得所需要的资源（数据、CPU时间片、运行指令等），导致一直无法执行的状态。

Java 中导致饥饿的原因：

- `高优先级线程`吞噬所有的低优先级线程的 CPU 时间。
- `线程被永久堵塞在一个等待进入同步块的状态`，因为其他线程总是能在它之前持续地对该同步块进行访问。
- `线程在等待一个本身也处于永久等待完成的对象`(比如调用这个对象的 `wait 方法`)，因为其他线程总是被持续地获得唤醒。

#### 你对线程优先级的理解是什么？

每一个线程都是有优先级的，一般来说，`高优先级的线程在运行时会具有优先权`。线程优先级是一个 int 变量(从`1-10`)，1 代表最低优先级，10 代表最高优先级。我们可以定义线程的优先级，但是这并`不能保证高优先级`的线程会在低优先级的线程前`执行`。Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。

### （新）什么叫线程安全？

线程安全，指某个函数、函数库在多线程环境中被调用时，`能够正确地处理多个线程之间的共享变量`，使程序功能正确完成。可能会带来内存泄漏、上下文切换、死锁等问题。

### （新）并发原理

#### 并发编程需要解决的核心问题？

**分工**：指的是如何`高效地拆解任务并分配给线程`，直接决定了并发程序的性能。一个任务下发了，怎么执行能更快的完成。

**同步（协作）**：指的是线程之间如何协作，一个线程执行完了一个任务，如何通知执行后续任务的线程开工。即当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行。

**互斥**：也叫线程安全。是保证同一时刻只允许一个线程访问共享资源。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。可以看做一种特殊的协作。

Java解决并发编程：

![image-20200912162649563](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200912162658.png)



#### 并发产生的原因？

为了平衡CPU、内存、I/O 设备三者速度的差异：

`缓存：CPU 增加了缓存`，以均衡与内存的速度差异。但在多核时代，每颗 CPU 都有自己的缓存，存在CPU 缓存与内存的数据一致性问题。一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。

`指令优化：`为了使得`缓存`能够得到更加合理地`利用`，编译程序优化`指令执行次序`。

`线程切换：`操作系统增加了进程、线程，用以`分时复用 CPU`，进而均衡 CPU 与 I/O 设备的速度差异。`但操作系统切换线程可以在任何一条CPU指令完成后`，所以无法保证高级语言的操作符的原子性。我们把一个或者多个操作在 `CPU 执行的过程中不被中断`的特性称为`原子性`：解决原子性问题，是要保证中间状态对外不可见。

#### Java如何解决可见性、有序性、原子性？

Java 内存模型是一个规范，规范了 JVM 如何提供按需禁用缓存和编译优化的方法以保证有序性问题。包括volatile、synchronized 和 final 三个关键字，以及8项 Happens-Before 规则保证前面一个操作的结果对后续操作是可见的。

**三个关键字：**

volatile：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。并在1.5版本通过程序顺序性、volatile 变量规则、传递性这三项Happens-Before规则，对volatile进行了语义增强，如下所示： 

![image-20200914155306845](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914155308.png)

`final：`这个变量生而不变，可以可劲儿优化。

- Java 编译器在 1.5 以前的版本会因构造函数的错误重排导致线程可能看到 final 变量的值会变化。1.5以后对final类型变量得类型变量的重排进行了约束，但要避免构造函数溢出。

  ![image-20200914155058458](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914155100.png)

  将this赋值给global.obj时，this还没有初始化完

`synchronized：`为了保证`操作`的`原子性`，在多核CPU时代，不需要`禁止线程切换`，还需要“同一时刻只有一个线程执行”这个条件，称之为`线程互斥`。Java提供了锁技术，锁并不能改变CPU时间片切换的特点，只是保证当CPU走了后，不让其他线程操作数据。当其他线程要访问锁修饰的这个资源时，发现锁还未释放，所以只能在外面等待，以此来保证操作的原子性。并根据 Happens-Before 中的`管程中锁的规则`，保证后续线程`加锁时`对受保护资源的`可见性`。

`（保护资源）对象`：每个对象都有唯一的一把锁。加锁只会保证框定的区域（临界区）里，对保护资源  `操作`  （方法：可以有多个操作）的原子性，所以不能多把锁保护同一个资源。

锁，一定有一个要锁定的对象（临界区），至于这个`锁定的对象要保护的”资源“`以及在哪里加锁 / 解锁（门），就属于设计层面的事情了，受保护资源和锁之间合理的关联关系应该是 `N:1` 的关系。

- 同步代码块：锁定指定的一个 obj 对象
- 修饰非静态方法：当前实例对象 this
- 修饰静态方法：锁定的是当前类的 Class 对象，在上面的例子中就是 Class X

`原理：`

加锁的本质（待整理）：synchronized的理解是这样，它并不能改变CPU时间片切换的特点，只是当其他线程要访问这个资源时，发现锁还未释放，所以只能在外面等待。

Sync优化：sync锁的对象monitor指针指向一个ObjectMonitor对象，所有线程加入他的entrylist里面，去cas抢锁，更改state加1拿锁，执行完代码，释放锁state减1，和aqs机制差不多，只是所有线程不阻塞，cas抢锁，没有队列，属于非公平锁。 wait的时候，线程进waitset休眠，等待notify唤醒。

**8项 Happens-Before 规则：**

- `程序的顺序性规则:``一个线程`中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。
- `volatile 变量规则：`这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。
- `传递性：` 这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。
- `管程中锁的规则：`是指对`一个锁的解锁` Happens-Before 于后续对这个锁的加锁。线程B进入同步块后能看见线程A的写操作
- `线程 start() 规则：`它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。
- `线程 join() 规则：`这条是关于线程等待的。`它是指主线程 A 等待子线程 B 完成`（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），`主线程能够看到子线程的操作`。
- `线程中断规则:`对线程interrupt（）方法的调用happen—before发生于被中断线程的代码检测到中断时事件的发生。可以通过Thread::interrupted（）方法检查是否有中断发生。
- `对象终结规则：`一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始。

### 锁

#### 锁和资源

`不能用，可变对象做锁`：我觉得不能用balance和password做为锁对象。这两个对象balance是Integer，password是String都是不可变变对象，一但对他们进行赋值就会变成新的对象，加的锁就失效了。

##### 保护没有关联关系的多个资源

各自用一把锁。

用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字，叫`细粒度锁。`

##### 保护有关联关系（之间有数据交换）的多个资源

转账问题：锁能覆盖所有受保护资源，即多个对象共用一把锁。

注：转账实际使用数据库事务+乐观锁的方式解决（select * from account where account_id = ? for update 加锁，锁住锁定两条记录）。并且实际中转账和到账操作有延迟，转入操作放到mq里面，mq消费失败会重试，所以能保证最终一致性。

- 创建多个对象时，`传入唯一的lock对象来当锁`。万一不是一样的对象，就没用了，并且会出现，锁自家门来保护他家资产的荒唐事。

- 用 `Account.class 作为共享的锁`。这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。`但所有的转账操作都变成串行，不可行`。

  - 还可以在Account中添加一个final静态object，通过锁这个object来实现一个锁保护多个资源。这种方式比锁class更安全。如果用 Account.class 的话，其他使用的者也可以用这个锁，可以说这种锁是暴露的，而这种则是私有的锁，不会有暴露的风险。

    ![image-20200914171740854](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914171742.png)

#### 死锁

 Account.class 作为互斥锁，虽然这个方案不存在并发问题，但是所有账户的转账操作都是串行的。解决这个问题，可以`一次性获取两把锁`：转出账户 this锁，转入账户锁。

![image-20200914173910745](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914173912.png)

将锁的细粒度变小，使用`细粒度锁`可以提高并行度，是性能优化的一个重要手段。

`但代价`就是可能会导致`死锁`:一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。

以下四个条件`都发生`时才会出现`死锁`：

- `互斥`，共享资源 X 和 Y 只能被一个线程占用；
- `占有且等待`，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
- `不可抢占`，其他线程不能强行抢占线程 T1 占有的资源；
- `循环等待`，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

破坏其中一个，就可以成功避免死锁的发生：

- `互斥：`无法破坏，用`锁为的就是互斥`。

- `占用且等待：`我们可以`一次性申请所有的资源`。需要一个`管理员角色：Allocator`（Java 里面的类）来管理这个临界区，用来同时申请资源，同时释放资源。账户 Account 类里面持有一个 `Allocator 的单例`（管理员必须是唯一的）。

  <img src="upload\image-20200914180535649.png" alt="image-20200914180535649" style="zoom:25%;" />

- `不可抢占：`占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。`synchronized 是做不到`，synchronized 申请资源的时候，如果申请不到，线程直接进入`阻塞状态`。java.util.concurrent 这个包下面提供的 `Lock` 是可以轻松`解决`这个问题的

- `循环等待：`可以靠`先排序`，然后`按序申请资源`来预防。按照序号从小到大的顺序锁定账户。<img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914181031.png" alt="image-20200914181029958" style="zoom:25%;" />

**总结：**用细粒度锁来锁定多个资源时，要注意死锁的问题。识别出风险很重要。

`破坏占用且等待条件`，我们也是`锁了所有的账户`，而且还是用了`死循环` while(!actr.apply(this, target));(**方法实际项目中，应该加个timeout避免一直阻塞**），不过好在 apply() 这个方法基本不耗时。 在转账这个例子中，`破坏循环等待条件就是成本最低`的一个方案。

所以我们在选择具体方案的时候，还需要`评估一下操作成本`，从中选择一个成本最低的方案。

##### “等待-通知”机制`优化循环等待`

用死循环的方式来循环等待，如果 apply() 操作耗时非常短，而且并发冲突量也不大时，方案可行。但如果`apply() 耗时长，并发大`，循环获取锁太`耗CPU`。需要`等待通知机制`。

`等待 - 通知机制`：线程首先**获取互斥锁**，当线程要求的条件**不满足**时，**释放互斥锁**，进入等待状态；当要求的条件**满足**时，**通知等待的线程，重新获取互斥锁**。

- 获取锁，`获取不到`在互斥锁的`等待队列`里等待。（对象、互斥锁、等待队列一一对应）

- 线程进入临界区后，某些`条件不满足`，线程需要调`用对象的wait()方法`进入互斥锁的`等待队列`，并释放持有的互斥锁。

- 当条件满足时调用 notify()，会通知等待队列（互斥锁的等待队列）中的线程，告诉它条件`曾经满足过`（只保证通知的那个时间点条件满足，不保证被唤醒的线程执行时满足，有人可能插队），等待线程重新抢占获取互斥锁。

  - 为了解决曾经满足这个问题，当wait()满足时，需要重新检查等待条件。经典范式：

    ```java
    while(条件不满足) {
        wait();
    }
    ```

    <img src="https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200914195703.png" alt="image-20200914195701587" style="zoom:25%;" />

注：除非深思熟虑，否则尽量使用 notifyAll()。

### 线程的生命周期？

线程的生命周期分为新建（NeW）、就绪（ Runnable）、运行（ Running）、阻塞（ Blocked）和死亡（Dead）这5种状态。

![image-20200910153023382](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910153025.png)

- `新建状态：New`在Java中使用new关键字创建一个线程，新创建的线程将处于新建状态。在创建线程时主要是`为线程分配内存(线程私有的区域：程序计数器、虚拟机栈、本地方法栈)并初始化其成员变量的值`

- `就绪状态：Runnab1e`新建的线程对象在调用 start方法之后将转为就绪状态。此时JVM完成了方法调用栈和程序计数器的创建，等待该线程的调度和运行（JVM会调用操作系统的接口创建一个与之对应的原生线程）。

- `运行状态：Running`就绪状态的线程在竞争到CPU的使用权并开始执行run方法的线程执行体时，会转为运行状态，处于运行状态的线程的主要任务就是执行run方法中的逻辑代码。

- `阻塞状态：Waitting` 运行中的线程会主动或被动地放弃CPU的使用权并暂停运行，此时该线程将转为阻塞状态，直到再次进入可运行状态，才有机会再次竞争到CPU使用权并转为运行状态。阻塞的状态分为以下三种。

  1. 等待阻塞：在运行状态的线程调用o.wait方法时，JVM会把该线程放入等待队列（ Waitting Queue）中，线程转为阻塞状态。
  2. 同步阻塞：在运行状态的线程尝试获取正在被其他线程占用的对象同步锁时，JVM会把该线程放入锁池（ Lock Poo1）中，此时线程转为阻塞状态。
  3. 其他阻塞：运行状态的线程在执行 Thread. sleep（long ms）、 Thread.join、 调用socket的 recelver、 accept方法或者发出I/0请求时，，JVM会把该线程转为阻塞状态。直到 sleep()状态超时、 Thread. join等待线程终止或超时，或者I/0处理完毕，线程才重新转为可运行状态。

  ![img](http://static2.iocoder.cn/04a277229fd3b24e058417f9c571681c)

- `线程死亡：Dead`线程在以下面三种方式结束后转为死亡状态。

  - 线程正常结東：run方法或ca11方法执行完成。
  - 线程异常退出：运行中的线程抛出一个 Error或未捕获的Exception，线程异常退出
  - 手动结束：调用线程对象的stop方法手动结束运行中的线程该方式会瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，不推荐使用。



### 线程的基本方法？

线程相关的基本方法有wait、 notify、 notifyAll、 sleep join、 yield等，这些方法控制线程的运行，并影响线程的状态变化。

- `线程等待：wait方法`调用wait方法的线程会进入 WAITING状态，只有等到其他线程的通知或被中断后才会返回。需要注意的是，在调用wait方法后会释放对象的锁，因此wait方法一般被用于同步方法或同步代码块中。

- `线程睡眠：sleep方法`调用 sleep方法会导致当前线程休眠。与wait方法不同的是， sleep方法不会释放当前占有的锁，会导致线程进入 TIMED-WATING状态，而wai方法会导致当前线程进入 WATING状态

- `线程让步：yield方法`调用 yield方法会使当前线程让出（释放）CPU执行时间片，与其他线程一起重新竞争CPU时间片。在一般情况下，优先级高的线程更有可能竞争到CPU时间片，但这不是绝对的，有的操作系统对线程的优先级并不敏感。

- `线程中断：interrupt方法`Interrupt方法用于向线程发行一个`终止通知信号`，会影响该线程内部的一个中断标识位，这个线程木身并不会因为调用了 interrupt方法而改变状态（阻塞、终止等）。状态的具体变化需要等待接收到中断标识的程序的最终处理结果来判定。对 interrupt方法的理解需要注意以下4个核心点
  - `调用 interrupt方法并不会中断一个正在运行的线程`，也就是说处于 Running状态的线程并不会因为被中断而终止，仅仅改变了内部维护的中断标识位而已。
  - 若因为调用 sleep方法而使线程处于 TIMED- WATING状态，则这时调用 interrupt方法会抛出 InterruptedException，使线程提前结東TIMED-WATING状态
  - 许多声明抛出 InterruptedException的方法如Thread. sleep（ long mills），`在抛出异常前都会清除中断标识位`，所以在抛出异常后调用 interrupted方法将会返回 false。
  - 中断状态是线程固有的一个标识位，可以通过此标识位安全终上线程。比如，在想终止一个线程时，可以先调用该线程的 Interrupt方法，然后在线程的run方法中根据该线程 isInterrupted方法的返回状态值安全终止线程
  
- `线程加入：join方法`join方法用于等待其他线程终止，如果在当前线程中调用一个线程的join方法，则当前线程转为阻塞状态，等到另一个线程结束，前线程再由阻塞状态转为就绪状态，等待获取CPU的使用权。在很多情况下，主线程生成并启动了子线程，需要等到子线程返回结果并收集和处理再退出，这时就要用到join方法，具体的使用方法如下![](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910173847.png)

- `线程唤醒：notify方法`Object类有个 notify方法，用于唤醒在此对象监视器上等待的一个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的。
  `实战：`我们通常调用其中一个对象的wait方法在对象的监视器上等待，直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他线程竞争。类似的方法还有 notify1l，用于唤醒在监视器上等待的所有线程
  
- `后台守护线程：setDaemon方法`setDaemon方法用于定义一个守护线程，也叫作“服务线程”，该线程是后台线程，有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。
  
  守护线程的`优先级较低`，用于为系统中的其他对象和线程提供服务。将一个用户线程设置为守护线程的方法是在线程`对象创建之前（start之前）`用线程对象的 setDaemon（true）来`设置`。
  
  在后台守护线程中定义的线程（子线程）也是后台守护线程。后台`守护线程是JVM级别`的，比如垃圾回收线程就是一个经典的守护线程，在我们的程序中不再有任何线程运行时，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以在回收JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态下运行，用于实时监控和管理系统中的可回收资源。
  `实战：`守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。也就是说，守护线程`不依赖于终端，但是依赖于JVM，与JVM“同生共死”`。在JM中的所有线程都是守护线程时，JVM就可以退出了，如果还有一个或一个以上的非守护线程，则JVM不会退出。

![image-20200910175149849](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910175151.png)

####  （待整理）sleep方法与wait方法的区别？

- sleep方法属于 `Thread类`的静态方法，wait方法则属于 `Object类`。

- sleep方法暂停执行指定的时间，`让出CPU`给其他线程，但其监控状态依然保持，在指定的时间过后又会自动恢复到就绪状态。

- 在调用 `sleep方法`的过程中，线程`不会释放对象锁`。

- 在调用`wait方法`时，线程会`放弃对象锁`，进入等待此对象的`等待池（wait pool）`，只有针对此对象`调用 notify方法后`，才能唤醒等待池中的线程进入`等锁池（lock pool）`，如果线程重新获得对象的锁就可以进入就绪状态。

  wait与sleep区别在于： 1. wait会释放所有锁而sleep不会释放锁资源. 2. wait只能在同步方法和同步块中使用，而sleep任何地方都可以. 3. wait无需捕捉异常，而sleep需要. 两者相同点：都会让渡CPU执行时间，等待再次调度！ wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。 sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。

#### start方法与run方法的区别?

- start方法用于启动线程，真正实现了多线程运行。在调用了线程的 start方法后，线程会在`后台执行`，`无须等待run方法体的代码执行完毕`，就可以继续执行下面的代码
- 在通过调用 Thread类的 `start方法启动`一个线程时，此线程处于`就绪状态`，并没有运行。
- run方法也叫作线程体，包含了要执行的线程的逻辑代码，`在调用run方法后`，不会创建线程，线程就进入`运行状态`，开始运行run方法中的代码。`在run方法运行结束后，该线程终止`，CPU再调度其他线程。（不会创建线程，就一个普通方法）

#### 线程的 sleep 方法和 yield 方法有什么区别？

- `sleep 方法`给其他线程运行机会时`不考虑线程的优先级`，因此会给低优先级的线程以运行的机会。`yield 方法只会给相同优先级或更高优先级的线程以运行的机会`。
- 线程执行 `sleep 方法后转入阻塞（blocked）状态`，而执行 `yield 方法后转入就绪（ready）状态`。
- sleep 方法声明抛出 InterruptedException 异常，而 yield 方法没有声明任何异常。
- `sleep 方法`比 yield 方法（跟操作系统 CPU 调度相关）`具有更好的可移植性`。

#### 为什么 Thread 类的 sleep 和 yield 方法是静态的？

Thread 类的 sleep 和 yield 方法，将在`当前正在执行的线程上运行`。

所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。

#### sleep(0) 有什么用途？

`Thread#sleep(0)` 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 `Thread#sleep(0)` 方法，把当前线程确实的被冻结了一下，`让其他线程有机会优先执行`。`Thread#sleep(0)` 方法，是你的线程`暂时放弃 CPU` ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个**让位动作**。

为了防止循环检查条件时，一直占用CPU时间片做无用功。交出CPU时间片，让别人干。

[《Sleep(0) 的妙用》](https://blog.csdn.net/qiaoquan3/article/details/56281092) ：假如AB两个线程为合作关系，A线程处理一些原始数据，数据处理到一定程度，交给B线程处理，在A处理原始数据的时候，B也要做一些准备工作，所以，AB是并发的，但是B做好准备之后，需要等待A处理好那些数据，接过A的数据，继续处理，因此，这个等待，如果A不使用信号或者等待条件来通知B的话，那么B必须一直轮询，查看A是否已完成，B线程所做的这个轮询是否会一直占用CPU来做无用的循环查看呢？因此B这个时候占用的cpu时间片做的是无用功，因此，这里sleep(0)就有作用，当B查看A没处理完数据的时候，B马上sleep(0)交出B的时间片，让操作系统调度A来运行(假设只有AB两个线程），那么这个时候，A就会得到充分的时间来处理它的数据。

![image-20200910195136862](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910195138.png)

#### 定义一个可以安全退出的线程？

![image-20200910173135789](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910173137.png)

注：`在抛出异常前都会清除中断标识位`，所以需要在catch里重新设置中断标识。方便后续判断，做一些资源释放工作。

### 终止线程的4中方式？

1. `正常运行结束`指线程体执行完成，线程自动结束

2. `使用退出标志退出`可以使用一个变量来控制循环，比如设置一个 boolean类型的标志，并通过设置这个标志为true或false来控制 while循环是否退出，在定义exit时使用了一个Java关键字 `volatile`，这个关键字用于使exit线程同步安全，也就是说在同一时刻只能有一个线程修改exit的值，在exit为true时， While循环退出。

   ![image-20200910162721647](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910162722.png)

3. 使用interrupted方法终止线程，有一线两种情况：

   - 线程处于阻塞状态。当线程处于阻塞状态：s`leep()、wait()、join()或者调用 socket的 recelver、 accept等方法时`。在调用该线程的 Interrupt方法时，会抛出 InterruptException异常。我们通过代码捕获该异常，然后通过 break跳出状态检测循环(`在抛出异常前都会清除中断标识位，不break就会死循环`)，可以有机会结束这个线程的执行。

   - 线程未处于阻塞状态。此时，使用 isInterrupt方法判断线程的中断标志来退出循环（当标识用）。在调用 interrupt方法时，中断标志会被设置为true，并不能立刻退出线程，而是执行线程终止前的资源释放操作，等待资源释放完毕后退出该线程。

     ![image-20200910164038659](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910164040.png)

4. `使用stop方法终止线程：不安全`就像突然关闭计算机的电源，可能会产生不可预料的后果。在程序使用 Thread.stop方法终止线程时，瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，被保护的数据就可能岀现不一致的情况，并不推荐采用这种方法终止线程。

#### interrupted 和 isInterrupted 方法的区别？

`Thread#interrupted()` **静态**方法，查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 `#interrupted()` 方法则返回 `true` ，第二次和后面的就返回 `false` 了。线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程（用是否抛出异常来判断）的状态为并做处理。

`Thread#isInterrupted()` 方法，查询指定线程的中断状态，不会清除原状态。

### （待整理）为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？

Java提供的锁是属于对象的，每个对象都有唯一的一把锁。锁是要保证在线程并发的情况下，对共享资源操作的原子性，和先线程间的互斥。锁保证线程间互斥，就是让争抢锁失败的线程，进入等待队列。而进入互斥锁临界区后，但某条件不满足

锁抢占失败，或者进入互斥锁临界区后，条件不满足。都需要

所以线程间

为了避免多线程并发下，出现对锁的抢占，而可能造成的死锁问题。

在java面向对象思想中，资源就是对象。所以Java 提供的锁是对象级的，锁属于对象。并且每个对象都有锁，可以通过线程获得。 

wait，notify 和 notifyAll 方法都是锁用于线程之间通信的，通知线程什么时间该来，什么时间可以离开干别的，所以把它们定义在 Object 类中。

`一个是从观察者模式的角度，对象是被观察者，线程是观察者。被观察者的状态如果发生变化，理应有被观察者去轮询通知观察者，否则的话，观察者怎么知道notify方法应该在哪个时刻调用？n个观察者的notify又如何做到同时调用？再说了，在Thread里，谁调用啊？没人调用就不干活了？`

而且 wait()、notify()、notifyAll() 这三个方法能够被调用的前提是已经获取了相应的互斥锁，所以我们会发现 wait()、notify()、notifyAll() 都是在 synchronized{}内部被调用的。如果在 synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，JVM 会抛出一个运行时异常：java.lang.IllegalMonitorStateException。

#### [为什么 wait 和 notify 方法要在同步块中调用？](https://blog.csdn.net/lsgqjh/article/details/61915074)

- Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。
- 还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。

## 熟悉

### 常见的Java线程的4种创建方式

常见的Java线程的4种创建方式分别为：继承 Thread类、实现Runnable接口、通过 ExecutorService和 Callable< Class>实现有返回值的线程、基于线程池。

### ThreadPoolExecutor构造函数的具体参数?

corePoolSize:线程池核心线程数

![image-20200910142116416](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910142118.png)

### Java线程池的工作流程？

线程池刚被创建时，只是向系统申请个用于执行线程队列和管理线程池的线程资源。在调用 execute()添加一个任务时，线程池会按照以下流程执行任务:

- 如果正在运行的线程数量少于 corepoolsize（用户定义的核心线程数），线程池就会立刻创建线程并执行该线程任务
- 如果正在运行的线程数量大于等于 corepoolsize，该任务就将被放入阻塞队列中
- 在阻塞队列已满且正在运行的线程数量少于 maximumPoolsize时，线程池会创建非核心线程立刻执行该线程任务。
- 在阻塞队列已满且正在运行的线程数量大于等于maximumPoolsize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。
- 在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行。
- 在线程处于空闲状态的时间超过 keepAliveTime时间时，正在运行的线程数量超过 corepoolsize，该线程将会被认定为空闲线程并停止。因此在线程池中所有线程任务都执行完毕后，线程池会收缩到corepoo1Size大小

![image-20200910142404013](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200910142405.png)

### 线程池的拒绝策略有哪些？

ThreadPoolExecutor 默认有四个拒绝策略：

- `ThreadPoolExecutor.AbortPolicy()` ，直接抛出异常 RejectedExecutionException 。
- `ThreadPoolExecutor.CallerRunsPolicy()` ，直接调用 run 方法并且阻塞执行。（不会真的丢弃任务）
- `ThreadPoolExecutor.DiscardPolicy()` ，直接丢弃后来的任务。
- `ThreadPoolExecutor.DiscardOldestPolicy()` ，丢弃在队列中队首的任务，并尝试提交当前任务。

如果我们有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑。当然，绝大多数是不需要的。

### 创建线程池的几种方式？

Java 类库提供一个灵活的线程池以及一些有用的默认配置，我们可以通过Executors 的静态方法来创建线程池。

- - 1、

    ```java
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads);
    ```

    方法，创建一个固定长度的线程池。

    - 每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，新任务将在阻塞队列中排队。
    - 当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

  - 2、

    ```java
    ExecutorService cacheThreadPool = Executors.newCachedThreadPool();
    ```

     方法，创建一个可缓存的线程池。

    - 创建新线程时如果有可重用的线程，则重用它们，否则重新创建一个新的线程并将其添加到线程池中。
    - 在线程池的 keepAliveTime时间超过默认的60秒后，该线程会被终止并从缓存中移除，因此在没有线程任务运行时， newCachedThreadPool将不会占用系统的线程资源
    - 创建新线程复杂，且耗时。在有执行时间很短的大量任务需要执行的情况下， newCachedThreadPool能够很好地复用运行中的线程（任务已经完成但未关闭的线程）资源来提高系统的运行效率。

  - 3、

    ```java
    ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();
    ```

    方法，创建一个单线程的线程池。

    - 它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。
    - 它的特点是，能确保依照任务在队列中的顺序来串行执行。

  - 4、

    ```java
    ExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(int corePoolSize);
    ```

    方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。

  - 5、

    ```java
    ExecutorService newWorkStealingPool = Executors.newWorkStealingPool();
    ```

    - 创建持有足够线程的抢占式线程池来达到快速运算的目的，在内部通过使用多个队列来减少各个线程调度产生的竞争。
    - 足够的线程就是处理器的数量一样多的线程，`Runtime.getRuntime().availableProcessors()`以保障线程的快速执行，并很大程度地使用系统资源，提高并发计算的效率，省去用户根据CPU瓷源估算并行度的过程。
    - 如果开发者想自己定义线程的并发数，则也可以将其作为参数传入。



## 了解

### （新）并发编程和并行编程有什么区别？

并发（Concurrency）和并行（Parallellism）是：

并行编程是指同一时刻没有关系的两个事件执行各自的任务

并发编程是指在一个时间段两个事件相互协作，为了完成一个任务。

所以并发编程的目标是，充分的利用处理器的每一个核，以达到最高的处理性能。

#### 并发和并行的区别？

- 并发：同一时间段，多个任务都在执行（单位时间内不一定同时执行）；
- 并行：单位时间内，多个任务同时执行。

### （新）同步和异步有何异同，在什么情况下分别使用他们？

如果`数据将在线程间共享`。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行**同步**存取。

当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用**异步**编程，在很多情况下采用异步途径往往更有效率。

### 一个线程运行时发生异常会怎样？

如果异常没有被捕获该线程将会停止执行。

`Thread.UncaughtExceptionHandler` 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 `Thread#getUncaughtExceptionHandler()` 方法来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 `#uncaughtException(exception)` 方法进行处理。

具体的使用，可以看看 [《JAVA 多线程之 UncaughtExceptionHandler —— 处理非正常的线程中止》](https://blog.csdn.net/u013256816/article/details/50417822) 。

### notify 和 notifyAll 有什么区别？

当一个线程进入 wait 之后，就必须等其他线程 notify/notifyAll 。

- 使用 notifyAll,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。
- 如果没把握，建议 notifyAll ，防止 notify 因为信号丢失而造成程序错误。

关于 notify 的信息丢失，可以看看 [《wait 和 notify 的坑》](https://www.jianshu.com/p/91d95bb5a4bd) 文章。

### 为什么你应该在循环中检查等待条件？

处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。

所以，我们不能写 `if (condition)` 而应该是 `while (condition)` ，特别是 CAS 竞争的时候。示例代码如下：

```
// The standard idiom for using the wait method
synchronized (obj) {
    while (condition does not hold) {
        obj.wait(); // (Releases lock, and reacquires on wakeup)
    }
    ... // Perform action appropriate to condition
}
```

- 另外，也可以看看 [《wait 必须放在 while 循环里面的原因探析》](https://blog.csdn.net/qq_35181209/article/details/77362297)

### 你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？

> 考点，就是 join 方法。

我们可以使用 Thread 类的 `#join()` 方法，来确保所有程序创建的线程在 main 方法退出前结束。

### （新）什么是CPU超线程技术？

超线程技术通俗来讲就是一个人干活慢，于是就又模拟出另一个人一起干活，但实际工作人数未增加。通过特殊硬件指令，将两个逻辑内核模拟为两个物理芯片。让一个物理核心充当两个核心的角色，原本任务只能有一颗核心用单一线程进行处理，但在超线程技术的加持下，单颗核心可以同时对多个任务同时展开工作，利用了CPU的空闲时间，增加了芯片的工作效率，性能得到有效的提升。

### （新）XXX是线程安全的吗？

#### Servlet 是线程安全吗？

Servlet `不是`线程安全的，Servlet 是`单实例多线程`的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。

#### Struts2 是线程安全吗

Struts2 的 Action 是`多实例多线程`的，`是`线程安全的，每个请求过来都会 `new` 一个新的 Action 分配给这个请求，请求完成后销毁。

#### SpringMVC 是线程安全吗？

`不是`的，和 Servlet 类似的处理流程。

### （新）何在两个线程间共享数据？

在两个线程间**共享变量**，即可实现共享。

一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。

### （新）怎么检测一个线程是否拥有锁？

调用 `Thread#holdsLock(Object obj)` **静态**方法，它返回 `true` 如果当且仅当当前线程拥有某个具体对象的锁。代码如下：

```
// Thread.java

public static native boolean holdsLock(Object obj);
```

### （新）如何判断多线程的阻塞导致的问题？

可以用top命令查看Java线程的cpu利用率，用jstack来dump线程。开发环境可以用 java visualvm查看线程执行情况

### （新）10 个线程和 2 个线程的同步代码，哪个更容易写？

从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。

但是同步策略的选择依赖于线程的数量，`因为越多的线程意味着更大的竞争`，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。