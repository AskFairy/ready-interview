

# kubernetes

## 什么是kubernetes

kubernetes简称k8s。是用于自动`部署`，`扩展`和`管理`容器化应用程序`集群`的开源系统。

- 中文官网：https://kubernetes.io/Zh/
- 中文社区：https://www.kubernetes.org.cn/
- 官方文档：https://kubernetes.io/zh/docs/home/
- 社区文档：https://docs.kubernetes.org.cn/

### 部署方式的进化

![image-20201007232710077](E:\GitHub\ready-interview\md\upload\image-20201007232710077.png)

- 传统部署方式：**需要搭建环境、资源分配问题（边界）**。
- 虚拟化部署技术：虚拟化技术、虚拟机资源隔离、虚拟机镜像打包部署
  - **资源浪费**：每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。
  - 重量级，启动慢。
- 容器部署时代（**Docker提供运行时容器环境**）：轻量化隔离、共享OS
  - 容器与 VM 类似，**具有自己的文件系统、CPU、内存、进程空间**等。由于它们与基础架构分离，因此可以跨云和 OS 分发进行移植。
  - 创建、启动、效率高
  - 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。
  - **松散耦合、分布式、弹性、解放的微服务**：应用程序被分解成较小的独立部分，并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。

### 为什么使用kubernetes

管理服务器集群，使得服务系统更易于使用且功能更强大、健壮、弹性和可扩展性。

Kubernetes 为您提供：**调度、自动修复、水平伸缩**

- **服务发现和负载均衡（比微服务的更广泛，跨语言）**
  Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果到容器的流量很大，Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。

- **存储编排**
  Kubernetes **允许您自动挂载您选择的存储系统**，例如本地存储、公共云提供商等。

- **自动部署和回滚**
  您可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为所需状态。例如，您可以自动化 Kubernetes 来为您的部署创建新容器，删除现有容器并将它们的所有资源用于新容器。

- **自动二进制打包**
  Kubernetes 允许您指定每个容器所需 CPU 和内存（RAM）。当容器指定了资源请求时，Kubernetes 可以做出**更好的决策来管理容器的资源。**

- **自我修复**
  Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。

- **密钥与配置管理**
  Kubernetes 允许您存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。您**可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥**。

## kubernetes组件

### 架构图

![image-20201008000602911](E:\GitHub\ready-interview\md\upload\image-20201008000602911.png)

### Master组件

![image-20201008001251664](E:\GitHub\ready-interview\md\upload\image-20201008001251664.png)

1. kube-**apiserver**
   - 对外暴露K8S的api接口，是外界进行资源操作的**唯一入口**
   - 提供认证、授权、访问控制、AP注册和发现等机制

2. **etcd**
   - etcd是兼具**一致性和高可用性**的**键值**数据库，可以作为保存 Kubernetes所有集
     群数据的**后台数据库**。
   - Kubernetes集群的etcd数据库通常需要有个备份计划

3. kube-**scheduler**（调度器）
   - 主节点上的组件，该组件**监视**那些新创建的未指定运行节点的Pod，并选择节点让Pod在上面运行。
   - 所有对k8s的集群操作，都必须经过主节点进行调度**决策**
   - 例：创建Mysql -> apiserver -> 存储到ETCD -> scheduler去etcd拿任务

4. kube-**controller**-manager（控制器）：主要干活的

   - 在主节点上运行控制器的组件

   - 逻辑上讲，每个[控制器](https://kubernetes.io/docs/admin/kube-controller-manager/)都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并**在一个进程中运行**。

     这些控制器包括:

     - 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。
     - 副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象**维护正确数量的 Pod**。
     - 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。
     - 服务帐户和令牌控制器（Service Account & Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.
     
   - cloud-controller-manager

     云控制器管理器是 1.8 的 alpha 特性。在未来发布的版本中，这是将 Kubernetes 与任何其他**云集成的最佳方式**。

### Node组件

![image-20201008002914164](E:\GitHub\ready-interview\md\upload\image-20201008002914164.png)

节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。

1. 容器运行时（Container Runtime）
   - 容器运行环境是负责运行容器的软件。
   - Kubernetes 支持多个容器运行环境: [Docker](http://www.docker.com/)、 [containerd](https://containerd.io/)、[cri-o](https://cri-o.io/)、 [rktlet](https://github.com/kubernetes-incubator/rktlet) 以及任何实现 [Kubernetes CRI (容器运行环境接口)](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md)。

2. kubelet
   - 一个在集群中每个节点上运行的**代理**。它**保证容器都运行在 Pod 中**。
     - *Pod：运行的基本单位，可能包含多个容器组成的一个服务*。
   - kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。kubelet 不会管理不是由 Kubernetes 创建的容器。
   - 负责维护**容器的生命周期**，同时也负责 Volume（CSI）和**网络**（CNI）的管理
     - Volume（CSI）:容器的数据挂载到哪个目录保存
     - **网络**（CNI）：容器的网络接口

3. kube-proxy
   - [kube-proxy](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/) 是集群中每个节点上运行的**网络代理（类似网卡）**,实现 Kubernetes [Service](https://kubernetes.io/zh/docs/concepts/services-networking/service/) 概念的一部分。
   - kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。
   - 如果操作系统提供了数据包过滤层并可用的话，kube-proxy会通过它来实现网络规则。否则，kube-proxy 仅转发流量本身。
4. fluentd
   - 是一个守护进程，它有助于**提供集群层面日志**

### 插件

## [常用概念介绍](https://www.pianshen.com/article/74251348860/)

https://www.pianshen.com/article/30221378662/

![image-20201008004434768](E:\GitHub\ready-interview\md\upload\image-20201008004434768.png)

![image-20201008004830724](E:\GitHub\ready-interview\md\upload\image-20201008004830724.png)

![image-20201008005513413](E:\GitHub\ready-interview\md\upload\image-20201008005513413.png)

![image-20201008005054718](E:\GitHub\ready-interview\md\upload\image-20201008005054718.png)

- 无状态：程序员写的代码
- 有状态应用：Mysql

![image-20201008005303581](E:\GitHub\ready-interview\md\upload\image-20201008005303581.png)

- 提供同一种服务的Pod，算一个service

![image-20201008005610852](E:\GitHub\ready-interview\md\upload\image-20201008005610852.png)

![image-20201008005655054](E:\GitHub\ready-interview\md\upload\image-20201008005655054.png)

![image-20201008005854681](E:\GitHub\ready-interview\md\upload\image-20201008005854681.png)

![image-20201008010039675](E:\GitHub\ready-interview\md\upload\image-20201008010039675.png)

![image-20201008010132780](E:\GitHub\ready-interview\md\upload\image-20201008010132780.png)

![image-20201008010329039](E:\GitHub\ready-interview\md\upload\image-20201008010329039.png)

![image-20201008010437842](E:\GitHub\ready-interview\md\upload\image-20201008010437842.png)

### 流程描述

![image-20201008011551352](E:\GitHub\ready-interview\md\upload\image-20201008011551352.png)

![image-20201008011427172](E:\GitHub\ready-interview\md\upload\image-20201008011427172.png)

