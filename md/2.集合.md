# 集合

## 精通

![image-20200908163955794](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200908163958.png)



- 集合接口
  		短虚线表示
- 抽象类
  		蓝色字体
- 实现类
  		实线表示
- 虚线
  		实现
- 实现
  		继承

### 集合框架底层数据结构总结

1）List

- ArrayList ：Object 数组。
- Vector ：Object 数组。
- LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。

2）Map

- HashMap ：
  - JDK8 之前，HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。
  - JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。
- LinkedHashMap ：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：[《LinkedHashMap 源码详细分析（JDK1.8）》](https://www.imooc.com/article/22931) 。
- Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。
- TreeMap ：红黑树（自平衡的排序二叉树）。

3）Set

- HashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。
- LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。
- TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。

### 介绍一下集合类？（需要重新整理，有些不能说）

- 集合是Java提供方便操作和存储对象的容器，主要包括 Collection 和存储键值对 Map 两种
- 如果想存储键值对，可以选择实现Map接口的基于数组+链表+红黑树的HashMap，线程安全的HashTable，基于HashTable，使用链表保存插入顺序的LinkedHashMap，基于二叉树结构可以自定义比较器的TreeMap等

- 如果想存储有序，并允许重复，可以选择实现Collection 下的List接口实现类，其中包括查询快能随机访问，用数组实现的Arraylist。用数组实现的线程安全的Vector，以及增删快的，用双向链表实现的LinkedList。

- 如果不允许元素重复，可以选择实现Collection 下的set接口实现类。基于HashMap实现的Hashset，和继承HashSet基于LinkedHashMap实现元素顺序的LinkedHashSet。和基于二叉树原理，可以自定义排序规则的TreeSet。

- 以及队列Queue，ArrayblockingQueue：基于数组数据结构实现的有界阻塞队列
  LinkedBlockingQueue：基于链表数据结构实现的有界阻塞队列
  PriorityBlockingQueue：支持优先级排序的无界阻塞队列

  Delay Queue：支持延迟操作的无界阻塞队列。
  SynchronousQueue：用于线程同步的阻塞队列
  LinkedTransferQueue：基于链表数据结构实现的无界阻塞队列
  LinkedBlockingDeque：基于链表数据结构实现的双向阻塞队

  

### 谈谈你对HashMap的理解，底层原理的基本实现?HashMap是怎么解决碰撞问题的？

实际开发中很需要一个查找性能高的k-v存储结构,尽量在O(1)时间复杂度定位到元素。

所以HashMap用到了数组这种数据结构，将Hash值右移16位，之后与原哈希值做异或运算，也就是混合高位和低位，增大随机性，再和数组容积与运算，获取数组下标。

为了减少和数组容积的位运算带来的哈希冲突，将数组长度控制为`2^n`，也就是默认容量为16，然后每次扩容都是之前的2倍，这样hash值始终在和一个大部分数字都为1的值做与运算，元素所在位置取决于Hash值。`只有2的倍数在减1的时候才会出现一个 0111这种， 除高位以外都是1的特征` 

HashMap也增加了扩容的阀值，也就是负载因子,默认值为0.75,减少Hash碰撞的产生。

这些都是HashMap为减少哈希碰撞做的工作，当Hash碰撞产生时，HashMap通过 拉链式散列结构，也就是数组+链表的方式存储产生碰撞的元素。

为了提升查询速率，JDK1.8后又引入了红黑树，在链表长度大于于8并且数组（桶容量）长度大于64时，会转换成红黑树，否则只会扩容，在红黑树元素小于6的时候转为链表（`扩容时，调用树的split()时`），由原来查询链表的O(n)复杂度，降低为O(logn)。

### 为什么需要树化（为什么引入红黑树）？

### 红黑树是什么？红黑树的结构？红黑树的优点？红黑树的规则？红黑树中插入新的节点时怎么保持平衡？

红黑树是将  2-3树的概念模型2-3-4树 的实现规则标准化，转换而来的一种高效的自平衡二叉查找树，一般用于索引，提升整体的查询效率。插入、删除、查找等操作都是O(logN)的。它不会像二叉搜索树，可能会因为数据的插入顺序退化成O(n)的链表。

红黑树的 根节点是黑色，

节点只有红黑两种颜色，

所有的子叶节点都是黑色，

每个红色节点必须有两个黑色子节点，

从任一节点到齐每个叶子节点，经过的路径都包含相同数目的黑色节点。

并通过旋转、染色来保持树的平衡。

### 简单介绍下2-3树？

因为二叉搜索树，可能会因为数据的插入顺序，退化成的链表。而2-3树解决的二叉搜索树的平衡问题，既保留了树的特点，O(logn)的索引性能。

2-3树为了保持平衡从根节点，到每一个最底部的子叶节点，链路长度一致。也就是锁2-3树所有子叶节点都在同一层。

2-3中的23，代表叉的意思

2-3中的2的意思是：1个节点存1个数据时，可以分两叉，就是有“两个子节点”。

3的意思是：1个节点存2个数据时，则可以分三叉，且中间子节点是介于两个节点间的值。

如果一个节点有3个数据时，就要树结构调整为一个二叉树。

### 一致性Hash？

### 说下HashMap源码？

#### 添加put（）

为了增大随机性，进行哈希值的扰动，把Hash值的高低位进行异或（^）。

又因为数组桶是插入元素时再进行初始化，没有初始化的话会先调用扩容函数进行初始化。

之后用（n - 1）& hash 计算元素所在下标，如果该位置没有元素，直接插入就行。如果有元素，通过判断是红黑树还是链表，用不同的方式获取节点的位置，如果还是找不到，就会new一个新的节点，这时候就需要判断是否需要扩容了。获取节点位置后，替换value。

#### 扩容resize（）



第一步先获取新的容量、新的阀值的大小。已经初始化的，容量和阀值扩大为原来的两倍，无参数创建的用默然容量和负载因子计算新的容量和阀值。传了容量和负载因子的，自定义计算阀值。

创建一个新新数组桶

遍历旧数组桶，将hash & 原数组 ，如果等于0，元素位置不变。不为0，就移动到当前位置 + 数组长度的位置。通过这样将键值映射到新数组桶中。

#### 链表转红黑树（treeifyBin）

先判断是否真的需要树化，只有链表长度的大于8，并且桶组容量大于64才树化，否则只是扩容。

先将节点转换为树节点对象，并记录链表顺序，方便后续树转链表拆分方便。

之后在进行转红黑树的操作，进行比较，染色、旋转等。

#### 红黑树转链表（untreeify）

遍历TreeNode，将树节点转换为普通节点

因为链表转红黑树记录了链表顺序，拆分方便。

#### 查找get（）

先通过经过扰动函数计算元素的位置，再判断数组桶是否已经初始化，并且位置元素不为空。

先判断头结点是否相等。就判断当前位置是树还是链表，并查找元素。

#### 删除 remove（）

删除节点，前半部分和查找方法差不多，就是找到待删除节点的同事，也找到了其上一节点。

将

### hashmap 1.7 1.8的区别？

JDK1.8后又引入了红黑树，在链表长度大于于8并且数组（桶容量）长度大于64时，会转换成红黑树，否则只会扩容，在红黑树元素小于6的时候转为链表（`扩容时，调用树的split()时`），由原来查询链表的O(n)复杂度，降低为O(logn)。

JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且并发扩容下链表死循环的问题

扩容后数据存储位置的计算方式也不一样，1.7是用 hash & （n - 1）重新计算一遍位置，1.8是 hash & 源数组，等于0位置不变，不为0，元素位置为  index + oldCap 。也就是说少了一次运算。

### （未完成）HashMap为什么是线程不安全的？

### （新）ArrayList 

#### 简单介绍下 ArrayList 怎么实现？说一说ArrayList？

ArrayList的数据结构是基于`数组`实现的,数组在ArrayList的管理下插入数据时判断数组是否够用，不够用的话用System.arraycopy方法进行`copy个新数组`来进行动态扩容、并且在插入指定位置、和删除元素时，用system.arrayCopy进行对位置变化的`元素进行拷贝`后，左右挪动这些。

#### ArrayList的初始化？

`空构造函数`：空构造函数会初始化一个空数组，在第一次插入数据，将需要最小容量设置为10。

`预设数组长度`：会初始化一个固定长度的数组，好处是因为预定好一个长度，`减少`了插入ArrayList时因数组长度不够，扩容产生`拷贝`操作的`性能消耗`，坏处是预估太多浪费空间。

#### 说一说ArrayList的add操作？

先进行`扩容检查`，判断当前数组是否足够插入新的元素，如果现在容量不够，就扩容。并且因为空构造函数初始化数组时，`初始化`的是个空数组，所以如果数组为空，就会`扩容`成容量为10的数组。最后就是就`size++`把对应元素添加进去。

#### ArrayList什么时候扩容？&& 扩容步骤grow(minCapacity)？

##### 什么时候扩容？扩容步骤？

正常插入、或者指定位置插入时会进行扩容。先进行`扩容检查`，判断当前数组是否足够插入新的元素，如果现在容量不够，就扩容。

先`计算扩容后的容量`，扩容后的长度是`旧容量 + 旧容量右移1位`，大约是原容量的1.5倍。当扩容完以后，然后用将数组中的元素`用system.arrayCopy()方法，copy到新数组`中。

##### 指定位置插入？

指定位置插入与正常插入不同的地方在于，它会先进行`区间检查`，插入的元素必须与已有元素连续。然后进行`扩容检查`。指定位置插入与正常插入直接在元素末尾追加，最大的不同就是，需要进行`元素迁移`，就是用System.arraycopy方法将插入位置`空出来`，然后再进行指定位置插入。

#### ArrayList删除是怎么操作的？

### 什么是迭代器(Iterator)？

Iterator 接口，就是一种迭代器设计模式，让我们以相同的方式，遍历不同的数据结构元素。让每个一个集合类都包去实现具体的的迭代方法。`注意：迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的 #remove(Object Obj) 方法删除，可以通过迭代器的 #remove() 方法删除。`

#### Iterator 和 ListIterator 的区别是什么？

- Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。
- Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。
- ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。

### 什么是快速失败(fail-fast)？什么是安全失败(fail-safe)呢？



### 序列化和反序列化？（未完成）

## 熟悉

### 能画个2-3树吗?

![image-20200907145208543](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200907145211.png)

### 能画个红黑树吗？

![image-20200907145058168](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200907145105.png)



### Java 集合框架的基础接口有哪些？

为集合层级的根接口Collection。 以及继承Collection的，有序允许重复的Lsit接口和不允许重复的Set 接口。

存键值对对象的Map接口，消息队列的Queue，用来遍历的Iterator等。

### LinkedHashSet（链式散列集）的怎么实现的？

LinkedHashSet继承HashSet，而HashSet是基于HashMap实现的，new LinkedHashSet 时追加调用HashSet专门给它提供的构造器，又因为LinkedHashMap为HashMap的子类，直接`HashMap<E,Object> map =new LinkedHashMap<>(）`，剩下的方法和父类HashSet复用，只是操作的是LinkedHashMap。

### （未完成）集合中的Queue？

### 请详细讲述一下 RandomAccess 接口有什么作用（待整理）？

​	是一种标记接口
​		用来当标记的
​		接口的非典型用法
​	随机访问任意下标元素都比较快
​	用处
​		当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法





## 了解

### WeakHashMap？

![image-20200908165722417](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200908165724.png)

### 为什么扩容？

### java中HashMap节点和红黑树具体的数据结构？

Node：hash，key，value，next指针

TreeNode：除了继承Node的外，还有父节点、左、右节点的指针，记录转换前链表元素顺序的prev指针。`还有继承LinkedHashMap的before、after`

### 为何 Collection 不继承 Cloneable 和 Serializable 接口？

当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用，而Collection是抽象出来的行为类。

### 为何 Map 接口不继承 Collection 接口？

目的不一样，Map 接口是为了存键值对抽象出来的， Collection 接口是为了存一组元素抽象出来的。

### Collection 和 Collections 的区别？

Collection是集合类的上级接口，Collections 是针对集合类的一个工具类，搜索、排序、最大最小值等

### HashMap继承了哪些接口？

AbstractMap、Map、Cloneable、Serializable

### 解决Hash冲突的几种方法？

开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
		再哈希法
		链地址法
		公共溢出区

用拉链发是因为冲突简单，无堆积，链表上的结点空间是动态申请的。

### （新）ArrayList有几种初始化方式？

- `普通方式`：ArrayList<String> list = new ArrayList<String>();
- `内部类方式`：![image-20200911113041266](https://gitee.com//chenchong0817/picture/raw/master/Aaron/20200911113042.png)
- `Arrays.asList`：ArrayList<String> list = new ArrayList<String>(Arrays.asList("aaa", "bbb", "ccc"));
- `Collections.ncopies`：Collections.nCopies 是集合方法中用于生成多少份某个指定元素的方法。例如：ArrayList<Integer> list = new ArrayList<Integer>(Collections.nCopies(10, 0));这会初始化一个由10个0组成的集合。

### 红黑树需要比较大小才能进行插入，是依据什么进行比较的？

是根据插入节点的hash值比较的

### 如何删除 List 中的某个元素？

有两种方式，分别如下：

- 方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。
- 方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。

### Enumeration 和 Iterator 接口有什么不同？

- Enumeration 跟 Iterator 相比较快两倍，而且占用更少的内存。
- 但是，Iterator 相对于 Enumeration 更安全，因为其他线程不能修改当前迭代器遍历的集合对象。同时，Iterators 允许调用者从底层集合中移除元素，这些 Enumerations 都没法完成。

对于很多胖友，可能并未使用过 Enumeration 类，所以可以看看 [《Java Enumeration 接口》](http://www.runoob.com/java/java-enumeration-interface.html) 文章。

### Comparable 和 Comparator 的区别?

- Comparable 接口，在 `java.lang` 包下，用于当前对象和其它对象的比较，所以它有一个 `#compareTo(Object obj)` 方法用来排序，该方法只有一个参数。
- Comparator 接口，在 `java.util` 包下，用于传入的两个对象的比较，所以它有一个 `#compare(Object obj1, Object obj2)` 方法用来排序，该方法有两个参数。

详细的，可以看看 [《Java 自定义比较器》](https://blog.csdn.net/whing123/article/details/77851737) 文章，重点是如何自己实现 Comparable 和 Comparator 的方法。

🦅 **compareTo 方法的返回值表示的意思？**

- 大于 0 ，表示对象大于参数对象。
- 小于 0 ，表示对象小于参数对象
- 等于 0 ，表示两者相等。

🦅 **如何对 Object 的 List 排序？**

- 对 `Object[]` 数组进行排序时，我们可以用 `Arrays#sort(...)` 方法。
- 对 `List` 数组进行排序时，我们可以用 `Collections#sort(...)` 方法。